/*
** Biblioteca de Testes para Sol
** API extraordinária com grupos, hooks de ciclo de vida e relatórios
*/

#Defina testlib_c
#Defina SOL_LIB

#Inclua "prefix.int"

#Inclua <stdio.h>
#Inclua <string.h>
#Inclua <time.h>

#Inclua "sol.int"
#Inclua "auxlib.int"
#Inclua "solib.int"

/* Estado global de testes */
Pseudônimo Estrutura TestState {
    Inteiro total;
    Inteiro passou;
    Inteiro falhou;
    Inteiro pulados;
    clock_t inicio;
    Inteiro profundidade;
    Caractere descricao_atual[256];
} TestState;

Fixo TestState estado_global = {0, 0, 0, 0, 0, 0, ""};

/* Funções auxiliares de impressão */
Fixo Vazio imprime_indentacao(Inteiro nivel) {
    Inteiro i;
    Para (i = 0; i < nivel; i++) {
        printf("  ");
    }
}

Fixo Vazio imprime_simbolo(Imutável Caractere *simbolo, Imutável Caractere *cor) {
    printf("%s%s\033[0m ", cor, simbolo);
}

/* ========== ASSERÇÕES ========== */

Fixo Inteiro test_afirme(sol_State *L) {
    Inteiro cond = sol_toboolean(L, 1);
    Imutável Caractere *msg = sol_optstring(L, 2, "asserção falhou");
    
    Se (!cond) {
        Retorne solL_error(L, "%s", msg);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_igual(sol_State *L) {
    Inteiro igual = sol_compare(L, 1, 2, SOL_OPEQ);
    Se (!igual) {
        Imutável Caractere *msg = sol_optstring(L, 3, "valores não são iguais");
        sol_pushfstring(L, "%s\n  Esperado: %s\n  Atual: %s", 
            msg, solL_tolstring(L, 1, NULL), solL_tolstring(L, 2, NULL));
        Retorne sol_error(L);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_diferente(sol_State *L) {
    Inteiro igual = sol_compare(L, 1, 2, SOL_OPEQ);
    Se (igual) {
        Imutável Caractere *msg = sol_optstring(L, 3, "valores deveriam ser diferentes");
        Retorne solL_error(L, "%s", msg);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_verdadeiro(sol_State *L) {
    Se (!sol_toboolean(L, 1)) {
        Imutável Caractere *msg = sol_optstring(L, 2, "esperava verdadeiro");
        Retorne solL_error(L, "%s", msg);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_falso(sol_State *L) {
    Se (sol_toboolean(L, 1)) {
        Imutável Caractere *msg = sol_optstring(L, 2, "esperava falso");
        Retorne solL_error(L, "%s", msg);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_nulo(sol_State *L) {
    Se (!sol_isnil(L, 1)) {
        Imutável Caractere *msg = sol_optstring(L, 2, "esperava nulo");
        Retorne solL_error(L, "%s", msg);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_nao_nulo(sol_State *L) {
    Se (sol_isnil(L, 1)) {
        Imutável Caractere *msg = sol_optstring(L, 2, "não esperava nulo");
        Retorne solL_error(L, "%s", msg);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_tipo(sol_State *L) {
    Imutável Caractere *esperado = sol_checkstring(L, 1);
    Inteiro tipo = sol_type(L, 2);
    Imutável Caractere *nome_tipo = sol_typename(L, tipo);
    
    Se (strcmp(esperado, nome_tipo) != 0) {
        Imutável Caractere *msg = sol_optstring(L, 3, "tipo incorreto");
        sol_pushfstring(L, "%s\n  Esperado: %s\n  Atual: %s", msg, esperado, nome_tipo);
        Retorne sol_error(L);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_maior(sol_State *L) {
    Se (!sol_compare(L, 1, 2, SOL_OPLT)) {
        Se (!sol_compare(L, 2, 1, SOL_OPLT)) {
            Imutável Caractere *msg = sol_optstring(L, 3, "esperava a > b");
            Retorne solL_error(L, "%s", msg);
        }
    } Senão {
        Imutável Caractere *msg = sol_optstring(L, 3, "esperava a > b");
        Retorne solL_error(L, "%s", msg);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_menor(sol_State *L) {
    Se (!sol_compare(L, 1, 2, SOL_OPLT)) {
        Imutável Caractere *msg = sol_optstring(L, 3, "esperava a < b");
        Retorne solL_error(L, "%s", msg);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_maior_igual(sol_State *L) {
    Se (!sol_compare(L, 1, 2, SOL_OPLE)) {
        Imutável Caractere *msg = sol_optstring(L, 3, "esperava a >= b (invertido)");
        Retorne solL_error(L, "%s", msg);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_menor_igual(sol_State *L) {
    Se (!sol_compare(L, 1, 2, SOL_OPLE)) {
        Imutável Caractere *msg = sol_optstring(L, 3, "esperava a <= b");
        Retorne solL_error(L, "%s", msg);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_contem(sol_State *L) {
    sol_checktype(L, 1, SOL_TTABLE);
    sol_Integer tam = solL_len(L, 1);
    sol_Integer i;
    
    Para (i = 1; i <= tam; i++) {
        sol_geti(L, 1, i);
        Se (sol_compare(L, -1, 2, SOL_OPEQ)) {
            sol_pop(L, 1);
            Retorne 0;
        }
        sol_pop(L, 1);
    }
    
    Imutável Caractere *msg = sol_optstring(L, 3, "valor não encontrado na tabela");
    Retorne solL_error(L, "%s", msg);
}

Fixo Inteiro test_afirme_tamanho(sol_State *L) {
    sol_Integer esperado = sol_checkinteger(L, 1);
    sol_Integer atual = solL_len(L, 2);
    
    Se (esperado != atual) {
        Imutável Caractere *msg = sol_optstring(L, 3, "tamanho incorreto");
        sol_pushfstring(L, "%s\n  Esperado: %d\n  Atual: %d", msg, (Inteiro)esperado, (Inteiro)atual);
        Retorne sol_error(L);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_vazio(sol_State *L) {
    sol_Integer tam = solL_len(L, 1);
    Se (tam != 0) {
        Imutável Caractere *msg = sol_optstring(L, 2, "esperava tabela vazia");
        Retorne solL_error(L, "%s (tamanho: %d)", msg, (Inteiro)tam);
    }
    Retorne 0;
}

Fixo Inteiro test_afirme_erro(sol_State *L) {
    sol_checktype(L, 1, SOL_TFUNCTION);
    Inteiro status = sol_pcall(L, 0, 0, 0);
    Se (status == SOL_OK) {
        Imutável Caractere *msg = sol_optstring(L, 2, "esperava que lançasse erro");
        Retorne solL_error(L, "%s", msg);
    }
    sol_pop(L, 1);
    Retorne 0;
}

Fixo Inteiro test_afirme_sem_erro(sol_State *L) {
    sol_checktype(L, 1, SOL_TFUNCTION);
    Inteiro status = sol_pcall(L, 0, 0, 0);
    Se (status != SOL_OK) {
        Imutável Caractere *msg = sol_optstring(L, 2, "não esperava erro");
        sol_pushfstring(L, "%s: %s", msg, sol_tostring(L, -1));
        Retorne sol_error(L);
    }
    Retorne 0;
}

Fixo Inteiro test_falhe(sol_State *L) {
    Imutável Caractere *msg = sol_optstring(L, 1, "falha forçada");
    Retorne solL_error(L, "%s", msg);
}

Fixo Inteiro test_pule(sol_State *L) {
    estado_global.pulados++;
    Imutável Caractere *msg = sol_optstring(L, 1, "");
    sol_pushstring(L, "__SKIP__");
    sol_pushstring(L, msg);
    Retorne 2;
}

/* ========== HOOKS ========== */

Fixo Inteiro test_antes_de_todos(sol_State *L) {
    sol_checktype(L, 1, SOL_TFUNCTION);
    sol_setfield(L, SOL_REGISTRYINDEX, "__test_antes_todos__");
    Retorne 0;
}

Fixo Inteiro test_antes_de_cada(sol_State *L) {
    sol_checktype(L, 1, SOL_TFUNCTION);
    sol_setfield(L, SOL_REGISTRYINDEX, "__test_antes_cada__");
    Retorne 0;
}

Fixo Inteiro test_depois_de_cada(sol_State *L) {
    sol_checktype(L, 1, SOL_TFUNCTION);
    sol_setfield(L, SOL_REGISTRYINDEX, "__test_depois_cada__");
    Retorne 0;
}

Fixo Inteiro test_depois_de_todos(sol_State *L) {
    sol_checktype(L, 1, SOL_TFUNCTION);
    sol_setfield(L, SOL_REGISTRYINDEX, "__test_depois_todos__");
    Retorne 0;
}

Fixo Inteiro test_descreva(sol_State *L) {
    Imutável Caractere *desc = sol_checkstring(L, 1);
    strncpy(estado_global.descricao_atual, desc, 255);
    estado_global.descricao_atual[255] = '\0';
    Retorne 0;
}

/* ========== EXECUTORES ========== */

Fixo Vazio executar_hook(sol_State *L, Imutável Caractere *nome) {
    sol_getfield(L, SOL_REGISTRYINDEX, nome);
    Se (sol_isfunction(L, -1)) {
        sol_pcall(L, 0, 0, 0);
    } Senão {
        sol_pop(L, 1);
    }
}

Fixo Inteiro test_caso(sol_State *L) {
    Imutável Caractere *nome = sol_checkstring(L, 1);
    sol_checktype(L, 2, SOL_TFUNCTION);
    
    estado_global.total++;
    
    imprime_indentacao(estado_global.profundidade + 1);
    
    executar_hook(L, "__test_antes_cada__");
    
    sol_pushvalue(L, 2);
    Inteiro status = sol_pcall(L, 0, 2, 0);
    
    Se (status == SOL_OK) {
        Se (sol_isstring(L, -2) && strcmp(sol_tostring(L, -2), "__SKIP__") == 0) {
            printf("\033[33m○\033[0m %s \033[33m[PULADO]\033[0m", nome);
            Se (sol_isstring(L, -1) && strlen(sol_tostring(L, -1)) > 0) {
                printf(" - %s", sol_tostring(L, -1));
            }
            printf("\n");
            sol_pop(L, 2);
        } Senão {
            estado_global.passou++;
            printf("\033[32m✓\033[0m %s\n", nome);
            sol_pop(L, 2);
        }
    } Senão {
        estado_global.falhou++;
        printf("\033[31m✗\033[0m %s\n", nome);
        imprime_indentacao(estado_global.profundidade + 2);
        printf("\033[31m└─ %s\033[0m\n", sol_tostring(L, -1));
        sol_pop(L, 1);
    }
    
    executar_hook(L, "__test_depois_cada__");
    
    Retorne 0;
}

Fixo Inteiro test_grupo(sol_State *L) {
    Imutável Caractere *nome = sol_checkstring(L, 1);
    sol_checktype(L, 2, SOL_TFUNCTION);
    
    estado_global.descricao_atual[0] = '\0';
    
    imprime_indentacao(estado_global.profundidade);
    printf("\033[1m%s\033[0m\n", nome);
    
    estado_global.profundidade++;
    
    sol_pushnil(L);
    sol_setfield(L, SOL_REGISTRYINDEX, "__test_antes_todos__");
    sol_pushnil(L);
    sol_setfield(L, SOL_REGISTRYINDEX, "__test_antes_cada__");
    sol_pushnil(L);
    sol_setfield(L, SOL_REGISTRYINDEX, "__test_depois_cada__");
    sol_pushnil(L);
    sol_setfield(L, SOL_REGISTRYINDEX, "__test_depois_todos__");
    
    sol_pushvalue(L, 2);
    Inteiro status = sol_pcall(L, 0, 0, 0);
    
    Se (strlen(estado_global.descricao_atual) > 0) {
        imprime_indentacao(estado_global.profundidade);
        printf("\033[90m\"%s\"\033[0m\n", estado_global.descricao_atual);
    }
    
    Se (status == SOL_OK) {
        executar_hook(L, "__test_antes_todos__");
    }
    
    Se (status != SOL_OK) {
        printf("\033[31mErro no grupo: %s\033[0m\n", sol_tostring(L, -1));
        sol_pop(L, 1);
    }
    
    executar_hook(L, "__test_depois_todos__");
    
    estado_global.profundidade--;
    
    Retorne 0;
}

Fixo Inteiro test_execute(sol_State *L) {
    estado_global.inicio = clock();
    Retorne 0;
}

Fixo Inteiro test_relatorio(sol_State *L) {
    clock_t fim = clock();
    Real tempo = (Real)(fim - estado_global.inicio) / CLOCKS_PER_SEC;
    
    printf("\n");
    printf("\033[1m╔══════════════════════════════════════════════════════════╗\033[0m\n");
    printf("\033[1m║                    RELATÓRIO DE TESTES                   ║\033[0m\n");
    printf("\033[1m╠══════════════════════════════════════════════════════════╣\033[0m\n");
    printf("\033[1m║\033[0m  Total: %d | ", estado_global.total);
    printf("\033[32m✓ Passou: %d\033[0m | ", estado_global.passou);
    printf("\033[31m✗ Falhou: %d\033[0m | ", estado_global.falhou);
    printf("\033[33m○ Pulados: %d\033[0m\n", estado_global.pulados);
    printf("\033[1m║\033[0m  Tempo: %.3fs\n", tempo);
    printf("\033[1m╚══════════════════════════════════════════════════════════╝\033[0m\n");
    
    Se (estado_global.falhou > 0) {
        sol_pushboolean(L, 0);
    } Senão {
        sol_pushboolean(L, 1);
    }
    
    Retorne 1;
}

Fixo Inteiro test_reinicie(sol_State *L) {
    estado_global.total = 0;
    estado_global.passou = 0;
    estado_global.falhou = 0;
    estado_global.pulados = 0;
    estado_global.profundidade = 0;
    estado_global.descricao_atual[0] = '\0';
    Retorne 0;
}

/* ========== REGISTRO ========== */

Fixo Imutável sol_Reg testlib[] = {
    /* Asserções */
    {"afirme", test_afirme},
    {"afirme_igual", test_afirme_igual},
    {"afirme_diferente", test_afirme_diferente},
    {"afirme_verdadeiro", test_afirme_verdadeiro},
    {"afirme_falso", test_afirme_falso},
    {"afirme_nulo", test_afirme_nulo},
    {"afirme_não_nulo", test_afirme_nao_nulo},
    {"afirme_tipo", test_afirme_tipo},
    {"afirme_maior", test_afirme_maior},
    {"afirme_menor", test_afirme_menor},
    {"afirme_maior_igual", test_afirme_maior_igual},
    {"afirme_menor_igual", test_afirme_menor_igual},
    {"afirme_contem", test_afirme_contem},
    {"afirme_tamanho", test_afirme_tamanho},
    {"afirme_vazio", test_afirme_vazio},
    {"afirme_erro", test_afirme_erro},
    {"afirme_sem_erro", test_afirme_sem_erro},
    {"falhe", test_falhe},
    {"pule", test_pule},
    
    /* Hooks */
    {"antes_de_todos", test_antes_de_todos},
    {"antes_de_cada", test_antes_de_cada},
    {"depois_de_cada", test_depois_de_cada},
    {"depois_de_todos", test_depois_de_todos},
    {"descreva", test_descreva},
    
    /* Executores */
    {"grupo", test_grupo},
    {"caso", test_caso},
    {"execute", test_execute},
    {"relatorio", test_relatorio},
    {"reinicie", test_reinicie},
    
    {NULL, NULL}
};

SOLMOD_API Inteiro solopen_test(sol_State *L) {
    sol_newlib(L, testlib);
    
    estado_global.total = 0;
    estado_global.passou = 0;
    estado_global.falhou = 0;
    estado_global.pulados = 0;
    estado_global.inicio = clock();
    estado_global.profundidade = 0;
    
    Retorne 1;
}
