#Defina SOL_LIB

#Inclua "sol.int"
#Inclua "auxlib.int"
#Inclua "solib.int"

#Inclua <windows.h>
#Inclua <stdlib.h>
#Inclua <string.h>
#Inclua <stdio.h>

#Defina MALA_DE_FERRAMENTAS    (20)

Pseudônimo Estrutura {
    HANDLE mutex;
    HANDLE event;
    Inteiro ref_count;
    Inteiro has_data;
    Caractere data[4096];
    Inteiro closed;
} Channel;

Fixo Channel* channel_create(Vazio) {
    Channel *c = (Channel*)malloc(meça(Channel));
    c->mutex = CreateMutex(NULL, 0, NULL);
    c->event = CreateEvent(NULL, 0, 0, NULL);
    c->ref_count = 1;
    c->has_data = 0;
    c->closed = 0;
    Retorne c;
}

Fixo Vazio channel_ref(Channel *c) {
    WaitForSingleObject(c->mutex, INFINITE);
    c->ref_count++;
    ReleaseMutex(c->mutex);
}

Fixo Vazio channel_unref(Channel *c) {
    WaitForSingleObject(c->mutex, INFINITE);
    c->ref_count--;
    Inteiro count = c->ref_count;
    ReleaseMutex(c->mutex);
    
    Se (count == 0) {
        CloseHandle(c->mutex);
        CloseHandle(c->event);
        free(c);
        printf("[DEBUG] Channel freed\n");
    }
}

Pseudônimo Estrutura {
    Caractere *script;
    Channel *channel_arg;
} ThreadData;

Natural worker_thread(Vazio *arg) {
    ThreadData *td = (ThreadData *)arg;
    
    sol_State *L = solL_newstate();
    sol_openselectedlibs(L, ~0, 0); 
    
    Inteiro status = sol_loadstring(L, td->script);
    Se (status != 0) {
        printf("Erro ao carregar script na thread: %s\n", sol_tostring(L, -1));
        sol_close(L);
        free(td->script);
        Se (td->channel_arg) channel_unref(td->channel_arg);
        free(td);
        Retorne 0;
    }
    
    Inteiro nargs = 0;
    Se (td->channel_arg) {
        Channel **ud = (Channel**)sol_newuserdatauv(L, meça(Channel*), 0);
        *ud = td->channel_arg;
        solL_setmetatable(L, "Sol.Channel");
        nargs = 1;
    }
    
    status = sol_pcall(L, nargs, SOL_MULTRET, 0);
    Se (status != 0) {
        printf("Erro na thread: %s\n", sol_tostring(L, -1));
    }
    
    sol_close(L);
    free(td->script);
    free(td);
    Retorne 0;
}

Fixo Inteiro channel_gc (sol_State *L) {
    Channel **c = (Channel**)sol_testudata(L, 1, "Sol.Channel");
    Se (c && *c) {
        channel_unref(*c);
        *c = NULL;
    }
    Retorne 0;
}

Fixo Inteiro parallel_channel (sol_State *L) {
    Channel *c = channel_create();
    Channel **ud = (Channel**)sol_newuserdatauv(L, meça(Channel*), 0);
    *ud = c;
    
    solL_setmetatable(L, "Sol.Channel");
    Retorne 1;
}

Fixo Vazio create_channel_meta(sol_State *L) {
    sol_newmetatable(L, "Sol.Channel");
    sol_pushcfunction(L, channel_gc);
    sol_setfield(L, -2, "__coletor_lixo");
    sol_pop(L, 1);
}

Fixo Inteiro parallel_execute (sol_State *L) {
    Imutável Caractere *script = sol_checkstring(L, 1);
    Channel *c_arg = NULL;
    
    Se (sol_gettop(L) >= 2) {
        Channel **ud = (Channel**)sol_testudata(L, 2, "Sol.Channel");
        Se (ud && *ud) {
            c_arg = *ud;
            channel_ref(c_arg);
        }
    }
    
    ThreadData *td = (ThreadData *)malloc(meça(ThreadData));
    td->script = strdup(script);
    td->channel_arg = c_arg;
    
    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)worker_thread, td, 0, NULL);
    
    Se (hThread == NULL) {
        free(td->script);
        Se (c_arg) channel_unref(c_arg);
        free(td);
        Retorne solL_error(L, "falha ao criar thread");
    }
    
    CloseHandle(hThread);
    
    sol_pushboolean(L, 1);
    Retorne 1;
}

Fixo Inteiro parallel_send (sol_State *L) {
    Channel **ud = (Channel**)sol_checkudata(L, 1, "Sol.Channel");
    Imutável Caractere *msg = sol_checkstring(L, 2);
    size_t len = strlen(msg);
    
    Se (!ud || !*ud) Retorne solL_error(L, "canal invalido");
    Channel *c = *ud;
    
    WaitForSingleObject(c->mutex, INFINITE);
    
    Se (len >= 4096) len = 4095;
    memcpy(c->data, msg, len);
    c->data[len] = '\0';
    c->has_data = 1;
    
    SetEvent(c->event);
    ReleaseMutex(c->mutex);
    
    sol_pushboolean(L, 1);
    Retorne 1;
}

Fixo Inteiro parallel_receive (sol_State *L) {
    Channel **ud = (Channel**)sol_checkudata(L, 1, "Sol.Channel");
    Se (!ud || !*ud) Retorne solL_error(L, "canal invalido");
    Channel *c = *ud;
    
    WaitForSingleObject(c->mutex, INFINITE);
    
    Enquanto (!c->has_data) {
        ReleaseMutex(c->mutex);
        WaitForSingleObject(c->event, INFINITE);
        WaitForSingleObject(c->mutex, INFINITE);
    }
    
    sol_pushstring(L, c->data);
    c->has_data = 0;
    
    ReleaseMutex(c->mutex);
    Retorne 1;
}

Fixo Imutável sol_Reg parallellib[] = {
  {"execute", parallel_execute},
  {"canal", parallel_channel},
  {"envie", parallel_send},
  {"receba", parallel_receive},
  {NULL, NULL}
};

SOLMOD_API Inteiro solopen_parallel (sol_State *L) {
  create_channel_meta(L);
  sol_newlib(L, parallellib);
  Retorne 1;
}
