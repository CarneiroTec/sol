/*
** $Id: code.h $
** Code generator Para Sol
** See Direitos Autorais Notice in sol.h
*/

#SeNãoDefinido code_h
#Defina code_h

#Inclua "lex.int"
#Inclua "object.int"
#Inclua "opcodes.int"
#Inclua "parser.int"


/*
** Marks the end of a patch list. It is an invalid value both as an absolute
** address, and as a list link (would link an element to itself).
*/
#Defina NO_JUMP (-1)


/*
** grep "ORDER OPR" Se you change these enums  (ORDER OP)
*/
Pseudônimo Enumeração BinOpr {
  /* arithmetic operators */
  OPR_ADD, OPR_SUB, OPR_MUL, OPR_MOD, OPR_POW,
  OPR_DIV, OPR_IDIV,
  /* bitwise operators */
  OPR_BAND, OPR_BOR, OPR_BXOR,
  OPR_SHL, OPR_SHR,
  /* string operator */
  OPR_CONCAT,
  /* comparison operators */
  OPR_EQ, OPR_LT, OPR_LE,
  OPR_NE, OPR_GT, OPR_GE,
  /* logical operators */
  OPR_AND, OPR_OR,
  OPR_NOBINOPR
} BinOpr;


/* true Se operation is foldable (that is, it is arithmetic or bitwise) */
#Defina foldbinop(op)	((op) <= OPR_SHR)


#Defina sol_k_codeABC(fs,o,a,b,c)	sol_k_codeABCk(fs,o,a,b,c,0)


Pseudônimo Enumeração UnOpr { OPR_MINUS, OPR_BNOT, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;


/* get (pointer to) instruction of given 'expdesc' */
#Defina getinstruction(fs,e)	((fs)->f->code[(e)->u.info])


#Defina sol_k_setmultret(fs,e)	sol_k_setreturns(fs, e, SOL_MULTRET)

#Defina sol_k_jumpto(fs,t)	sol_k_patchlist(fs, sol_k_jump(fs), t)

SOL_FUNC Inteiro sol_k_code (FuncState *fs, Instruction i);
SOL_FUNC Inteiro sol_k_codeABx (FuncState *fs, OpCode o, Inteiro A, Inteiro Bx);
SOL_FUNC Inteiro sol_k_codeABCk (FuncState *fs, OpCode o, Inteiro A, Inteiro B, Inteiro C,
                                            Inteiro k);
SOL_FUNC Inteiro sol_k_codevABCk (FuncState *fs, OpCode o, Inteiro A, Inteiro B, Inteiro C,
                                             Inteiro k);
SOL_FUNC Inteiro sol_k_exp2const (FuncState *fs, Imutável expdesc *e, TValue *v);
SOL_FUNC Vazio sol_k_fixline (FuncState *fs, Inteiro Linha);
SOL_FUNC Vazio sol_k_nil (FuncState *fs, Inteiro from, Inteiro n);
SOL_FUNC Vazio sol_k_reserveregs (FuncState *fs, Inteiro n);
SOL_FUNC Vazio sol_k_checkstack (FuncState *fs, Inteiro n);
SOL_FUNC Vazio sol_k_int (FuncState *fs, Inteiro reg, sol_Integer n);
SOL_FUNC Vazio sol_k_dischargevars (FuncState *fs, expdesc *e);
SOL_FUNC Inteiro sol_k_exp2anyreg (FuncState *fs, expdesc *e);
SOL_FUNC Vazio sol_k_exp2anyregup (FuncState *fs, expdesc *e);
SOL_FUNC Vazio sol_k_exp2nextreg (FuncState *fs, expdesc *e);
SOL_FUNC Vazio sol_k_exp2val (FuncState *fs, expdesc *e);
SOL_FUNC Vazio sol_k_self (FuncState *fs, expdesc *e, expdesc *key);
SOL_FUNC Vazio sol_k_indexed (FuncState *fs, expdesc *t, expdesc *k);
SOL_FUNC Vazio sol_k_goiftrue (FuncState *fs, expdesc *e);
SOL_FUNC Vazio sol_k_goiffalse (FuncState *fs, expdesc *e);
SOL_FUNC Vazio sol_k_storevar (FuncState *fs, expdesc *var, expdesc *e);
SOL_FUNC Vazio sol_k_setreturns (FuncState *fs, expdesc *e, Inteiro nresults);
SOL_FUNC Vazio sol_k_setoneret (FuncState *fs, expdesc *e);
SOL_FUNC Inteiro sol_k_jump (FuncState *fs);
SOL_FUNC Vazio sol_k_ret (FuncState *fs, Inteiro first, Inteiro nret);
SOL_FUNC Vazio sol_k_patchlist (FuncState *fs, Inteiro list, Inteiro target);
SOL_FUNC Vazio sol_k_patchtohere (FuncState *fs, Inteiro list);
SOL_FUNC Vazio sol_k_concat (FuncState *fs, Inteiro *l1, Inteiro l2);
SOL_FUNC Inteiro sol_k_getlabel (FuncState *fs);
SOL_FUNC Vazio sol_k_prefix (FuncState *fs, UnOpr op, expdesc *v, Inteiro Linha);
SOL_FUNC Vazio sol_k_infix (FuncState *fs, BinOpr op, expdesc *v);
SOL_FUNC Vazio sol_k_posfix (FuncState *fs, BinOpr op, expdesc *v1,
                            expdesc *v2, Inteiro Linha);
SOL_FUNC Vazio sol_k_settablesize (FuncState *fs, Inteiro pc,
                                  Inteiro ra, Inteiro asize, Inteiro hsize);
SOL_FUNC Vazio sol_k_setlist (FuncState *fs, Inteiro base, Inteiro nelems, Inteiro tostore);
SOL_FUNC Vazio sol_k_finish (FuncState *fs);
SOL_FUNC l_noret sol_k_semerror (LexState *ls, Imutável Caractere *fmt, ...);


#FimSe
