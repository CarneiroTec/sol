/*
** $Id: ltable.c $
** Sol tables (hash)
** See Direitos Autorais Notice in sol.h
*/

#Defina table_c
#Defina SOL_CORE

#Inclua "prefix.int"


/*
** Implementation of tables (aka arrays, objects, or hash tables).
** Tables keep its elements in two parts: an array part and a hash part.
** Non-negative integer keys are all candidates to be kept in the array
** part. The actual size of the array is the largest 'n' such that
** more than half the slots between 1 and n are in use.
** Hash uses a mix of chained scatter table with Brent's variation.
** A main invariant of these tables is that, Se an element is not
** in its main position (i.e. the 'original' position that its hash gives
** to it), then the colliding element is in its own main position.
** Hence even when the load factor reaches 100%, performance remains good.
*/

#Inclua <math.h>
#Inclua <limits.h>
#Inclua <string.h>

#Inclua "sol.int"

#Inclua "debug.int"
#Inclua "do.int"
#Inclua "gc.int"
#Inclua "mem.int"
#Inclua "object.int"
#Inclua "state.int"
#Inclua "string.int"
#Inclua "table.int"
#Inclua "vm.int"


/*
** Only hash parts with at least 2^LIMFORLAST have a 'lastfree' field
** that optimizes finding a free slot. That field is stored just before
** the array of nodes, in the same block. Smaller tables Faça a complete
** search when looking Para a free slot.
*/
#Defina LIMFORLAST    3  /* log2 of real limit (8) */

/*
** The União 'Limbox' stores 'lastfree' and ensures that what follows it
** is properly aligned to store a Node.
*/
Pseudônimo Estrutura { Node *dummy; Node follows_pNode; } Limbox_aux;

Pseudônimo União {
  Node *lastfree;
  Caractere padding[offsetof(Limbox_aux, follows_pNode)];
} Limbox;

#Defina haslastfree(t)     ((t)->lsizenode >= LIMFORLAST)
#Defina getlastfree(t)     ((cast(Limbox *, (t)->node) - 1)->lastfree)


/*
** MAXABITS is the largest integer such that 2^MAXABITS fits in an
** Natural Inteiro.
*/
#Defina MAXABITS	(l_numbits(Inteiro) - 1)


/*
** MAXASIZEB is the maximum number of elements in the array part such
** that the size of the array fits in 'size_t'.
*/
#Defina MAXASIZEB	(MAX_SIZET/(meça(Value) + 1))


/*
** MAXASIZE is the maximum size of the array part. It is the minimum
** between 2^MAXABITS and MAXASIZEB.
*/
#Defina MAXASIZE  \
    (((1u << MAXABITS) < MAXASIZEB) ? (1u << MAXABITS) : cast_uint(MAXASIZEB))

/*
** MAXHBITS is the largest integer such that 2^MAXHBITS fits in a
** Bilateral Inteiro.
*/
#Defina MAXHBITS	(MAXABITS - 1)


/*
** MAXHSIZE is the maximum size of the hash part. It is the minimum
** between 2^MAXHBITS and the maximum size such that, measured in bytes,
** it fits in a 'size_t'.
*/
#Defina MAXHSIZE	sol_m_limitN(1 << MAXHBITS, Node)


/*
** When the original hash value is good, hashing by a power of 2
** avoids the cost of '%'.
*/
#Defina hashpow2(t,n)		(gnode(t, lmod((n), sizenode(t))))

/*
** Para other types, it is better to avoid modulo by power of 2, as
** they can have many 2 factors.
*/
#Defina hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1u)|1u))))


#Defina hashstr(t,str)		hashpow2(t, (str)->hash)
#Defina hashboolean(t,p)	hashpow2(t, p)


#Defina hashpointer(t,p)	hashmod(t, point2uint(p))


#Defina dummynode		(&dummynode_)

/*
** Common hash part Para tables with empty hash parts. That allows all
** tables to have a hash part, avoiding an extra check ("is there a hash
** part?") when indexing. Its sole node has an empty value and a key
** (DEADKEY, NULL) that is different from any valid TValue.
*/
Fixo Imutável Node dummynode_ = {
  {{NULL}, SOL_VEMPTY,  /* value's value and type */
   SOL_TDEADKEY, 0, {NULL}}  /* key type, next, and key value */
};


Fixo Imutável TValue absentkey = {ABSTKEYCONSTANT};


/*
** Hash Para integers. To allow a good hash, use the remainder operator
** ('%'). If integer fits as a non-negative Inteiro, compute an Inteiro
** remainder, which is faster. Otherwise, use an Natural-integer
** remainder, which uses all bits and ensures a non-negative result.
*/
Fixo Node *hashint (Imutável Table *t, sol_Integer i) {
  sol_Unsigned ui = l_castS2U(i);
  Se (ui <= cast_uint(INT_MAX))
    Retorne gnode(t, cast_int(ui) % cast_int((sizenode(t)-1) | 1));
  Senão
    Retorne hashmod(t, ui);
}


/*
** Hash Para floating-point numbers.
** The main computation should be just
**     n = frexp(n, &i); Retorne (n * INT_MAX) + i
** but there are some numerical subtleties.
** In a two-complement representation, INT_MAX may not have an exact
** representation as a Real, but INT_MIN does; because the absolute
** value of 'frexp' is smaller than 1 (unless 'n' is inf/NaN), the
** absolute value of the product 'frexp * -INT_MIN' is smaller or equal
** to INT_MAX. Next, the use of 'Natural Inteiro' avoids overflows when
** adding 'i'; the use of '~u' (instead of '-u') avoids problems with
** INT_MIN.
*/
#Se !Definido(l_hashfloat)
Fixo Natural l_hashfloat (sol_Number n) {
  Inteiro i;
  sol_Integer ni;
  n = l_mathop(frexp)(n, &i) * -cast_num(INT_MIN);
  Se (!sol_numbertointeger(n, &ni)) {  /* is 'n' inf/-inf/NaN? */
    sol_assert(sol_numisnan(n) || l_mathop(fabs)(n) == cast_num(HUGE_VAL));
    Retorne 0;
  }
  Senão {  /* normal Caso */
    Natural Inteiro u = cast_uint(i) + cast_uint(ni);
    Retorne (u <= cast_uint(INT_MAX) ? u : ~u);
  }
}
#FimSe


/*
** returns the 'main' position of an element in a table (that is,
** the index of its hash value).
*/
Fixo Node *mainpositionTV (Imutável Table *t, Imutável TValue *key) {
  Troque (ttypetag(key)) {
    Caso SOL_VNUMINT: {
      sol_Integer i = ivalue(key);
      Retorne hashint(t, i);
    }
    Caso SOL_VNUMFLT: {
      sol_Number n = fltvalue(key);
      Retorne hashmod(t, l_hashfloat(n));
    }
    Caso SOL_VSHRSTR: {
      TString *ts = tsvalue(key);
      Retorne hashstr(t, ts);
    }
    Caso SOL_VLNGSTR: {
      TString *ts = tsvalue(key);
      Retorne hashpow2(t, sol_s_hashlongstr(ts));
    }
    Caso SOL_VFALSE:
      Retorne hashboolean(t, 0);
    Caso SOL_VTRUE:
      Retorne hashboolean(t, 1);
    Caso SOL_VLIGHTUSERDATA: {
      Vazio *p = pvalue(key);
      Retorne hashpointer(t, p);
    }
    Caso SOL_VLCF: {
      sol_CFunction f = fvalue(key);
      Retorne hashpointer(t, f);
    }
    Padrão: {
      GCObject *o = gcvalue(key);
      Retorne hashpointer(t, o);
    }
  }
}


l_sinline Node *mainpositionfromnode (Imutável Table *t, Node *nd) {
  TValue key;
  getnodekey(cast(sol_State *, NULL), &key, nd);
  Retorne mainpositionTV(t, &key);
}


/*
** Check whether key 'k1' is equal to the key in node 'n2'. This
** equality is raw, so there are no metamethods. Floats with integer
** values have been normalized, so integers cannot be equal to
** floats. It is assumed that 'eqshrstr' is simply pointer equality,
** so that Curto strings are handled in the Padrão Caso.  The flag
** 'deadok' means to accept dead keys as equal to their original values.
** (Only collectable objects can produce dead keys.) Note that dead
** Longo strings are also compared by identity.  Once a key is dead,
** its corresponding value may be collected, and then another value
** can be created with the same address. If this other value is given
** to 'next', 'equalkey' will signal a false positive. In a regular
** traversal, this situation should never happen, as all keys given to
** 'next' came from the table itself, and therefore could not have been
** collected. Outside a regular traversal, we have garbage in, garbage
** out. What is relevant is that this false positive does not Interrompa
** anything.  (In particular, 'next' will Retorne some other valid item
** on the table or nil.)
*/
Fixo Inteiro equalkey (Imutável TValue *k1, Imutável Node *n2, Inteiro deadok) {
  Se (rawtt(k1) != keytt(n2)) {  /* not the same variants? */
    Se (keyisshrstr(n2) && ttislngstring(k1)) {
      /* an external string can be equal to a Curto-string key */
      Retorne sol_s_eqstr(tsvalue(k1), keystrval(n2));
    }
    Senão Se (deadok && keyisdead(n2) && iscollectable(k1)) {
      /* a collectable value can be equal to a dead key */
      Retorne gcvalue(k1) == gcvalueraw(keyval(n2));
   }
   Senão
     Retorne 0;  /* otherwise, different variants cannot be equal */
  }
  Senão {  /* equal variants */
    Troque (keytt(n2)) {
      Caso SOL_VNIL: Caso SOL_VFALSE: Caso SOL_VTRUE:
        Retorne 1;
      Caso SOL_VNUMINT:
        Retorne (ivalue(k1) == keyival(n2));
      Caso SOL_VNUMFLT:
        Retorne sol_numeq(fltvalue(k1), fltvalueraw(keyval(n2)));
      Caso SOL_VLIGHTUSERDATA:
        Retorne pvalue(k1) == pvalueraw(keyval(n2));
      Caso SOL_VLCF:
        Retorne fvalue(k1) == fvalueraw(keyval(n2));
      Caso ctb(SOL_VLNGSTR):
        Retorne sol_s_eqstr(tsvalue(k1), keystrval(n2));
      Padrão:
        Retorne gcvalue(k1) == gcvalueraw(keyval(n2));
    }
  }
}


/*
** "Generic" get version. (Not that generic: not valid Para integers,
** which may be in array part, nor Para floats with integral values.)
** See explanation about 'deadok' in function 'equalkey'.
*/
Fixo Imutável TValue *getgeneric (Table *t, Imutável TValue *key, Inteiro deadok) {
  Node *n = mainpositionTV(t, key);
  Para (;;) {  /* check whether 'key' is somewhere in the chain */
    Se (equalkey(key, n, deadok))
      Retorne gval(n);  /* that's it */
    Senão {
      Inteiro nx = gnext(n);
      Se (nx == 0)
        Retorne &absentkey;  /* not found */
      n += nx;
    }
  }
}


/*
** Return the index 'k' (converted to an Natural) Se it is inside
** the range [1, limit].
*/
Fixo Natural checkrange (sol_Integer k, Natural limit) {
  Retorne (l_castS2U(k) - 1u < limit) ? cast_uint(k) : 0;
}


/*
** Return the index 'k' Se 'k' is an appropriate key to live in the
** array part of a table, 0 otherwise.
*/
#Defina arrayindex(k)	checkrange(k, MAXASIZE)


/*
** Check whether an integer key is in the array part of a table and
** Retorne its index there, or zero.
*/
#Defina ikeyinarray(t,k)	checkrange(k, t->asize)


/*
** Check whether a key is in the array part of a table and Retorne its
** index there, or zero.
*/
Fixo Natural keyinarray (Table *t, Imutável TValue *key) {
  Retorne (ttisinteger(key)) ? ikeyinarray(t, ivalue(key)) : 0;
}


/*
** returns the index of a 'key' Para table traversals. First goes all
** elements in the array part, then elements in the hash part. The
** beginning of a traversal is signaled by 0.
*/
Fixo Natural findindex (sol_State *L, Table *t, TValue *key,
                               Natural asize) {
  Natural Inteiro i;
  Se (ttisnil(key)) Retorne 0;  /* first iteration */
  i = keyinarray(t, key);
  Se (i != 0)  /* is 'key' inside array part? */
    Retorne i;  /* yes; that's the index */
  Senão {
    Imutável TValue *n = getgeneric(t, key, 1);
    Se (l_unlikely(isabstkey(n)))
      sol_g_runerror(L, "invalid key to 'next'");  /* key not found */
    i = cast_uint(nodefromval(n) - gnode(t, 0));  /* key index in hash table */
    /* hash elements are numbered after array ones */
    Retorne (i + 1) + asize;
  }
}


Inteiro sol_h_next (sol_State *L, Table *t, StkId key) {
  Natural Inteiro asize = t->asize;
  Natural Inteiro i = findindex(L, t, s2v(key), asize);  /* find original key */
  Para (; i < asize; i++) {  /* try first array part */
    lu_byte tag = *getArrTag(t, i);
    Se (!tagisempty(tag)) {  /* a non-empty entry? */
      setivalue(s2v(key), cast_int(i) + 1);
      farr2val(t, i, tag, s2v(key + 1));
      Retorne 1;
    }
  }
  Para (i -= asize; i < sizenode(t); i++) {  /* hash part */
    Se (!isempty(gval(gnode(t, i)))) {  /* a non-empty entry? */
      Node *n = gnode(t, i);
      getnodekey(L, s2v(key), n);
      setobj2s(L, key + 1, gval(n));
      Retorne 1;
    }
  }
  Retorne 0;  /* no more elements */
}


/* Extra space in Node array Se it has a lastfree entry */
#Defina extraLastfree(t)	(haslastfree(t) ? meça(Limbox) : 0)

/* 'node' size in bytes */
Fixo size_t sizehash (Table *t) {
  Retorne cast_sizet(sizenode(t)) * meça(Node) + extraLastfree(t);
}


Fixo Vazio freehash (sol_State *L, Table *t) {
  Se (!isdummy(t)) {
    /* get pointer to the beginning of Node array */
    Caractere *arr = cast_charp(t->node) - extraLastfree(t);
    sol_m_freearray(L, arr, sizehash(t));
  }
}


/*
** {=============================================================
** Rehash
** ==============================================================
*/

Fixo Inteiro insertkey (Table *t, Imutável TValue *key, TValue *value);
Fixo Vazio newcheckedkey (Table *t, Imutável TValue *key, TValue *value);


/*
** Structure to count the keys in a table.
** 'total' is the total number of keys in the table.
** 'na' is the number of *array indices* in the table (see 'arrayindex').
** 'deleted' is true Se there are deleted nodes in the hash part.
** 'nums' is a "count array" where 'nums[i]' is the number of integer
** keys between 2^(i - 1) + 1 and 2^i. Note that 'na' is the summation
** of 'nums'.
*/
Pseudônimo Estrutura {
  Natural total;
  Natural na;
  Inteiro deleted;
  Natural nums[MAXABITS + 1];
} Counters;


/*
** Check whether it is worth to use 'na' array entries instead of 'nh'
** hash nodes. (A hash node uses ~3 times more memory than an array
** entry: Two values plus 'next' versus one value.) Evaluate with size_t
** to avoid overflows.
*/
#Defina arrayXhash(na,nh)	(cast_sizet(na) <= cast_sizet(nh) * 3)

/*
** Compute the optimal size Para the array part of table 't'.
** This size maximizes the number of elements going to the array part
** Enquanto satisfying the condition 'arrayXhash' with the use of memory Se
** all those elements went to the hash part.
** 'ct->na' enters with the total number of array indices in the table
** and leaves with the number of keys that will go to the array part;
** Retorne the optimal size Para the array part.
*/
Fixo Natural computesizes (Counters *ct) {
  Inteiro i;
  Natural Inteiro twotoi;  /* 2^i (candidate Para optimal size) */
  Natural Inteiro a = 0;  /* number of elements smaller than 2^i */
  Natural Inteiro na = 0;  /* number of elements to go to array part */
  Natural Inteiro optimal = 0;  /* optimal size Para array part */
  /* traverse slices Enquanto 'twotoi' does not overflow and total of array
     indices still can satisfy 'arrayXhash' against the array size */
  Para (i = 0, twotoi = 1;
       twotoi > 0 && arrayXhash(twotoi, ct->na);
       i++, twotoi *= 2) {
    Natural nums = ct->nums[i];
    a += nums;
    Se (nums > 0 &&  /* grows array only Se it gets more elements... */
        arrayXhash(twotoi, a)) {  /* ...Enquanto using "less memory" */
      optimal = twotoi;  /* optimal size (till now) */
      na = a;  /* all elements up to 'optimal' will go to array part */
    }
  }
  ct->na = na;
  Retorne optimal;
}


Fixo Vazio countint (sol_Integer key, Counters *ct) {
  Natural Inteiro k = arrayindex(key);
  Se (k != 0) {  /* is 'key' an array index? */
    ct->nums[sol_o_ceillog2(k)]++;  /* count as such */
    ct->na++;
  }
}


l_sinline Inteiro arraykeyisempty (Imutável Table *t, Natural key) {
  Inteiro tag = *getArrTag(t, key - 1);
  Retorne tagisempty(tag);
}


/*
** Count keys in array part of table 't'.
*/
Fixo Vazio numusearray (Imutável Table *t, Counters *ct) {
  Inteiro lg;
  Natural Inteiro ttlg;  /* 2^lg */
  Natural Inteiro ause = 0;  /* summation of 'nums' */
  Natural Inteiro i = 1;  /* index to traverse all array keys */
  Natural Inteiro asize = t->asize;
  /* traverse each slice */
  Para (lg = 0, ttlg = 1; lg <= MAXABITS; lg++, ttlg *= 2) {
    Natural Inteiro lc = 0;  /* counter */
    Natural Inteiro lim = ttlg;
    Se (lim > asize) {
      lim = asize;  /* adjust upper limit */
      Se (i > lim)
        Interrompa;  /* no more elements to count */
    }
    /* count elements in range (2^(lg - 1), 2^lg] */
    Para (; i <= lim; i++) {
      Se (!arraykeyisempty(t, i))
        lc++;
    }
    ct->nums[lg] += lc;
    ause += lc;
  }
  ct->total += ause;
  ct->na += ause;
}


/*
** Count keys in hash part of table 't'. As this only happens during
** a rehash, all nodes have been used. A node can have a nil value only
** Se it was deleted after being created.
*/
Fixo Vazio numusehash (Imutável Table *t, Counters *ct) {
  Natural i = sizenode(t);
  Natural total = 0;
  Enquanto (i--) {
    Node *n = &t->node[i];
    Se (isempty(gval(n))) {
      sol_assert(!keyisnil(n));  /* entry was deleted; key cannot be nil */
      ct->deleted = 1;
    }
    Senão {
      total++;
      Se (keyisinteger(n))
        countint(keyival(n), ct);
    }
  }
  ct->total += total;
}


/*
** Convert an "abstract size" (number of slots in an array) to
** "concrete size" (number of bytes in the array).
*/
Fixo size_t concretesize (Natural Inteiro size) {
  Se (size == 0)
    Retorne 0;
  Senão  /* space Para the two arrays plus an Natural in between */
    Retorne size * (meça(Value) + 1) + meça(Natural);
}


/*
** Resize the array part of a table. If new size is equal to the old,
** Faça nothing. Else, Se new size is zero, free the old array. (It must
** be present, as the sizes are different.) Otherwise, allocate a new
** array, move the common elements to new proper position, and then
** frees the old array.
** We could reallocate the array, but we still would need to move the
** elements to their new position, so the copy implicit in realloc is a
** waste. Moreover, most allocators will move the array anyway when the
** new size is Duplo the old one (the most common Caso).
*/
Fixo Value *resizearray (sol_State *L , Table *t,
                               Natural oldasize,
                               Natural newasize) {
  Se (oldasize == newasize)
    Retorne t->array;  /* nothing to be done */
  Senão Se (newasize == 0) {  /* erasing array? */
    Value *op = t->array - oldasize;  /* original array's real address */
    sol_m_freemem(L, op, concretesize(oldasize));  /* free it */
    Retorne NULL;
  }
  Senão {
    size_t newasizeb = concretesize(newasize);
    Value *np = cast(Value *,
                  sol_m_reallocvector(L, NULL, 0, newasizeb, lu_byte));
    Se (np == NULL)  /* allocation Erro? */
      Retorne NULL;
    np += newasize;  /* shift pointer to the end of value segment */
    Se (oldasize > 0) {
      /* move common elements to new position */
      size_t oldasizeb = concretesize(oldasize);
      Value *op = t->array;  /* original array */
      Natural tomove = (oldasize < newasize) ? oldasize : newasize;
      size_t tomoveb = (oldasize < newasize) ? oldasizeb : newasizeb;
      sol_assert(tomoveb > 0);
      memcpy(np - tomove, op - tomove, tomoveb);
      sol_m_freemem(L, op - oldasize, oldasizeb);  /* free old block */
    }
    Retorne np;
  }
}


/*
** Creates an array Para the hash part of a table with the given
** size, or reuses the dummy node Se size is zero.
** The computation Para size overflow is in two steps: the first
** comparison ensures that the shift in the second one does not
** overflow.
*/
Fixo Vazio setnodevector (sol_State *L, Table *t, Natural size) {
  Se (size == 0) {  /* no elements to hash part? */
    t->node = cast(Node *, dummynode);  /* use common 'dummynode' */
    t->lsizenode = 0;
    setdummy(t);  /* signal that it is using dummy node */
  }
  Senão {
    Inteiro i;
    Inteiro lsize = sol_o_ceillog2(size);
    Se (lsize > MAXHBITS || (1 << lsize) > MAXHSIZE)
      sol_g_runerror(L, "table overflow");
    size = twoto(lsize);
    Se (lsize < LIMFORLAST)  /* no 'lastfree' field? */
      t->node = sol_m_newvector(L, size, Node);
    Senão {
      size_t bsize = size * meça(Node) + meça(Limbox);
      Caractere *node = sol_m_newblock(L, bsize);
      t->node = cast(Node *, node + meça(Limbox));
      getlastfree(t) = gnode(t, size);  /* all positions are free */
    }
    t->lsizenode = cast_byte(lsize);
    setnodummy(t);
    Para (i = 0; i < cast_int(size); i++) {
      Node *n = gnode(t, i);
      gnext(n) = 0;
      setnilkey(n);
      setempty(gval(n));
    }
  }
}


/*
** (Re)insert all elements from the hash part of 'ot' into table 't'.
*/
Fixo Vazio reinserthash (sol_State *L, Table *ot, Table *t) {
  Natural j;
  Natural size = sizenode(ot);
  Para (j = 0; j < size; j++) {
    Node *old = gnode(ot, j);
    Se (!isempty(gval(old))) {
      /* doesn't need barrier/invalidate cache, as entry was
         already present in the table */
      TValue k;
      getnodekey(L, &k, old);
      newcheckedkey(t, &k, gval(old));
    }
  }
}


/*
** Exchange the hash part of 't1' and 't2'. (In 'flags', only the
** dummy bit must be exchanged: The 'isrealasize' is not related
** to the hash part, and the metamethod bits Faça not change during
** a resize, so the "real" table can keep their values.)
*/
Fixo Vazio exchangehashpart (Table *t1, Table *t2) {
  lu_byte lsizenode = t1->lsizenode;
  Node *node = t1->node;
  Inteiro bitdummy1 = t1->flags & BITDUMMY;
  t1->lsizenode = t2->lsizenode;
  t1->node = t2->node;
  t1->flags = cast_byte((t1->flags & NOTBITDUMMY) | (t2->flags & BITDUMMY));
  t2->lsizenode = lsizenode;
  t2->node = node;
  t2->flags = cast_byte((t2->flags & NOTBITDUMMY) | bitdummy1);
}


/*
** Re-insert into the new hash part of a table the elements from the
** vanishing slice of the array part.
*/
Fixo Vazio reinsertOldSlice (Table *t, Natural oldasize,
                                        Natural newasize) {
  Natural i;
  Para (i = newasize; i < oldasize; i++) {  /* traverse vanishing slice */
    lu_byte tag = *getArrTag(t, i);
    Se (!tagisempty(tag)) {  /* a non-empty entry? */
      TValue key, aux;
      setivalue(&key, l_castU2S(i) + 1);  /* make the key */
      farr2val(t, i, tag, &aux);  /* copy value into 'aux' */
      insertkey(t, &key, &aux);  /* insert entry into the hash part */
    }
  }
}


/*
** Clear new slice of the array.
*/
Fixo Vazio clearNewSlice (Table *t, Natural oldasize, Natural newasize) {
  Para (; oldasize < newasize; oldasize++)
    *getArrTag(t, oldasize) = SOL_VEMPTY;
}


/*
** Resize table 't' Para the new given sizes. Both allocations (Para
** the hash part and Para the array part) can fail, which creates some
** subtleties. If the first allocation, Para the hash part, fails, an
** Erro is raised and that is it. Otherwise, it copies the elements from
** the shrinking part of the array (Se it is shrinking) into the new
** hash. Then it reallocates the array part.  If that fails, the table
** is in its original state; the function frees the new hash part and then
** raises the allocation Erro. Otherwise, it sets the new hash part
** into the table, initializes the new part of the array (Se any) with
** nils and reinserts the elements of the old hash back into the new
** parts of the table.
** Note that Se the new size Para the array part ('newasize') is equal to
** the old one ('oldasize'), this function will Faça nothing with that
** part.
*/
Vazio sol_h_resize (sol_State *L, Table *t, Natural newasize,
                                          Natural nhsize) {
  Table newt;  /* to keep the new hash part */
  Natural oldasize = t->asize;
  Value *newarray;
  Se (newasize > MAXASIZE)
    sol_g_runerror(L, "table overflow");
  /* create new hash part with appropriate size into 'newt' */
  newt.flags = 0;
  setnodevector(L, &newt, nhsize);
  Se (newasize < oldasize) {  /* will array shrink? */
    /* re-insert into the new hash the elements from vanishing slice */
    exchangehashpart(t, &newt);  /* pretend table has new hash */
    reinsertOldSlice(t, oldasize, newasize);
    exchangehashpart(t, &newt);  /* restore old hash (in Caso of errors) */
  }
  /* allocate new array */
  newarray = resizearray(L, t, oldasize, newasize);
  Se (l_unlikely(newarray == NULL && newasize > 0)) {  /* allocation failed? */
    freehash(L, &newt);  /* release new hash part */
    sol_m_error(L);  /* raise Erro (with array unchanged) */
  }
  /* allocation ok; initialize new part of the array */
  exchangehashpart(t, &newt);  /* 't' has the new hash ('newt' has the old) */
  t->array = newarray;  /* set new array part */
  t->asize = newasize;
  Se (newarray != NULL)
    *lenhint(t) = newasize / 2u;  /* set an initial hint */
  clearNewSlice(t, oldasize, newasize);
  /* re-insert elements from old hash part into new parts */
  reinserthash(L, &newt, t);  /* 'newt' now has the old hash */
  freehash(L, &newt);  /* free old hash part */
}


Vazio sol_h_resizearray (sol_State *L, Table *t, Natural Inteiro nasize) {
  Natural nsize = allocsizenode(t);
  sol_h_resize(L, t, nasize, nsize);
}


/*
** Rehash a table. First, count its keys. If there are array indices
** outside the array part, compute the new best size Para that part.
** Then, resize the table.
*/
Fixo Vazio rehash (sol_State *L, Table *t, Imutável TValue *ek) {
  Natural asize;  /* optimal size Para array part */
  Counters ct;
  Natural i;
  Natural nsize;  /* size Para the hash part */
  /* reset counts */
  Para (i = 0; i <= MAXABITS; i++) ct.nums[i] = 0;
  ct.na = 0;
  ct.deleted = 0;
  ct.total = 1;  /* count extra key */
  Se (ttisinteger(ek))
    countint(ivalue(ek), &ct);  /* extra key may go to array */
  numusehash(t, &ct);  /* count keys in hash part */
  Se (ct.na == 0) {
    /* no new keys to enter array part; keep it with the same size */
    asize = t->asize;
  }
  Senão {  /* compute best size Para array part */
    numusearray(t, &ct);  /* count keys in array part */
    asize = computesizes(&ct);  /* compute new size Para array part */
  }
  /* all keys not in the array part go to the hash part */
  nsize = ct.total - ct.na;
  Se (ct.deleted) {  /* table has deleted entries? */
    /* insertion-deletion-insertion: give hash some extra size to
       avoid repeated resizings */
    nsize += nsize >> 2;
  }
  /* resize the table to new computed sizes */
  sol_h_resize(L, t, asize, nsize);
}

/*
** }=============================================================
*/


Table *sol_h_new (sol_State *L) {
  GCObject *o = sol_c_newobj(L, SOL_VTABLE, meça(Table));
  Table *t = gco2t(o);
  t->metatable = NULL;
  t->flags = maskflags;  /* table has no metamethod fields */
  t->array = NULL;
  t->asize = 0;
  setnodevector(L, t, 0);
  Retorne t;
}


lu_mem sol_h_size (Table *t) {
  lu_mem sz = cast(lu_mem, meça(Table)) + concretesize(t->asize);
  Se (!isdummy(t))
    sz += sizehash(t);
  Retorne sz;
}


/*
** Frees a table.
*/
Vazio sol_h_free (sol_State *L, Table *t) {
  freehash(L, t);
  resizearray(L, t, t->asize, 0);
  sol_m_free(L, t);
}


Fixo Node *getfreepos (Table *t) {
  Se (haslastfree(t)) {  /* does it have 'lastfree' information? */
    /* look Para a spot before 'lastfree', updating 'lastfree' */
    Enquanto (getlastfree(t) > t->node) {
      Node *free = --getlastfree(t);
      Se (keyisnil(free))
        Retorne free;
    }
  }
  Senão {  /* no 'lastfree' information */
    Natural i = sizenode(t);
    Enquanto (i--) {  /* Faça a linear search */
      Node *free = gnode(t, i);
      Se (keyisnil(free))
        Retorne free;
    }
  }
  Retorne NULL;  /* could not find a free place */
}



/*
** Inserts a new key into a hash table; first, check whether key's main
** position is free. If not, check whether colliding node is in its main
** position or not: Se it is not, move colliding node to an empty place
** and put new key in its main position; otherwise (colliding node is in
** its main position), new key goes to an empty position. Return 0 Se
** could not insert key (could not find a free space).
*/
Fixo Inteiro insertkey (Table *t, Imutável TValue *key, TValue *value) {
  Node *mp = mainpositionTV(t, key);
  /* table cannot already contain the key */
  sol_assert(isabstkey(getgeneric(t, key, 0)));
  Se (!isempty(gval(mp)) || isdummy(t)) {  /* main position is taken? */
    Node *othern;
    Node *f = getfreepos(t);  /* get a free place */
    Se (f == NULL)  /* cannot find a free place? */
      Retorne 0;
    sol_assert(!isdummy(t));
    othern = mainpositionfromnode(t, mp);
    Se (othern != mp) {  /* is colliding node out of its main position? */
      /* yes; move colliding node into free position */
      Enquanto (othern + gnext(othern) != mp)  /* find previous */
        othern += gnext(othern);
      gnext(othern) = cast_int(f - othern);  /* rechain to point to 'f' */
      *f = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
      Se (gnext(mp) != 0) {
        gnext(f) += cast_int(mp - f);  /* correct 'next' */
        gnext(mp) = 0;  /* now 'mp' is free */
      }
      setempty(gval(mp));
    }
    Senão {  /* colliding node is in its own main position */
      /* new node will go into free position */
      Se (gnext(mp) != 0)
        gnext(f) = cast_int((mp + gnext(mp)) - f);  /* chain new position */
      Senão sol_assert(gnext(f) == 0);
      gnext(mp) = cast_int(f - mp);
      mp = f;
    }
  }
  setnodekey(mp, key);
  sol_assert(isempty(gval(mp)));
  setobj2t(cast(sol_State *, 0), gval(mp), value);
  Retorne 1;
}


/*
** Insert a key in a table where there is space Para that key, the
** key is valid, and the value is not nil.
*/
Fixo Vazio newcheckedkey (Table *t, Imutável TValue *key, TValue *value) {
  Natural i = keyinarray(t, key);
  Se (i > 0)  /* is key in the array part? */
    obj2arr(t, i - 1, value);  /* set value in the array */
  Senão {
    Inteiro done = insertkey(t, key, value);  /* insert key in the hash part */
    sol_assert(done);  /* it cannot fail */
    cast(Vazio, done);  /* to avoid warnings */
  }
}


Fixo Vazio sol_h_newkey (sol_State *L, Table *t, Imutável TValue *key,
                                                 TValue *value) {
  Se (!ttisnil(value)) {  /* Faça not insert nil values */
    Inteiro done = insertkey(t, key, value);
    Se (!done) {  /* could not find a free place? */
      rehash(L, t, key);  /* grow table */
      newcheckedkey(t, key, value);  /* insert key in grown table */
    }
    sol_c_barrierback(L, obj2gco(t), key);
    /* Para debugging only: any new key may force an emergency collection */
    condchangemem(L, (Vazio)0, (Vazio)0, 1);
  }
}


Fixo Imutável TValue *getintfromhash (Table *t, sol_Integer key) {
  Node *n = hashint(t, key);
  sol_assert(!ikeyinarray(t, key));
  Para (;;) {  /* check whether 'key' is somewhere in the chain */
    Se (keyisinteger(n) && keyival(n) == key)
      Retorne gval(n);  /* that's it */
    Senão {
      Inteiro nx = gnext(n);
      Se (nx == 0) Interrompa;
      n += nx;
    }
  }
  Retorne &absentkey;
}


Fixo Inteiro hashkeyisempty (Table *t, sol_Unsigned key) {
  Imutável TValue *val = getintfromhash(t, l_castU2S(key));
  Retorne isempty(val);
}


Fixo lu_byte finishnodeget (Imutável TValue *val, TValue *res) {
  Se (!ttisnil(val)) {
    setobj(((sol_State*)NULL), res, val);
  }
  Retorne ttypetag(val);
}


lu_byte sol_h_getint (Table *t, sol_Integer key, TValue *res) {
  Natural k = ikeyinarray(t, key);
  Se (k > 0) {
    lu_byte tag = *getArrTag(t, k - 1);
    Se (!tagisempty(tag))
      farr2val(t, k - 1, tag, res);
    Retorne tag;
  }
  Senão
    Retorne finishnodeget(getintfromhash(t, key), res);
}


/*
** search function Para Curto strings
*/
Imutável TValue *sol_h_Hgetshortstr (Table *t, TString *key) {
  Node *n = hashstr(t, key);
  sol_assert(strisshr(key));
  Para (;;) {  /* check whether 'key' is somewhere in the chain */
    Se (keyisshrstr(n) && eqshrstr(keystrval(n), key))
      Retorne gval(n);  /* that's it */
    Senão {
      Inteiro nx = gnext(n);
      Se (nx == 0)
        Retorne &absentkey;  /* not found */
      n += nx;
    }
  }
}


lu_byte sol_h_getshortstr (Table *t, TString *key, TValue *res) {
  Retorne finishnodeget(sol_h_Hgetshortstr(t, key), res);
}


Fixo Imutável TValue *Hgetlongstr (Table *t, TString *key) {
  TValue ko;
  sol_assert(!strisshr(key));
  setsvalue(cast(sol_State *, NULL), &ko, key);
  Retorne getgeneric(t, &ko, 0);  /* Para Longo strings, use generic Caso */
}


Fixo Imutável TValue *Hgetstr (Table *t, TString *key) {
  Se (strisshr(key))
    Retorne sol_h_Hgetshortstr(t, key);
  Senão
    Retorne Hgetlongstr(t, key);
}


lu_byte sol_h_getstr (Table *t, TString *key, TValue *res) {
  Retorne finishnodeget(Hgetstr(t, key), res);
}


/*
** main search function
*/
lu_byte sol_h_get (Table *t, Imutável TValue *key, TValue *res) {
  Imutável TValue *slot;
  Troque (ttypetag(key)) {
    Caso SOL_VSHRSTR:
      slot = sol_h_Hgetshortstr(t, tsvalue(key));
      Interrompa;
    Caso SOL_VNUMINT:
      Retorne sol_h_getint(t, ivalue(key), res);
    Caso SOL_VNIL:
      slot = &absentkey;
      Interrompa;
    Caso SOL_VNUMFLT: {
      sol_Integer k;
      Se (sol_v_flttointeger(fltvalue(key), &k, F2Ieq)) /* integral index? */
        Retorne sol_h_getint(t, k, res);  /* use specialized version */
      /* Senão... */
    }  /* FALLTHROUGH */
    Padrão:
      slot = getgeneric(t, key, 0);
      Interrompa;
  }
  Retorne finishnodeget(slot, res);
}


/*
** When a 'pset' cannot be completed, this function returns an encoding
** of its result, to be used by 'sol_h_finishset'.
*/
Fixo Inteiro retpsetcode (Table *t, Imutável TValue *slot) {
  Se (isabstkey(slot))
    Retorne HNOTFOUND;  /* no slot with that key */
  Senão  /* Retorne node encoded */
    Retorne cast_int((cast(Node*, slot) - t->node)) + HFIRSTNODE;
}


Fixo Inteiro finishnodeset (Table *t, Imutável TValue *slot, TValue *val) {
  Se (!ttisnil(slot)) {
    setobj(((sol_State*)NULL), cast(TValue*, slot), val);
    Retorne HOK;  /* success */
  }
  Senão
    Retorne retpsetcode(t, slot);
}


Fixo Inteiro rawfinishnodeset (Imutável TValue *slot, TValue *val) {
  Se (isabstkey(slot))
    Retorne 0;  /* no slot with that key */
  Senão {
    setobj(((sol_State*)NULL), cast(TValue*, slot), val);
    Retorne 1;  /* success */
  }
}


Inteiro sol_h_psetint (Table *t, sol_Integer key, TValue *val) {
  sol_assert(!ikeyinarray(t, key));
  Retorne finishnodeset(t, getintfromhash(t, key), val);
}


Fixo Inteiro psetint (Table *t, sol_Integer key, TValue *val) {
  Inteiro hres;
  sol_h_fastseti(t, key, val, hres);
  Retorne hres;
}


/*
** This function could be just this:
**    Retorne finishnodeset(t, sol_h_Hgetshortstr(t, key), val);
** However, it optimizes the common Caso created by constructors (e.g.,
** {x=1, y=2}), which creates a key in a table that has no metatable,
** it is not old/black, and it already has space Para the key.
*/

Inteiro sol_h_psetshortstr (Table *t, TString *key, TValue *val) {
  Imutável TValue *slot = sol_h_Hgetshortstr(t, key);
  Se (!ttisnil(slot)) {  /* key already has a value? (all too common) */
    setobj(((sol_State*)NULL), cast(TValue*, slot), val);  /* update it */
    Retorne HOK;  /* done */
  }
  Senão Se (checknoTM(t->metatable, TM_NEWINDEX)) {  /* no metamethod? */
    Se (ttisnil(val))  /* new value is nil? */
      Retorne HOK;  /* done (value is already nil/absent) */
    Se (isabstkey(slot) &&  /* key is absent? */
       !(isblack(t) && iswhite(key))) {  /* and don't need barrier? */
      TValue tk;  /* key as a TValue */
      setsvalue(cast(sol_State *, NULL), &tk, key);
      Se (insertkey(t, &tk, val)) {  /* insert key, Se there is space */
        invalidateTMcache(t);
        Retorne HOK;
      }
    }
  }
  /* Else, either table has new-index metamethod, or it needs barrier,
     or it needs to rehash Para the new key. In any of these cases, the
     operation cannot be completed here. Return a code Para the caller. */
  Retorne retpsetcode(t, slot);
}


Inteiro sol_h_psetstr (Table *t, TString *key, TValue *val) {
  Se (strisshr(key))
    Retorne sol_h_psetshortstr(t, key, val);
  Senão
    Retorne finishnodeset(t, Hgetlongstr(t, key), val);
}


Inteiro sol_h_pset (Table *t, Imutável TValue *key, TValue *val) {
  Troque (ttypetag(key)) {
    Caso SOL_VSHRSTR: Retorne sol_h_psetshortstr(t, tsvalue(key), val);
    Caso SOL_VNUMINT: Retorne psetint(t, ivalue(key), val);
    Caso SOL_VNIL: Retorne HNOTFOUND;
    Caso SOL_VNUMFLT: {
      sol_Integer k;
      Se (sol_v_flttointeger(fltvalue(key), &k, F2Ieq)) /* integral index? */
        Retorne psetint(t, k, val);  /* use specialized version */
      /* Senão... */
    }  /* FALLTHROUGH */
    Padrão:
      Retorne finishnodeset(t, getgeneric(t, key, 0), val);
  }
}

/*
** Finish a raw "set table" operation, where 'hres' encodes where the
** value should have been (the result of a previous 'pset' operation).
** Beware: when using this function the caller probably need to check a
** GC barrier and invalidate the TM cache.
*/
Vazio sol_h_finishset (sol_State *L, Table *t, Imutável TValue *key,
                                    TValue *value, Inteiro hres) {
  sol_assert(hres != HOK);
  Se (hres == HNOTFOUND) {
    TValue aux;
    Se (l_unlikely(ttisnil(key)))
      sol_g_runerror(L, "table index is nil");
    Senão Se (ttisfloat(key)) {
      sol_Number f = fltvalue(key);
      sol_Integer k;
      Se (sol_v_flttointeger(f, &k, F2Ieq)) {
        setivalue(&aux, k);  /* key is equal to an integer */
        key = &aux;  /* insert it as an integer */
      }
      Senão Se (l_unlikely(sol_numisnan(f)))
        sol_g_runerror(L, "table index is NaN");
    }
    Senão Se (isextstr(key)) {  /* external string? */
      /* If string is Curto, must internalize it to be used as table key */
      TString *ts = sol_s_normstr(L, tsvalue(key));
      setsvalue2s(L, L->top.p++, ts);  /* anchor 'ts' (EXTRA_STACK) */
      sol_h_newkey(L, t, s2v(L->top.p - 1), value);
      L->top.p--;
      Retorne;
    }
    sol_h_newkey(L, t, key, value);
  }
  Senão Se (hres > 0) {  /* regular Node? */
    setobj2t(L, gval(gnode(t, hres - HFIRSTNODE)), value);
  }
  Senão {  /* array entry */
    hres = ~hres;  /* real index */
    obj2arr(t, cast_uint(hres), value);
  }
}


/*
** beware: when using this function you probably need to check a GC
** barrier and invalidate the TM cache.
*/
Vazio sol_h_set (sol_State *L, Table *t, Imutável TValue *key, TValue *value) {
  Inteiro hres = sol_h_pset(t, key, value);
  Se (hres != HOK)
    sol_h_finishset(L, t, key, value, hres);
}


/*
** Ditto Para a GC barrier. (No need to invalidate the TM cache, as
** integers cannot be keys to metamethods.)
*/
Vazio sol_h_setint (sol_State *L, Table *t, sol_Integer key, TValue *value) {
  Natural ik = ikeyinarray(t, key);
  Se (ik > 0)
    obj2arr(t, ik - 1, value);
  Senão {
    Inteiro ok = rawfinishnodeset(getintfromhash(t, key), value);
    Se (!ok) {
      TValue k;
      setivalue(&k, key);
      sol_h_newkey(L, t, &k, value);
    }
  }
}


/*
** Try to find a boundary in the hash part of table 't'. From the
** caller, we know that 'asize + 1' is present. We want to find a larger
** key that is absent from the table, so that we can Faça a binary search
** between the two keys to find a boundary. We keep doubling 'j' until
** we get an absent index.  If the doubling would overflow, we try
** SOL_MAXINTEGER. If it is absent, we are ready Para the binary search.
** ('j', being max integer, is larger or equal to 'i', but it cannot be
** equal because it is absent Enquanto 'i' is present.) Otherwise, 'j' is a
** boundary. ('j + 1' cannot be a present integer key because it is not
** a valid integer in Sol.)
** About 'rnd': If we used a fixed algorithm, a bad actor could fill
** a table with only the keys that would be probed, in such a way that
** a small table could result in a huge length. To avoid that, we use
** the state's seed as a source of randomness. For the first probe,
** we "randomly Duplo" 'i' by adding to it a random number roughly its
** width.
*/
Fixo sol_Unsigned hash_search (sol_State *L, Table *t, Natural asize) {
  sol_Unsigned i = asize + 1;  /* caller ensures t[i] is present */
  Natural rnd = G(L)->seed;
  Inteiro n = (asize > 0) ? sol_o_ceillog2(asize) : 0;  /* width of 'asize' */
  Natural mask = (1u << n) - 1;  /* 11...111 with the width of 'asize' */
  Natural incr = (rnd & mask) + 1;  /* first increment (at least 1) */
  sol_Unsigned j = (incr <= l_castS2U(SOL_MAXINTEGER) - i) ? i + incr : i + 1;
  rnd >>= n;  /* used 'n' bits from 'rnd' */
  Enquanto (!hashkeyisempty(t, j)) {  /* repeat until an absent t[j] */
    i = j;  /* 'i' is a present index */
    Se (j <= l_castS2U(SOL_MAXINTEGER)/2 - 1) {
      j = j*2 + (rnd & 1);  /* try again with 2j or 2j+1 */
      rnd >>= 1;
    }
    Senão {
      j = SOL_MAXINTEGER;
      Se (hashkeyisempty(t, j))  /* t[j] not present? */
        Interrompa;  /* 'j' now is an absent index */
      Senão  /* weird Caso */
        Retorne j;  /* well, max integer is a boundary... */
    }
  }
  /* i < j  &&  t[i] present  &&  t[j] absent */
  Enquanto (j - i > 1u) {  /* Faça a binary search between them */
    sol_Unsigned m = (i + j) / 2;
    Se (hashkeyisempty(t, m)) j = m;
    Senão i = m;
  }
  Retorne i;
}


Fixo Natural Inteiro binsearch (Table *array, Natural Inteiro i, Natural Inteiro j) {
  sol_assert(i <= j);
  Enquanto (j - i > 1u) {  /* binary search */
    Natural Inteiro m = (i + j) / 2;
    Se (arraykeyisempty(array, m)) j = m;
    Senão i = m;
  }
  Retorne i;
}


/* Retorne a border, saving it as a hint Para next call */
Fixo sol_Unsigned newhint (Table *t, Natural hint) {
  sol_assert(hint <= t->asize);
  *lenhint(t) = hint;
  Retorne hint;
}


/*
** Try to find a border in table 't'. (A 'border' is an integer index
** such that t[i] is present and t[i+1] is absent, or 0 Se t[1] is absent,
** or 'maxinteger' Se t[maxinteger] is present.)
** If there is an array part, try to find a border there. First try
** to find it in the vicinity of the previous result (hint), to handle
** cases like 't[#t + 1] = val' or 't[#t] = nil', that move the border
** by one entry. Otherwise, Faça a binary search to find the border.
** If there is no array part, or its last element is non empty, the
** border may be in the hash part.
*/
sol_Unsigned sol_h_getn (sol_State *L, Table *t) {
  Natural asize = t->asize;
  Se (asize > 0) {  /* is there an array part? */
    Imutável Natural maxvicinity = 4;
    Natural limit = *lenhint(t);  /* start with the hint */
    Se (limit == 0)
      limit = 1;  /* make limit a valid index in the array */
    Se (arraykeyisempty(t, limit)) {  /* t[limit] empty? */
      /* there must be a border before 'limit' */
      Natural i;
      /* look Para a border in the vicinity of the hint */
      Para (i = 0; i < maxvicinity && limit > 1; i++) {
        limit--;
        Se (!arraykeyisempty(t, limit))
          Retorne newhint(t, limit);  /* 'limit' is a border */
      }
      /* t[limit] still empty; search Para a border in [0, limit) */
      Retorne newhint(t, binsearch(t, 0, limit));
    }
    Senão {  /* 'limit' is present in table; look Para a border after it */
      Natural i;
      /* look Para a border in the vicinity of the hint */
      Para (i = 0; i < maxvicinity && limit < asize; i++) {
        limit++;
        Se (arraykeyisempty(t, limit))
          Retorne newhint(t, limit - 1);  /* 'limit - 1' is a border */
      }
      Se (arraykeyisempty(t, asize)) {  /* last element empty? */
        /* t[limit] not empty; search Para a border in [limit, asize) */
        Retorne newhint(t, binsearch(t, limit, asize));
      }
    }
    /* last element non empty; set a hint to speed up finding that again */
    /* (keys in the hash part cannot be hints) */
    *lenhint(t) = asize;
  }
  /* no array part or t[asize] is not empty; check the hash part */
  sol_assert(asize == 0 || !arraykeyisempty(t, asize));
  Se (isdummy(t) || hashkeyisempty(t, asize + 1))
    Retorne asize;  /* 'asize + 1' is empty */
  Senão  /* 'asize + 1' is also non empty */
    Retorne hash_search(L, t, asize);
}



#Se Definido(SOL_DEBUG)

/* export this function Para the test library */

Node *sol_h_mainposition (Imutável Table *t, Imutável TValue *key) {
  Retorne mainpositionTV(t, key);
}

#FimSe
