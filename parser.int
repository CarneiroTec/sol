/*
** $Id: parser.h $
** Sol Parser
** See Direitos Autorais Notice in sol.h
*/

#SeNãoDefinido parser_h
#Defina parser_h

#Inclua "limits.int"
#Inclua "object.int"
#Inclua "zio.int"


/*
** Expression and variable descriptor.
** Code generation Para variables and expressions can be delayed to allow
** optimizations; An 'expdesc' structure describes a potentially-delayed
** variable/expression. It has a description of its "main" value plus a
** list of conditional jumps that can also produce its value (generated
** by Curto-circuit operators 'and'/'or').
*/

/* kinds of variables/expressions */
Pseudônimo Enumeração {
  VVOID,  /* when 'expdesc' describes the last expression of a list,
             this kind means an empty list (so, no expression) */
  VNIL,  /* constant nil */
  VTRUE,  /* constant true */
  VFALSE,  /* constant false */
  VK,  /* constant in 'k'; info = index of constant in 'k' */
  VKFLT,  /* floating constant; nval = numerical Real value */
  VKINT,  /* integer constant; ival = numerical integer value */
  VKSTR,  /* string constant; strval = TString address;
             (string is fixed by the scanner) */
  VNONRELOC,  /* expression has its value in a fixed Registrador;
                 info = result Registrador */
  VLOCAL,  /* local variable; var.ridx = Registrador index;
              var.vidx = relative index in 'actvar.arr'  */
  VGLOBAL,  /* global variable;
               info = relative index in 'actvar.arr' (or -1 Para
                      implicit declaration) */
  VUPVAL,  /* upvalue variable; info = index of upvalue in 'upvalues' */
  VCONST,  /* compile-time <Imutável> variable;
              info = absolute index in 'actvar.arr'  */
  VINDEXED,  /* indexed variable;
                ind.t = table Registrador;
                ind.idx = key's R index;
                ind.ro = true Se it represents a read-only global;
                ind.keystr = Se key is a string, index in 'k' of that string;
                             -1 Se key is not a string */
  VINDEXUP,  /* indexed upvalue;
                ind.idx = key's K index;
                ind.* as in VINDEXED */
  VINDEXI, /* indexed variable with constant integer;
                ind.t = table Registrador;
                ind.idx = key's value */
  VINDEXSTR, /* indexed variable with literal string;
                ind.idx = key's K index;
                ind.* as in VINDEXED */
  VJMP,  /* expression is a test/comparison;
            info = pc of corresponding jump instruction */
  VRELOC,  /* expression can put result in any Registrador;
              info = instruction pc */
  VCALL,  /* expression is a function call; info = instruction pc */
  VVARARG  /* vararg expression; info = instruction pc */
} expkind;


#Defina vkisvar(k)	(VLOCAL <= (k) && (k) <= VINDEXSTR)
#Defina vkisindexed(k)	(VINDEXED <= (k) && (k) <= VINDEXSTR)


Pseudônimo Estrutura expdesc {
  expkind k;
  União {
    sol_Integer ival;    /* Para VKINT */
    sol_Number nval;  /* Para VKFLT */
    TString *strval;  /* Para VKSTR */
    Inteiro info;  /* Para generic use */
    Estrutura {  /* Para indexed variables */
      Curto idx;  /* index (R or "Longo" K) */
      lu_byte t;  /* table (Registrador or upvalue) */
      lu_byte ro;  /* true Se variable is read-only */
      Inteiro keystr;  /* index in 'k' of string key, or -1 Se not a string */
    } ind;
    Estrutura {  /* Para local variables */
      lu_byte ridx;  /* Registrador holding the variable */
      Curto vidx;  /* index in 'actvar.arr' */
    } var;
  } u;
  Inteiro t;  /* patch list of 'exit when true' */
  Inteiro f;  /* patch list of 'exit when false' */
} expdesc;


/* kinds of variables */
#Defina VDKREG		0   /* regular local */
#Defina RDKCONST	1   /* local constant */
#Defina RDKTOCLOSE	2   /* to-be-closed */
#Defina RDKCTC		3   /* local compile-time constant */
#Defina GDKREG		4   /* regular global */
#Defina GDKCONST	5   /* global constant */

/* variables that live in registers */
#Defina varinreg(v)	((v)->vd.kind <= RDKTOCLOSE)

/* test Para global variables */
#Defina varglobal(v)	((v)->vd.kind >= GDKREG)


/* description of an active variable */
Pseudônimo União Vardesc {
  Estrutura {
    TValuefields;  /* constant value (Se it is a compile-time constant) */
    lu_byte kind;
    lu_byte ridx;  /* Registrador holding the variable */
    Curto pidx;  /* index of the variable in the Proto's 'locvars' array */
    TString *name;  /* variable name */
  } vd;
  TValue k;  /* constant value (Se any) */
} Vardesc;



/* description of pending Execute statements and label statements */
Pseudônimo Estrutura Labeldesc {
  TString *name;  /* label identifier */
  Inteiro pc;  /* position in code */
  Inteiro Linha;  /* Linha where it appeared */
  Curto nactvar;  /* number of active variables in that position */
  lu_byte close;  /* true Para Execute that escapes upvalues */
} Labeldesc;


/* list of labels or gotos */
Pseudônimo Estrutura Labellist {
  Labeldesc *arr;  /* array */
  Inteiro n;  /* number of entries in use */
  Inteiro size;  /* array size */
} Labellist;


/* dynamic structures used by the parser */
Pseudônimo Estrutura Dyndata {
  Estrutura {  /* list of all active local variables */
    Vardesc *arr;
    Inteiro n;
    Inteiro size;
  } actvar;
  Labellist gt;  /* list of pending gotos */
  Labellist label;   /* list of active labels */
} Dyndata;


/* control of blocks */
Estrutura BlockCnt;  /* Definido in lparser.c */


/* state needed to generate code Para a given function */
Pseudônimo Estrutura FuncState {
  Proto *f;  /* current function header */
  Estrutura FuncState *prev;  /* enclosing function */
  Estrutura LexState *ls;  /* lexical state */
  Estrutura BlockCnt *bl;  /* chain of current blocks */
  Table *kcache;  /* cache Para reusing constants */
  Inteiro pc;  /* next position to code (equivalent to 'ncode') */
  Inteiro lasttarget;   /* 'label' of last 'jump label' */
  Inteiro previousline;  /* last Linha that was saved in 'lineinfo' */
  Inteiro nk;  /* number of elements in 'k' */
  Inteiro np;  /* number of elements in 'p' */
  Inteiro nabslineinfo;  /* number of elements in 'abslineinfo' */
  Inteiro firstlocal;  /* index of first local var (in Dyndata array) */
  Inteiro firstlabel;  /* index of first label (in 'dyd->label->arr') */
  Curto ndebugvars;  /* number of elements in 'f->locvars' */
  Curto nactvar;  /* number of active variable declarations */
  lu_byte nups;  /* number of upvalues */
  lu_byte freereg;  /* first free Registrador */
  lu_byte iwthabs;  /* instructions issued since last absolute Linha info */
  lu_byte needclose;  /* function needs to close upvalues when returning */
  lu_byte if_depth;   /* current nesting depth of 'se' statements */
  lu_byte for_depth;  /* current nesting depth of 'para' loops */
} FuncState;


SOL_FUNC lu_byte sol_y_nvarstack (FuncState *fs);
SOL_FUNC Vazio sol_y_checklimit (FuncState *fs, Inteiro v, Inteiro l,
                                Imutável Caractere *what);
SOL_FUNC LClosure *sol_y_parser (sol_State *L, ZIO *z, Mbuffer *buff,
                                 Dyndata *dyd, Imutável Caractere *name, Inteiro firstchar);


#FimSe
