/*
** $Id: ltm.c $
** Tag methods
** See Copyright Notice in sol.h
*/

#Defina tm_c
#Defina SOL_CORE

#Inclua "prefix.int"


#Inclua <string.h>

#Inclua "sol.int"

#Inclua "debug.int"
#Inclua "do.int"
#Inclua "gc.int"
#Inclua "object.int"
#Inclua "state.int"
#Inclua "string.int"
#Inclua "table.int"
#Inclua "tm.int"
#Inclua "vm.int"


Fixo Imutável Caractere udatatypename[] = "objeto externo";

SOL_DDEF Imutável Caractere *Imutável sol_t_typenames_[SOL_TOTALTYPES] = {
  "no value",
  "nulo", "lógico", udatatypename, "número",
  "texto", "tabela", "função", udatatypename, "corrotina",
  "canal", "tarefa", "processo",
  "upvalue", "proto" /* these last cases are used Para tests only */
};


Vazio sol_t_init (sol_State *L) {
  Fixo Imutável Caractere *Imutável sol_t_eventname[] = {  /* ORDER TM */
    "__índice", "__novo_índice",
    "__coletor_lixo", "__modo", "__comprimento", "__igual",
    "__soma", "__subtração", "__multiplicação", "__módulo", "__potência",
    "__divisão", "__divisão_inteira",
    "__e_binário", "__ou_binário", "__ou_exclusivo", "__desloque_esquerda", "__desloque_direita",
    "__negação", "__não_binário", "__menor_que", "__menor_ou_igual",
    "__concatene", "__chame", "__feche"
  };
  Inteiro i;
  Para (i=0; i<TM_N; i++) {
    G(L)->tmname[i] = sol_s_new(L, sol_t_eventname[i]);
    sol_c_fix(L, obj2gco(G(L)->tmname[i]));  /* never collect these names */
  }
}


/*
** function to be used with macro "fasttm": optimized Para absence of
** tag methods
*/
Imutável TValue *sol_t_gettm (Table *events, TMS event, TString *ename) {
  Imutável TValue *tm = sol_h_Hgetshortstr(events, ename);
  sol_assert(event <= TM_EQ);
  Se (notm(tm)) {  /* no tag method? */
    events->flags |= cast_byte(1u<<event);  /* cache this fact */
    Retorne NULL;
  }
  Senão Retorne tm;
}


Imutável TValue *sol_t_gettmbyobj (sol_State *L, Imutável TValue *o, TMS event) {
  Table *mt;
  Troque (ttype(o)) {
    Caso SOL_TTABLE:
      mt = hvalue(o)->metatable;
      Interrompa;
    Caso SOL_TUSERDATA:
      mt = uvalue(o)->metatable;
      Interrompa;
    Padrão:
      mt = G(L)->mt[ttype(o)];
  }
  Retorne (mt ? sol_h_Hgetshortstr(mt, G(L)->tmname[event]) : &G(L)->nilvalue);
}


/*
** Return the name of the type of an object. For tables and userdata
** with metatable, use their '__name' metafield, Se present.
*/
Imutável Caractere *sol_t_objtypename (sol_State *L, Imutável TValue *o) {
  Table *mt;
  Se ((ttistable(o) && (mt = hvalue(o)->metatable) != NULL) ||
      (ttisfulluserdata(o) && (mt = uvalue(o)->metatable) != NULL)) {
    Imutável TValue *name = sol_h_Hgetshortstr(mt, sol_s_new(L, "__nome"));
    Se (ttisstring(name))  /* is '__name' a string? */
      Retorne getstr(tsvalue(name));  /* use it as type name */
  }
  Retorne ttypename(ttype(o));  /* Senão use standard type name */
}


Vazio sol_t_callTM (sol_State *L, Imutável TValue *f, Imutável TValue *p1,
                  Imutável TValue *p2, Imutável TValue *p3) {
  StkId func = L->top.p;
  setobj2s(L, func, f);  /* push function (assume EXTRA_STACK) */
  setobj2s(L, func + 1, p1);  /* 1st argument */
  setobj2s(L, func + 2, p2);  /* 2nd argument */
  setobj2s(L, func + 3, p3);  /* 3rd argument */
  L->top.p = func + 4;
  /* metamethod may yield only when called from Sol code */
  Se (isLuacode(L->ci))
    sol_d_call(L, func, 0);
  Senão
    sol_d_callnoyield(L, func, 0);
}


lu_byte sol_t_callTMres (sol_State *L, Imutável TValue *f, Imutável TValue *p1,
                        Imutável TValue *p2, StkId res) {
  ptrdiff_t result = savestack(L, res);
  StkId func = L->top.p;
  setobj2s(L, func, f);  /* push function (assume EXTRA_STACK) */
  setobj2s(L, func + 1, p1);  /* 1st argument */
  setobj2s(L, func + 2, p2);  /* 2nd argument */
  L->top.p += 3;
  /* metamethod may yield only when called from Sol code */
  Se (isLuacode(L->ci))
    sol_d_call(L, func, 1);
  Senão
    sol_d_callnoyield(L, func, 1);
  res = restorestack(L, result);
  setobjs2s(L, res, --L->top.p);  /* move result to its place */
  Retorne ttypetag(s2v(res));  /* Retorne tag of the result */
}


Fixo Inteiro callbinTM (sol_State *L, Imutável TValue *p1, Imutável TValue *p2,
                      StkId res, TMS event) {
  Imutável TValue *tm = sol_t_gettmbyobj(L, p1, event);  /* try first operand */
  Se (notm(tm))
    tm = sol_t_gettmbyobj(L, p2, event);  /* try second operand */
  Se (notm(tm))
    Retorne -1;  /* tag method not found */
  Senão  /* call tag method and Retorne the tag of the result */
    Retorne sol_t_callTMres(L, tm, p1, p2, res);
}


Vazio sol_t_trybinTM (sol_State *L, Imutável TValue *p1, Imutável TValue *p2,
                    StkId res, TMS event) {
  Se (l_unlikely(callbinTM(L, p1, p2, res, event) < 0)) {
    Troque (event) {
      Caso TM_BAND: Caso TM_BOR: Caso TM_BXOR:
      Caso TM_SHL: Caso TM_SHR: Caso TM_BNOT: {
        Se (ttisnumber(p1) && ttisnumber(p2))
          sol_g_tointerror(L, p1, p2);
        Senão
          sol_g_opinterror(L, p1, p2, "perform bitwise operation on");
      }
      /* calls never Retorne, but to avoid warnings: *//* FALLTHROUGH */
      Padrão:
        sol_g_opinterror(L, p1, p2, "perform arithmetic on");
    }
  }
}


/*
** The use of 'p1' after 'callbinTM' is safe because, when a tag
** method is not found, 'callbinTM' cannot change the stack.
*/
Vazio sol_t_tryconcatTM (sol_State *L) {
  StkId p1 = L->top.p - 2;  /* first argument */
  Se (l_unlikely(callbinTM(L, s2v(p1), s2v(p1 + 1), p1, TM_CONCAT) < 0))
    sol_g_concaterror(L, s2v(p1), s2v(p1 + 1));
}


Vazio sol_t_trybinassocTM (sol_State *L, Imutável TValue *p1, Imutável TValue *p2,
                                       Inteiro flip, StkId res, TMS event) {
  Se (flip)
    sol_t_trybinTM(L, p2, p1, res, event);
  Senão
    sol_t_trybinTM(L, p1, p2, res, event);
}


Vazio sol_t_trybiniTM (sol_State *L, Imutável TValue *p1, sol_Integer i2,
                                   Inteiro flip, StkId res, TMS event) {
  TValue aux;
  setivalue(&aux, i2);
  sol_t_trybinassocTM(L, p1, &aux, flip, res, event);
}


/*
** Calls an order tag method.
*/
Inteiro sol_t_callorderTM (sol_State *L, Imutável TValue *p1, Imutável TValue *p2,
                      TMS event) {
  Inteiro tag = callbinTM(L, p1, p2, L->top.p, event);  /* try original event */
  Se (tag >= 0)  /* found tag method? */
    Retorne !tagisfalse(tag);
  sol_g_ordererror(L, p1, p2);  /* no metamethod found */
  Retorne 0;  /* to avoid warnings */
}


Inteiro sol_t_callorderiTM (sol_State *L, Imutável TValue *p1, Inteiro v2,
                       Inteiro flip, Inteiro isfloat, TMS event) {
  TValue aux; Imutável TValue *p2;
  Se (isfloat) {
    setfltvalue(&aux, cast_num(v2));
  }
  Senão
    setivalue(&aux, v2);
  Se (flip) {  /* arguments were exchanged? */
    p2 = p1; p1 = &aux;  /* correct them */
  }
  Senão
    p2 = &aux;
  Retorne sol_t_callorderTM(L, p1, p2, event);
}


Vazio sol_t_adjustvarargs (sol_State *L, Inteiro nfixparams, CallInfo *ci,
                         Imutável Proto *p) {
  Inteiro i;
  Inteiro actual = cast_int(L->top.p - ci->func.p) - 1;  /* number of arguments */
  Inteiro nextra = actual - nfixparams;  /* number of extra arguments */
  ci->u.l.nextraargs = nextra;
  sol_d_checkstack(L, p->maxstacksize + 1);
  /* copy function to the top of the stack */
  setobjs2s(L, L->top.p++, ci->func.p);
  /* move fixed parameters to the top of the stack */
  Para (i = 1; i <= nfixparams; i++) {
    setobjs2s(L, L->top.p++, ci->func.p + i);
    setnilvalue(s2v(ci->func.p + i));  /* erase original parameter (Para GC) */
  }
  ci->func.p += actual + 1;
  ci->top.p += actual + 1;
  sol_assert(L->top.p <= ci->top.p && ci->top.p <= L->stack_last.p);
}


Vazio sol_t_getvarargs (sol_State *L, CallInfo *ci, StkId where, Inteiro wanted) {
  Inteiro i;
  Inteiro nextra = ci->u.l.nextraargs;
  Se (wanted < 0) {
    wanted = nextra;  /* get all extra arguments available */
    checkstackp(L, nextra, where);  /* ensure stack space */
    L->top.p = where + nextra;  /* next instruction will need top */
  }
  Para (i = 0; i < wanted && i < nextra; i++)
    setobjs2s(L, where + i, ci->func.p - nextra + i);
  Para (; i < wanted; i++)   /* complete required results with nil */
    setnilvalue(s2v(where + i));
}

