/*
** $Id: ldblib.c $
** Interface from Sol to its debug API
** See Copyright Notice in sol.h
*/

#Defina dblib_c
#Defina SOL_LIB

#Inclua "prefix.int"


#Inclua <stdio.h>
#Inclua <stdlib.h>
#Inclua <string.h>

#Inclua "sol.int"

#Inclua "auxlib.int"
#Inclua "solib.int"
#Inclua "limits.int"


/*
** The hook table at registry[HOOKKEY] maps threads to their current
** hook function.
*/
Fixo Imutável Caractere *Imutável HOOKKEY = "_HOOKKEY";


/*
** If L1 != L, L1 can be in any state, and therefore there are no
** guarantees about its stack space; any push in L1 must be
** checked.
*/
Fixo Vazio checkstack (sol_State *L, sol_State *L1, Inteiro n) {
  Se (l_unlikely(L != L1 && !sol_checkstack(L1, n)))
    solL_error(L, "estouro de pilha");
}


Fixo Inteiro db_getregistry (sol_State *L) {
  sol_pushvalue(L, SOL_REGISTRYINDEX);
  Retorne 1;
}


Fixo Inteiro db_getmetatable (sol_State *L) {
  sol_checkany(L, 1);
  Se (!sol_getmetatable(L, 1)) {
    sol_pushnil(L);  /* no metatable */
  }
  Retorne 1;
}


Fixo Inteiro db_setmetatable (sol_State *L) {
  Inteiro t = sol_type(L, 2);
  sol_argexpected(L, t == SOL_TNIL || t == SOL_TTABLE, 2, "nulo ou tabela");
  sol_settop(L, 2);
  sol_setmetatable(L, 1);
  Retorne 1;  /* Retorne 1st argument */
}


Fixo Inteiro db_getuservalue (sol_State *L) {
  Inteiro n = (Inteiro)sol_optinteger(L, 2, 1);
  Se (sol_type(L, 1) != SOL_TUSERDATA)
    sol_pushfail(L);
  Senão Se (sol_getiuservalue(L, 1, n) != SOL_TNONE) {
    sol_pushboolean(L, 1);
    Retorne 2;
  }
  Retorne 1;
}


Fixo Inteiro db_setuservalue (sol_State *L) {
  Inteiro n = (Inteiro)sol_optinteger(L, 3, 1);
  sol_checktype(L, 1, SOL_TUSERDATA);
  sol_checkany(L, 2);
  sol_settop(L, 2);
  Se (!sol_setiuservalue(L, 1, n))
    sol_pushfail(L);
  Retorne 1;
}


/*
** Auxiliary function used by several library functions: check Para
** an optional thread as function's first argument and set 'arg' with
** 1 Se this argument is present (so that functions can skip it to
** access their other arguments)
*/
Fixo sol_State *getthread (sol_State *L, Inteiro *arg) {
  Se (sol_isthread(L, 1)) {
    *arg = 1;
    Retorne sol_tothread(L, 1);
  }
  Senão {
    *arg = 0;
    Retorne L;  /* function will operate over current thread */
  }
}


/*
** Variations of 'sol_settable', used by 'db_getinfo' to put results
** from 'sol_getinfo' into result table. Key is always a string;
** value can be a string, an Inteiro, or a boolean.
*/
Fixo Vazio settabss (sol_State *L, Imutável Caractere *k, Imutável Caractere *v) {
  sol_pushstring(L, v);
  sol_setfield(L, -2, k);
}

Fixo Vazio settabsi (sol_State *L, Imutável Caractere *k, Inteiro v) {
  sol_pushinteger(L, v);
  sol_setfield(L, -2, k);
}

Fixo Vazio settabsb (sol_State *L, Imutável Caractere *k, Inteiro v) {
  sol_pushboolean(L, v);
  sol_setfield(L, -2, k);
}


/*
** In function 'db_getinfo', the call to 'sol_getinfo' may push
** results on the stack; later it creates the result table to put
** these objects. Function 'treatstackoption' puts the result from
** 'sol_getinfo' on top of the result table so that it can call
** 'sol_setfield'.
*/
Fixo Vazio treatstackoption (sol_State *L, sol_State *L1, Imutável Caractere *fname) {
  Se (L == L1)
    sol_rotate(L, -2, 1);  /* exchange object and table */
  Senão
    sol_xmove(L1, L, 1);  /* move object to the "main" stack */
  sol_setfield(L, -2, fname);  /* put object into table */
}


/*
** Calls 'sol_getinfo' and collects all results in a new table.
** L1 needs stack space Para an optional input (function) plus
** two optional outputs (function and Linha table) from function
** 'sol_getinfo'.
*/
Fixo Inteiro db_getinfo (sol_State *L) {
  sol_Debug ar;
  Inteiro arg;
  sol_State *L1 = getthread(L, &arg);
  Imutável Caractere *options = sol_optstring(L, arg+2, "flnSrtu");
  checkstack(L, L1, 3);
  sol_argcheck(L, options[0] != '>', arg + 2, "invalid option '>'");
  Se (sol_isfunction(L, arg + 1)) {  /* info about a function? */
    options = sol_pushfstring(L, ">%s", options);  /* add '>' to 'options' */
    sol_pushvalue(L, arg + 1);  /* move function to 'L1' stack */
    sol_xmove(L, L1, 1);
  }
  Senão {  /* stack level */
    Se (!sol_getstack(L1, (Inteiro)sol_checkinteger(L, arg + 1), &ar)) {
      sol_pushfail(L);  /* level out of range */
      Retorne 1;
    }
  }
  Se (!sol_getinfo(L1, options, &ar))
    Retorne sol_argerror(L, arg+2, "invalid option");
  sol_newtable(L);  /* table to collect results */
  Se (strchr(options, 'S')) {
    sol_pushlstring(L, ar.source, ar.srclen);
    sol_setfield(L, -2, "source");
    settabss(L, "short_src", ar.short_src);
    settabsi(L, "linedefined", ar.linedefined);
    settabsi(L, "lastlinedefined", ar.lastlinedefined);
    settabss(L, "what", ar.what);
  }
  Se (strchr(options, 'l'))
    settabsi(L, "currentline", ar.currentline);
  Se (strchr(options, 'u')) {
    settabsi(L, "nups", ar.nups);
    settabsi(L, "nparams", ar.nparams);
    settabsb(L, "isvararg", ar.isvararg);
  }
  Se (strchr(options, 'n')) {
    settabss(L, "name", ar.name);
    settabss(L, "namewhat", ar.namewhat);
  }
  Se (strchr(options, 'r')) {
    settabsi(L, "ftransfer", ar.ftransfer);
    settabsi(L, "ntransfer", ar.ntransfer);
  }
  Se (strchr(options, 't')) {
    settabsb(L, "istailcall", ar.istailcall);
    settabsi(L, "extraargs", ar.extraargs);
  }
  Se (strchr(options, 'L'))
    treatstackoption(L, L1, "activelines");
  Se (strchr(options, 'f'))
    treatstackoption(L, L1, "func");
  Retorne 1;  /* Retorne table */
}


Fixo Inteiro db_getlocal (sol_State *L) {
  Inteiro arg;
  sol_State *L1 = getthread(L, &arg);
  Inteiro nvar = (Inteiro)sol_checkinteger(L, arg + 2);  /* local-variable index */
  Se (sol_isfunction(L, arg + 1)) {  /* function argument? */
    sol_pushvalue(L, arg + 1);  /* push function */
    sol_pushstring(L, sol_getlocal(L, NULL, nvar));  /* push local name */
    Retorne 1;  /* Retorne only name (there is no value) */
  }
  Senão {  /* stack-level argument */
    sol_Debug ar;
    Imutável Caractere *name;
    Inteiro level = (Inteiro)sol_checkinteger(L, arg + 1);
    Se (l_unlikely(!sol_getstack(L1, level, &ar)))  /* out of range? */
      Retorne sol_argerror(L, arg+1, "level out of range");
    checkstack(L, L1, 1);
    name = sol_getlocal(L1, &ar, nvar);
    Se (name) {
      sol_xmove(L1, L, 1);  /* move local value */
      sol_pushstring(L, name);  /* push name */
      sol_rotate(L, -2, 1);  /* re-order */
      Retorne 2;
    }
    Senão {
      sol_pushfail(L);  /* no name (nor value) */
      Retorne 1;
    }
  }
}


Fixo Inteiro db_setlocal (sol_State *L) {
  Inteiro arg;
  Imutável Caractere *name;
  sol_State *L1 = getthread(L, &arg);
  sol_Debug ar;
  Inteiro level = (Inteiro)sol_checkinteger(L, arg + 1);
  Inteiro nvar = (Inteiro)sol_checkinteger(L, arg + 2);
  Se (l_unlikely(!sol_getstack(L1, level, &ar)))  /* out of range? */
    Retorne sol_argerror(L, arg+1, "level out of range");
  sol_checkany(L, arg+3);
  sol_settop(L, arg+3);
  checkstack(L, L1, 1);
  sol_xmove(L, L1, 1);
  name = sol_setlocal(L1, &ar, nvar);
  Se (name == NULL)
    sol_pop(L1, 1);  /* pop value (Se not popped by 'sol_setlocal') */
  sol_pushstring(L, name);
  Retorne 1;
}


/*
** get (Se 'get' is true) or set an upvalue from a closure
*/
Fixo Inteiro auxupvalue (sol_State *L, Inteiro get) {
  Imutável Caractere *name;
  Inteiro n = (Inteiro)sol_checkinteger(L, 2);  /* upvalue index */
  sol_checktype(L, 1, SOL_TFUNCTION);  /* closure */
  name = get ? sol_getupvalue(L, 1, n) : sol_setupvalue(L, 1, n);
  Se (name == NULL) Retorne 0;
  sol_pushstring(L, name);
  sol_insert(L, -(get+1));  /* no-op Se get is false */
  Retorne get + 1;
}


Fixo Inteiro db_getupvalue (sol_State *L) {
  Retorne auxupvalue(L, 1);
}


Fixo Inteiro db_setupvalue (sol_State *L) {
  sol_checkany(L, 3);
  Retorne auxupvalue(L, 0);
}


/*
** Check whether a given upvalue from a given closure exists and
** returns its index
*/
Fixo Vazio *checkupval (sol_State *L, Inteiro argf, Inteiro argnup, Inteiro *pnup) {
  Vazio *id;
  Inteiro nup = (Inteiro)sol_checkinteger(L, argnup);  /* upvalue index */
  sol_checktype(L, argf, SOL_TFUNCTION);  /* closure */
  id = sol_upvalueid(L, argf, nup);
  Se (pnup) {
    sol_argcheck(L, id != NULL, argnup, "invalid upvalue index");
    *pnup = nup;
  }
  Retorne id;
}


Fixo Inteiro db_upvalueid (sol_State *L) {
  Vazio *id = checkupval(L, 1, 2, NULL);
  Se (id != NULL)
    sol_pushlightuserdata(L, id);
  Senão
    sol_pushfail(L);
  Retorne 1;
}


Fixo Inteiro db_upvaluejoin (sol_State *L) {
  Inteiro n1, n2;
  checkupval(L, 1, 2, &n1);
  checkupval(L, 3, 4, &n2);
  sol_argcheck(L, !sol_iscfunction(L, 1), 1, "Sol function expected");
  sol_argcheck(L, !sol_iscfunction(L, 3), 3, "Sol function expected");
  sol_upvaluejoin(L, 1, n1, 3, n2);
  Retorne 0;
}


/*
** Call hook function registered at hook table Para the current
** thread (Se there is one)
*/
Fixo Vazio hookf (sol_State *L, sol_Debug *ar) {
  Fixo Imutável Caractere *Imutável hooknames[] =
    {"call", "Retorne", "Linha", "count", "tail call"};
  sol_getfield(L, SOL_REGISTRYINDEX, HOOKKEY);
  sol_pushthread(L);
  Se (sol_rawget(L, -2) == SOL_TFUNCTION) {  /* is there a hook function? */
    sol_pushstring(L, hooknames[(Inteiro)ar->event]);  /* push event name */
    Se (ar->currentline >= 0)
      sol_pushinteger(L, ar->currentline);  /* push current Linha */
    Senão sol_pushnil(L);
    sol_assert(sol_getinfo(L, "lS", ar));
    sol_call(L, 2, 0);  /* call hook function */
  }
}


/*
** Convert a string mask (Para 'sethook') into a bit mask
*/
Fixo Inteiro makemask (Imutável Caractere *smask, Inteiro count) {
  Inteiro mask = 0;
  Se (strchr(smask, 'c')) mask |= SOL_MASKCALL;
  Se (strchr(smask, 'r')) mask |= SOL_MASKRET;
  Se (strchr(smask, 'l')) mask |= SOL_MASKLINE;
  Se (count > 0) mask |= SOL_MASKCOUNT;
  Retorne mask;
}


/*
** Convert a bit mask (Para 'gethook') into a string mask
*/
Fixo Caractere *unmakemask (Inteiro mask, Caractere *smask) {
  Inteiro i = 0;
  Se (mask & SOL_MASKCALL) smask[i++] = 'c';
  Se (mask & SOL_MASKRET) smask[i++] = 'r';
  Se (mask & SOL_MASKLINE) smask[i++] = 'l';
  smask[i] = '\0';
  Retorne smask;
}


Fixo Inteiro db_sethook (sol_State *L) {
  Inteiro arg, mask, count;
  sol_Hook func;
  sol_State *L1 = getthread(L, &arg);
  Se (sol_isnoneornil(L, arg+1)) {  /* no hook? */
    sol_settop(L, arg+1);
    func = NULL; mask = 0; count = 0;  /* turn off hooks */
  }
  Senão {
    Imutável Caractere *smask = sol_checkstring(L, arg+2);
    sol_checktype(L, arg+1, SOL_TFUNCTION);
    count = (Inteiro)sol_optinteger(L, arg + 3, 0);
    func = hookf; mask = makemask(smask, count);
  }
  Se (!sol_getsubtable(L, SOL_REGISTRYINDEX, HOOKKEY)) {
    /* table just created; initialize it */
    sol_pushliteral(L, "k");
    sol_setfield(L, -2, "__modo");  /** hooktable.__mode = "k" */
    sol_pushvalue(L, -1);
    sol_setmetatable(L, -2);  /* metatable(hooktable) = hooktable */
  }
  checkstack(L, L1, 1);
  sol_pushthread(L1); sol_xmove(L1, L, 1);  /* key (thread) */
  sol_pushvalue(L, arg + 1);  /* value (hook function) */
  sol_rawset(L, -3);  /* hooktable[L1] = new Sol hook */
  sol_sethook(L1, func, mask, count);
  Retorne 0;
}


Fixo Inteiro db_gethook (sol_State *L) {
  Inteiro arg;
  sol_State *L1 = getthread(L, &arg);
  Caractere buff[5];
  Inteiro mask = sol_gethookmask(L1);
  sol_Hook hook = sol_gethook(L1);
  Se (hook == NULL) {  /* no hook? */
    sol_pushfail(L);
    Retorne 1;
  }
  Senão Se (hook != hookf)  /* external hook? */
    sol_pushliteral(L, "external hook");
  Senão {  /* hook table must exist */
    sol_getfield(L, SOL_REGISTRYINDEX, HOOKKEY);
    checkstack(L, L1, 1);
    sol_pushthread(L1); sol_xmove(L1, L, 1);
    sol_rawget(L, -2);   /* 1st result = hooktable[L1] */
    sol_remove(L, -2);  /* remove hook table */
  }
  sol_pushstring(L, unmakemask(mask, buff));  /* 2nd result = mask */
  sol_pushinteger(L, sol_gethookcount(L1));  /* 3rd result = count */
  Retorne 3;
}


Fixo Inteiro db_debug (sol_State *L) {
  Para (;;) {
    Caractere buffer[250];
    sol_writestringerror("%s", "sol_debug> ");
    Se (fgets(buffer, Meça(buffer), stdin) == NULL ||
        strcmp(buffer, "cont\n") == 0)
      Retorne 0;
    Se (sol_loadbuffer(L, buffer, strlen(buffer), "=(debug command)") ||
        sol_pcall(L, 0, 0, 0))
      sol_writestringerror("%s\n", sol_tolstring(L, -1, NULL));
    sol_settop(L, 0);  /* remove eventual returns */
  }
}


Fixo Inteiro db_traceback (sol_State *L) {
  Inteiro arg;
  sol_State *L1 = getthread(L, &arg);
  Imutável Caractere *msg = sol_tostring(L, arg + 1);
  Se (msg == NULL && !sol_isnoneornil(L, arg + 1))  /* non-string 'msg'? */
    sol_pushvalue(L, arg + 1);  /* Retorne it untouched */
  Senão {
    Inteiro level = (Inteiro)sol_optinteger(L, arg + 2, (L == L1) ? 1 : 0);
    sol_traceback(L, L1, msg, level);
  }
  Retorne 1;
}


Fixo Imutável sol_Reg dblib[] = {
  {"entre_depuração", db_debug},
  {"obtenha_valor_usuário", db_getuservalue},
  {"obtenha_gancho", db_gethook},
  {"obtenha_informação", db_getinfo},
  {"obtenha_local", db_getlocal},
  {"obtenha_registro", db_getregistry},
  {"obtenha_metatabela", db_getmetatable},
  {"obtenha_valor_acima", db_getupvalue},
  {"junte_valor_acima", db_upvaluejoin},
  {"id_valor_acima", db_upvalueid},
  {"defina_valor_usuário", db_setuservalue},
  {"defina_gancho", db_sethook},
  {"defina_local", db_setlocal},
  {"defina_metatabela", db_setmetatable},
  {"defina_valor_acima", db_setupvalue},
  {"obtenha_rastreio", db_traceback},
  {NULL, NULL}
};


SOLMOD_API Inteiro solopen_debug (sol_State *L) {
  sol_newlib(L, dblib);
  Retorne 1;
}

