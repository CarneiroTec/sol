/*
** teste_lsp_validacao_docs.ctec - VALIDA√á√ÉO: LSP vs Documenta√ß√£o
** 
** Este teste valida se o LSP implementa EXATAMENTE o que a documenta√ß√£o diz.
** A documenta√ß√£o (sol-linguagem/docs/pages/) √© a FONTE DE VERDADE.
** Se o teste falhar, o LSP precisa ser CORRIGIDO.
**
** Documenta√ß√£o testada:
** - variaveis.php: escopo local/global
** - funcoes.php: par√¢metros, closures
** - sintaxe.php: keywords
**
** Para cada regra da documenta√ß√£o: 4 cen√°rios
*/

#Defina teste_validacao_c
#Defina SOL_LIB

#Inclua "prefix.int"
#Inclua <stdio.h>
#Inclua <stdlib.h>
#Inclua <string.h>
#Inclua "sol.int"
#Inclua "auxlib.int"
#Inclua "lsp.int"

#Defina TESTE_OK 1
#Defina TESTE_FALHA 0
#Defina MAX_ERRO 512

Fixo Inteiro total_testes = 0;
Fixo Inteiro testes_passaram = 0;
Fixo Caractere ultimo_erro[MAX_ERRO] = "";

Fixo Vazio registra_erro(Imut√°vel Caractere *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vsnprintf(ultimo_erro, MAX_ERRO, fmt, args);
    va_end(args);
}

Fixo Vazio imprime_resultado(Imut√°vel Caractere *regra, Imut√°vel Caractere *cenario, Inteiro ok) {
    total_testes++;
    Se (ok) {
        testes_passaram++;
        fprintf(stderr, "  ‚úì [%s] %s\n", regra, cenario);
    } Sen√£o {
        fprintf(stderr, "  ‚úó [%s] %s%s\n", regra, cenario, ultimo_erro);
    }
}

/* ============================================================
** Fun√ß√µes auxiliares de valida√ß√£o
** ============================================================ */

Fixo Inteiro var_existe(LSPDocument *doc, Imut√°vel Caractere *nome) {
    Para (Inteiro i = 0; i < doc->variableCount; i++) {
        Se (strcmp(doc->variables[i].name, nome) == 0) {
            Retorne 1;
        }
    }
    Retorne 0;
}

Fixo Inteiro var_visivel_na_linha(LSPDocument *doc, Imut√°vel Caractere *nome, Inteiro linha) {
    Para (Inteiro i = 0; i < doc->variableCount; i++) {
        Se (strcmp(doc->variables[i].name, nome) == 0) {
            Se (linha >= doc->variables[i].scopeStartLine && 
                linha <= doc->variables[i].scopeEndLine) {
                Retorne 1;
            }
        }
    }
    Retorne 0;
}

Fixo Inteiro var_invisivel_na_linha(LSPDocument *doc, Imut√°vel Caractere *nome, Inteiro linha) {
    Para (Inteiro i = 0; i < doc->variableCount; i++) {
        Se (strcmp(doc->variables[i].name, nome) == 0) {
            Se (linha >= doc->variables[i].scopeStartLine && 
                linha <= doc->variables[i].scopeEndLine) {
                Retorne 0;  /* Vis√≠vel = falha */
            }
        }
    }
    Retorne 1;  /* Invis√≠vel ou n√£o existe */
}

/* ============================================================
** REGRA DOC: "local dentro de bloco morre quando bloco termina"
** Fonte: variaveis.php - Escopo de Bloco
** ============================================================ */

Vazio teste_doc_escopo_bloco_se() {
    fprintf(stderr, "\nüìñ DOC: 'local dentro de se morre quando se termina'\n");
    
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    
    /* C√≥digo exato da documenta√ß√£o:
       se verdadeiro ent√£o
           local segredo = "1234"
           exiba(segredo)  -- Funciona
       fim
       exiba(segredo)      -- Erro/Nulo! 
    */
    Imut√°vel Caractere *codigo = 
        "se verdadeiro ent√£o\n"      /* linha 0 */
        "    local segredo = \"1234\"\n"  /* linha 1 */
        "    exiba(segredo)\n"        /* linha 2 */
        "fim\n"                       /* linha 3 */
        "exiba(segredo)\n";           /* linha 4 */
    
    LSPDocument *doc = lsp_add_document(lsp, "file:///doc_escopo.sol", codigo);
    lsp_analyze_document(lsp, doc);
    
    /* ESPERADO: segredo vis√≠vel na linha 2 (dentro do se) */
    Inteiro ok1 = var_visivel_na_linha(doc, "segredo", 2);
    Se (!ok1) registra_erro(": 'segredo' deveria estar vis√≠vel na linha 2");
    imprime_resultado("ESCOPO_SE", "ESPERADO: segredo vis√≠vel dentro do bloco", ok1);
    
    /* NAO_ESPERADO: segredo N√ÉO vis√≠vel na linha 4 (fora do se) */
    Inteiro ok2 = var_invisivel_na_linha(doc, "segredo", 4);
    Se (!ok2) registra_erro(": 'segredo' VAZOU para fora do bloco (linha 4)");
    imprime_resultado("ESCOPO_SE", "NAO_ESPERADO: segredo invis√≠vel fora do bloco", ok2);
    
    /* NULO: bloco vazio */
    LSPDocument *doc2 = lsp_add_document(lsp, "file:///vazio.sol", "se verdadeiro ent√£o\nfim\n");
    lsp_analyze_document(lsp, doc2);
    imprime_resultado("ESCOPO_SE", "NULO: bloco vazio n√£o crashou", TESTE_OK);
    
    /* ESTOURO: muitos blocos aninhados (limite documentado: 32) */
    Caractere aninhado[4096];
    Inteiro pos = 0;
    Para (Inteiro i = 0; i < 35; i++) {
        pos += snprintf(aninhado + pos, 4096 - pos, "se verdadeiro ent√£o\n");
    }
    Para (Inteiro i = 0; i < 35; i++) {
        pos += snprintf(aninhado + pos, 4096 - pos, "fim\n");
    }
    LSPDocument *doc3 = lsp_add_document(lsp, "file:///aninhado.sol", aninhado);
    lsp_analyze_document(lsp, doc3);
    imprime_resultado("ESCOPO_SE", "ESTOURO: 35 blocos aninhados n√£o crashou", TESTE_OK);
    
    lsp_shutdown(lsp);
    sol_close(L);
}

/* ============================================================
** REGRA DOC: "par√¢metros de fun√ß√£o vis√≠veis apenas dentro"
** Fonte: funcoes.php - Fun√ß√µes com par√¢metros
** ============================================================ */

Vazio teste_doc_parametros_funcao() {
    fprintf(stderr, "\nüìñ DOC: 'par√¢metros vis√≠veis apenas dentro da fun√ß√£o'\n");
    
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    
    /* C√≥digo baseado na documenta√ß√£o:
       fun√ß√£o diga_oi_para(nome)
           exiba("Ol√°, " .. nome .. "!")
       fim
    */
    Imut√°vel Caractere *codigo = 
        "fun√ß√£o diga_oi_para(nome)\n"     /* linha 0 */
        "    exiba(\"Ol√°, \" .. nome)\n"  /* linha 1 */
        "fim\n"                           /* linha 2 */
        "local x = 1\n";                  /* linha 3 */
    
    LSPDocument *doc = lsp_add_document(lsp, "file:///doc_param.sol", codigo);
    lsp_analyze_document(lsp, doc);
    
    /* ESPERADO: nome vis√≠vel na linha 1 (dentro) */
    Inteiro ok1 = var_visivel_na_linha(doc, "nome", 1);
    Se (!ok1) registra_erro(": 'nome' deveria estar vis√≠vel na linha 1");
    imprime_resultado("PARAM_FUNC", "ESPERADO: par√¢metro vis√≠vel dentro", ok1);
    
    /* NAO_ESPERADO: nome N√ÉO vis√≠vel na linha 3 (fora) */
    Inteiro ok2 = var_invisivel_na_linha(doc, "nome", 3);
    Se (!ok2) registra_erro(": 'nome' VAZOU para fora da fun√ß√£o");
    imprime_resultado("PARAM_FUNC", "NAO_ESPERADO: par√¢metro invis√≠vel fora", ok2);
    
    /* NULO: fun√ß√£o sem par√¢metros */
    LSPDocument *doc2 = lsp_add_document(lsp, "file:///sem_param.sol", 
        "fun√ß√£o vazia()\n    retorne nulo\nfim\n");
    lsp_analyze_document(lsp, doc2);
    imprime_resultado("PARAM_FUNC", "NULO: fun√ß√£o sem par√¢metros OK", TESTE_OK);
    
    /* ESTOURO: muitos par√¢metros */
    Caractere codigo_params[4096];
    Inteiro pos = snprintf(codigo_params, 4096, "fun√ß√£o grande(");
    Para (Inteiro i = 0; i < 100; i++) {
        pos += snprintf(codigo_params + pos, 4096 - pos, "p%d%s", i, i < 99 ? ", " : "");
    }
    snprintf(codigo_params + pos, 4096 - pos, ")\n    retorne p0\nfim\n");
    
    LSPDocument *doc3 = lsp_add_document(lsp, "file:///muitos_params.sol", codigo_params);
    lsp_analyze_document(lsp, doc3);
    
    Inteiro ok3 = var_visivel_na_linha(doc3, "p0", 1) && var_visivel_na_linha(doc3, "p99", 1);
    Se (!ok3) registra_erro(": nem todos os 100 par√¢metros foram registrados");
    imprime_resultado("PARAM_FUNC", "ESTOURO: 100 par√¢metros registrados", ok3);
    
    lsp_shutdown(lsp);
    sol_close(L);
}

/* ============================================================
** REGRA DOC: "vari√°vel de loop vis√≠vel apenas dentro"
** Fonte: funcoes.php - para/em/fa√ßa
** ============================================================ */

Vazio teste_doc_variavel_loop() {
    fprintf(stderr, "\nüìñ DOC: 'vari√°vel de loop vis√≠vel apenas dentro'\n");
    
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    
    /* C√≥digo baseado na documenta√ß√£o:
       para i, v em obtenha_pares_indexados(args) fa√ßa
           total = total + v
       fim
    */
    Imut√°vel Caractere *codigo = 
        "para i, v em pares({}) fa√ßa\n"   /* linha 0 */
        "    exiba(i, v)\n"               /* linha 1 */
        "fim\n"                           /* linha 2 */
        "local x = 1\n";                  /* linha 3 */
    
    LSPDocument *doc = lsp_add_document(lsp, "file:///doc_loop.sol", codigo);
    lsp_analyze_document(lsp, doc);
    
    /* ESPERADO: i e v vis√≠veis na linha 1 */
    Inteiro ok1 = var_visivel_na_linha(doc, "i", 1) && var_visivel_na_linha(doc, "v", 1);
    Se (!ok1) registra_erro(": 'i' e 'v' deveriam estar vis√≠veis na linha 1");
    imprime_resultado("VAR_LOOP", "ESPERADO: vari√°veis de loop vis√≠veis dentro", ok1);
    
    /* NAO_ESPERADO: i e v N√ÉO vis√≠veis na linha 3 */
    Inteiro ok2 = var_invisivel_na_linha(doc, "i", 3) && var_invisivel_na_linha(doc, "v", 3);
    Se (!ok2) registra_erro(": vari√°veis de loop VAZARAM");
    imprime_resultado("VAR_LOOP", "NAO_ESPERADO: vari√°veis invis√≠veis fora", ok2);
    
    /* NULO: _ (underscore) n√£o deve ser registrado */
    LSPDocument *doc2 = lsp_add_document(lsp, "file:///underscore.sol", 
        "para _, v em pares({}) fa√ßa\n    exiba(v)\nfim\n");
    lsp_analyze_document(lsp, doc2);
    
    Inteiro ok3 = !var_existe(doc2, "_");
    Se (!ok3) registra_erro(": '_' n√£o deveria ser registrado como vari√°vel");
    imprime_resultado("VAR_LOOP", "NULO: underscore n√£o registrado", ok3);
    
    /* ESTOURO: loops aninhados */
    Caractere loops[8192];
    Inteiro pos = 0;
    Para (Inteiro i = 0; i < 20; i++) {
        pos += snprintf(loops + pos, 8192 - pos, "para v%d = 1, 5 fa√ßa\n", i);
    }
    pos += snprintf(loops + pos, 8192 - pos, "local x = 1\n");
    Para (Inteiro i = 19; i >= 0; i--) {
        pos += snprintf(loops + pos, 8192 - pos, "fim\n");
    }
    
    LSPDocument *doc3 = lsp_add_document(lsp, "file:///loops_aninhados.sol", loops);
    lsp_analyze_document(lsp, doc3);
    
    /* v0 deve estar vis√≠vel na linha 20 (no meio) */
    Inteiro ok4 = var_visivel_na_linha(doc3, "v0", 20) && var_visivel_na_linha(doc3, "v19", 20);
    Se (!ok4) registra_erro(": vari√°veis de loops aninhados n√£o registradas");
    imprime_resultado("VAR_LOOP", "ESTOURO: 20 loops aninhados OK", ok4);
    
    lsp_shutdown(lsp);
    sol_close(L);
}

/* ============================================================
** REGRA DOC: "local fora de fun√ß√£o = vis√≠vel em todo arquivo"
** Fonte: variaveis.php - Escopo de Arquivo
** ============================================================ */

Vazio teste_doc_local_arquivo() {
    fprintf(stderr, "\nüìñ DOC: 'local fora de fun√ß√£o vis√≠vel em todo arquivo'\n");
    
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    
    /* C√≥digo baseado na documenta√ß√£o:
       local apenas_aqui = 10
       fun√ß√£o teste()
           exiba(apenas_aqui)  -- Funciona!
       fim
    */
    Imut√°vel Caractere *codigo = 
        "local apenas_aqui = 10\n"        /* linha 0 */
        "fun√ß√£o teste()\n"                /* linha 1 */
        "    exiba(apenas_aqui)\n"        /* linha 2 */
        "fim\n"                           /* linha 3 */
        "exiba(apenas_aqui)\n";           /* linha 4 */
    
    LSPDocument *doc = lsp_add_document(lsp, "file:///doc_arquivo.sol", codigo);
    lsp_analyze_document(lsp, doc);
    
    /* ESPERADO: apenas_aqui vis√≠vel na linha 0, 2 e 4 (todo o arquivo) */
    Inteiro ok1 = var_visivel_na_linha(doc, "apenas_aqui", 0) &&
                  var_visivel_na_linha(doc, "apenas_aqui", 4);
    Se (!ok1) registra_erro(": 'apenas_aqui' deveria estar vis√≠vel em todo arquivo");
    imprime_resultado("LOCAL_ARQ", "ESPERADO: local de arquivo vis√≠vel em todo lugar", ok1);
    
    /* NAO_ESPERADO: n√£o aplic√°vel para este cen√°rio */
    imprime_resultado("LOCAL_ARQ", "NAO_ESPERADO: N/A para escopo de arquivo", TESTE_OK);
    
    /* NULO: arquivo vazio */
    LSPDocument *doc2 = lsp_add_document(lsp, "file:///vazio.sol", "");
    lsp_analyze_document(lsp, doc2);
    imprime_resultado("LOCAL_ARQ", "NULO: arquivo vazio OK", TESTE_OK);
    
    /* ESTOURO: muitas vari√°veis de arquivo */
    Caractere muitas[32768];
    Inteiro pos = 0;
    Para (Inteiro i = 0; i < 200; i++) {
        pos += snprintf(muitas + pos, 32768 - pos, "local var%d = %d\n", i, i);
    }
    
    LSPDocument *doc3 = lsp_add_document(lsp, "file:///muitas.sol", muitas);
    lsp_analyze_document(lsp, doc3);
    
    Inteiro ok2 = var_existe(doc3, "var0") && var_existe(doc3, "var199");
    Se (!ok2) registra_erro(": nem todas as vari√°veis foram registradas");
    imprime_resultado("LOCAL_ARQ", "ESTOURO: 200 vari√°veis de arquivo OK", ok2);
    
    lsp_shutdown(lsp);
    sol_close(L);
}

/* ============================================================
** REGRA DOC: "m√∫ltiplos retornos de fun√ß√£o"
** Fonte: funcoes.php - M√∫ltiplos retornos
** ============================================================ */

Vazio teste_doc_multiplos_retornos() {
    fprintf(stderr, "\nüìñ DOC: 'fun√ß√µes podem devolver v√°rias coisas'\n");
    
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    
    /* C√≥digo exato da documenta√ß√£o:
       fun√ß√£o divide_com_resto(a, b)
           local quociente = a // b
           local resto = a % b
           retorne quociente, resto
       fim
       local q, r = divide_com_resto(17, 5)
    */
    Imut√°vel Caractere *codigo = 
        "fun√ß√£o divide_com_resto(a, b)\n"     /* linha 0 */
        "    local quociente = a // b\n"      /* linha 1 */
        "    local resto = a % b\n"           /* linha 2 */
        "    retorne quociente, resto\n"      /* linha 3 */
        "fim\n"                               /* linha 4 */
        "local q, r = divide_com_resto(17, 5)\n"; /* linha 5 */
    
    LSPDocument *doc = lsp_add_document(lsp, "file:///doc_retorno.sol", codigo);
    lsp_analyze_document(lsp, doc);
    
    /* ESPERADO: quociente e resto vis√≠veis dentro da fun√ß√£o */
    Inteiro ok1 = var_visivel_na_linha(doc, "quociente", 3) && 
                  var_visivel_na_linha(doc, "resto", 3);
    Se (!ok1) registra_erro(": vari√°veis locais n√£o detectadas");
    imprime_resultado("RETORNO", "ESPERADO: vari√°veis internas detectadas", ok1);
    
    /* NAO_ESPERADO: quociente e resto N√ÉO vis√≠veis fora */
    Inteiro ok2 = var_invisivel_na_linha(doc, "quociente", 5) &&
                  var_invisivel_na_linha(doc, "resto", 5);
    Se (!ok2) registra_erro(": vari√°veis internas VAZARAM");
    imprime_resultado("RETORNO", "NAO_ESPERADO: vari√°veis internas n√£o vazam", ok2);
    
    /* NULO: fun√ß√£o sem retorno */
    LSPDocument *doc2 = lsp_add_document(lsp, "file:///sem_ret.sol", 
        "fun√ß√£o vazia()\nfim\n");
    lsp_analyze_document(lsp, doc2);
    imprime_resultado("RETORNO", "NULO: fun√ß√£o sem retorno OK", TESTE_OK);
    
    /* ESTOURO: muitos valores de retorno (declara√ß√£o com m√∫ltiplas vari√°veis) */
    Caractere multi[4096];
    Inteiro pos = snprintf(multi, 4096, "local ");
    Para (Inteiro i = 0; i < 20; i++) {
        pos += snprintf(multi + pos, 4096 - pos, "v%d%s", i, i < 19 ? ", " : " = f()\n");
    }
    
    LSPDocument *doc3 = lsp_add_document(lsp, "file:///multi_ret.sol", multi);
    lsp_analyze_document(lsp, doc3);
    
    Inteiro ok3 = var_existe(doc3, "v0") && var_existe(doc3, "v19");
    Se (!ok3) registra_erro(": nem todas as vari√°veis m√∫ltiplas detectadas");
    imprime_resultado("RETORNO", "ESTOURO: 20 vari√°veis m√∫ltiplas OK", ok3);
    
    lsp_shutdown(lsp);
    sol_close(L);
}

/* ============================================================
** REGRA DOC: "closures lembram vari√°veis"
** Fonte: funcoes.php - Closures
** ============================================================ */

Vazio teste_doc_closures() {
    fprintf(stderr, "\nüìñ DOC: 'closure lembra vari√°veis de onde foi criada'\n");
    
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    
    /* C√≥digo exato da documenta√ß√£o:
       fun√ß√£o cria_contador()
           local contagem = 0
           retorne fun√ß√£o()
               contagem = contagem + 1
               retorne contagem
           fim
       fim
    */
    Imut√°vel Caractere *codigo = 
        "fun√ß√£o cria_contador()\n"            /* linha 0 */
        "    local contagem = 0\n"            /* linha 1 */
        "    retorne fun√ß√£o()\n"              /* linha 2 */
        "        contagem = contagem + 1\n"   /* linha 3 */
        "        retorne contagem\n"          /* linha 4 */
        "    fim\n"                           /* linha 5 */
        "fim\n";                              /* linha 6 */
    
    LSPDocument *doc = lsp_add_document(lsp, "file:///doc_closure.sol", codigo);
    lsp_analyze_document(lsp, doc);
    
    /* ESPERADO: contagem existe */
    Inteiro ok1 = var_existe(doc, "contagem");
    Se (!ok1) registra_erro(": 'contagem' n√£o detectada");
    imprime_resultado("CLOSURE", "ESPERADO: vari√°vel de closure detectada", ok1);
    
    /* Os outros cen√°rios s√£o mais complexos para LSP, validamos que n√£o crashou */
    imprime_resultado("CLOSURE", "NAO_ESPERADO: N/A para an√°lise est√°tica", TESTE_OK);
    imprime_resultado("CLOSURE", "NULO: N/A para an√°lise est√°tica", TESTE_OK);
    imprime_resultado("CLOSURE", "ESTOURO: N/A para an√°lise est√°tica", TESTE_OK);
    
    lsp_shutdown(lsp);
    sol_close(L);
}

/* ============================================================
** REGRA DOC: "tabelas com campos"
** Fonte: tipo-tabelas.php
** ============================================================ */

Vazio teste_doc_tabelas() {
    fprintf(stderr, "\nüìñ DOC: 'tabelas podem ter campos nomeados'\n");
    
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    
    Imut√°vel Caractere *codigo = 
        "local pessoa = {\n"
        "    nome = \"Jo√£o\",\n"
        "    idade = 25,\n"
        "    ativo = verdadeiro\n"
        "}\n";
    
    LSPDocument *doc = lsp_add_document(lsp, "file:///doc_tabela.sol", codigo);
    lsp_analyze_document(lsp, doc);
    
    /* ESPERADO: pessoa existe e tem tipo TABLE */
    Inteiro ok1 = 0;
    Para (Inteiro i = 0; i < doc->variableCount; i++) {
        Se (strcmp(doc->variables[i].name, "pessoa") == 0) {
            Se (doc->variables[i].type == LSP_TYPE_TABLE) {
                ok1 = 1;
            }
            Interrompa;
        }
    }
    Se (!ok1) registra_erro(": 'pessoa' n√£o detectada como TABLE");
    imprime_resultado("TABELA", "ESPERADO: tabela detectada com tipo correto", ok1);
    
    /* ESPERADO: campos detectados */
    Inteiro ok2 = 0;
    Para (Inteiro i = 0; i < doc->variableCount; i++) {
        Se (strcmp(doc->variables[i].name, "pessoa") == 0) {
            Se (doc->variables[i].fieldCount >= 3) {
                ok2 = 1;
            }
            Interrompa;
        }
    }
    Se (!ok2) registra_erro(": campos da tabela n√£o detectados");
    imprime_resultado("TABELA", "ESPERADO: campos da tabela detectados", ok2);
    
    imprime_resultado("TABELA", "NAO_ESPERADO: N/A", TESTE_OK);
    
    /* NULO: tabela vazia */
    LSPDocument *doc2 = lsp_add_document(lsp, "file:///tabela_vazia.sol", "local t = {}\n");
    lsp_analyze_document(lsp, doc2);
    imprime_resultado("TABELA", "NULO: tabela vazia OK", TESTE_OK);
    
    /* ESTOURO: muitos campos */
    Caractere muitos[32768];
    Inteiro pos = snprintf(muitos, 32768, "local t = {\n");
    Para (Inteiro i = 0; i < 150; i++) {
        pos += snprintf(muitos + pos, 32768 - pos, "    campo%d = %d,\n", i, i);
    }
    pos += snprintf(muitos + pos, 32768 - pos, "}\n");
    
    LSPDocument *doc3 = lsp_add_document(lsp, "file:///muitos_campos.sol", muitos);
    lsp_analyze_document(lsp, doc3);
    
    Inteiro ok3 = 0;
    Para (Inteiro i = 0; i < doc3->variableCount; i++) {
        Se (strcmp(doc3->variables[i].name, "t") == 0) {
            ok3 = (doc3->variables[i].fieldCount <= LSP_MAX_FIELDS);
            Interrompa;
        }
    }
    imprime_resultado("TABELA", "ESTOURO: respeita LSP_MAX_FIELDS", ok3);
    
    lsp_shutdown(lsp);
    sol_close(L);
}

/* ============================================================
** Fun√ß√£o Principal
** ============================================================ */

Inteiro In√≠cio() {
    fprintf(stderr, "\n");
    fprintf(stderr, "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    fprintf(stderr, "‚ïë  VALIDA√á√ÉO: LSP vs DOCUMENTA√á√ÉO                          ‚ïë\n");
    fprintf(stderr, "‚ïë  Fonte de Verdade: sol-linguagem/docs/pages/             ‚ïë\n");
    fprintf(stderr, "‚ïë  Se falhar, o LSP precisa ser CORRIGIDO                  ‚ïë\n");
    fprintf(stderr, "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    teste_doc_escopo_bloco_se();
    teste_doc_parametros_funcao();
    teste_doc_variavel_loop();
    teste_doc_local_arquivo();
    teste_doc_multiplos_retornos();
    teste_doc_closures();
    teste_doc_tabelas();
    
    fprintf(stderr, "\n");
    fprintf(stderr, "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    fprintf(stderr, "  RESULTADO FINAL: %d/%d testes passaram\n", testes_passaram, total_testes);
    
    Se (testes_passaram == total_testes) {
        fprintf(stderr, "  ‚úÖ LSP est√° de acordo com a documenta√ß√£o!\n");
    } Sen√£o {
        fprintf(stderr, "  ‚ùå LSP N√ÉO est√° de acordo com a documenta√ß√£o!\n");
        fprintf(stderr, "  ‚Üí Corrija o lsplib.ctec para seguir a documenta√ß√£o\n");
    }
    fprintf(stderr, "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n");
    
    Retorne (testes_passaram == total_testes) ? 0 : 1;
}
