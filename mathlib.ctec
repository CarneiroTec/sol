/*
** $Id: lmathlib.c $
** Standard mathematical library
** See Copyright Notice in sol.h
*/

#Defina mathlib_c
#Defina SOL_LIB

#Inclua "prefix.int"


#Inclua <float.h>
#Inclua <limits.h>
#Inclua <math.h>
#Inclua <stdlib.h>
#Inclua <time.h>

#Inclua "sol.int"

#Inclua "auxlib.int"
#Inclua "solib.int"
#Inclua "limits.int"


#Esqueça PI
#Defina PI	(l_mathop(3.141592653589793238462643383279502884))


Fixo Inteiro math_abs (sol_State *L) {
  Se (sol_isinteger(L, 1)) {
    sol_Integer n = sol_tointeger(L, 1);
    Se (n < 0) n = (sol_Integer)(0u - (sol_Unsigned)n);
    sol_pushinteger(L, n);
  }
  Senão
    sol_pushnumber(L, l_mathop(fabs)(sol_checknumber(L, 1)));
  Retorne 1;
}


Fixo Inteiro math_sin (sol_State *L) {
  sol_pushnumber(L, l_mathop(sin)(sol_checknumber(L, 1)));
  Retorne 1;
}


Fixo Inteiro math_cos (sol_State *L) {
  sol_pushnumber(L, l_mathop(cos)(sol_checknumber(L, 1)));
  Retorne 1;
}


Fixo Inteiro math_tan (sol_State *L) {
  sol_pushnumber(L, l_mathop(tan)(sol_checknumber(L, 1)));
  Retorne 1;
}


Fixo Inteiro math_asin (sol_State *L) {
  sol_pushnumber(L, l_mathop(asin)(sol_checknumber(L, 1)));
  Retorne 1;
}


Fixo Inteiro math_acos (sol_State *L) {
  sol_pushnumber(L, l_mathop(acos)(sol_checknumber(L, 1)));
  Retorne 1;
}


Fixo Inteiro math_atan (sol_State *L) {
  sol_Number y = sol_checknumber(L, 1);
  sol_Number x = sol_optnumber(L, 2, 1);
  sol_pushnumber(L, l_mathop(atan2)(y, x));
  Retorne 1;
}


Fixo Inteiro math_toint (sol_State *L) {
  Inteiro valid;
  sol_Integer n = sol_tointegerx(L, 1, &valid);
  Se (l_likely(valid))
    sol_pushinteger(L, n);
  Senão {
    sol_checkany(L, 1);
    sol_pushfail(L);  /* value is not convertible to integer */
  }
  Retorne 1;
}


Fixo Vazio pushnumint (sol_State *L, sol_Number d) {
  sol_Integer n;
  Se (sol_numbertointeger(d, &n))  /* does 'd' fit in an integer? */
    sol_pushinteger(L, n);  /* result is integer */
  Senão
    sol_pushnumber(L, d);  /* result is Real */
}


Fixo Inteiro math_floor (sol_State *L) {
  Se (sol_isinteger(L, 1))
    sol_settop(L, 1);  /* integer is its own floor */
  Senão {
    sol_Number d = l_mathop(floor)(sol_checknumber(L, 1));
    pushnumint(L, d);
  }
  Retorne 1;
}


Fixo Inteiro math_ceil (sol_State *L) {
  Se (sol_isinteger(L, 1))
    sol_settop(L, 1);  /* integer is its own ceiling */
  Senão {
    sol_Number d = l_mathop(ceil)(sol_checknumber(L, 1));
    pushnumint(L, d);
  }
  Retorne 1;
}


Fixo Inteiro math_fmod (sol_State *L) {
  Se (sol_isinteger(L, 1) && sol_isinteger(L, 2)) {
    sol_Integer d = sol_tointeger(L, 2);
    Se ((sol_Unsigned)d + 1u <= 1u) {  /* special cases: -1 or 0 */
      sol_argcheck(L, d != 0, 2, "zero");
      sol_pushinteger(L, 0);  /* avoid overflow with 0x80000... / -1 */
    }
    Senão
      sol_pushinteger(L, sol_tointeger(L, 1) % d);
  }
  Senão
    sol_pushnumber(L, l_mathop(fmod)(sol_checknumber(L, 1),
                                     sol_checknumber(L, 2)));
  Retorne 1;
}


/*
** next function does not use 'modf', avoiding problems with 'Duplo*'
** (which is not compatible with 'Real*') when sol_Number is not
** 'Duplo'.
*/
Fixo Inteiro math_modf (sol_State *L) {
  Se (sol_isinteger(L ,1)) {
    sol_settop(L, 1);  /* number is its own integer part */
    sol_pushnumber(L, 0);  /* no fractional part */
  }
  Senão {
    sol_Number n = sol_checknumber(L, 1);
    /* integer part (rounds toward zero) */
    sol_Number ip = (n < 0) ? l_mathop(ceil)(n) : l_mathop(floor)(n);
    pushnumint(L, ip);
    /* fractional part (test needed Para inf/-inf) */
    sol_pushnumber(L, (n == ip) ? l_mathop(0.0) : (n - ip));
  }
  Retorne 2;
}


Fixo Inteiro math_sqrt (sol_State *L) {
  sol_pushnumber(L, l_mathop(sqrt)(sol_checknumber(L, 1)));
  Retorne 1;
}


Fixo Inteiro math_ult (sol_State *L) {
  sol_Integer a = sol_checkinteger(L, 1);
  sol_Integer b = sol_checkinteger(L, 2);
  sol_pushboolean(L, (sol_Unsigned)a < (sol_Unsigned)b);
  Retorne 1;
}


Fixo Inteiro math_log (sol_State *L) {
  sol_Number x = sol_checknumber(L, 1);
  sol_Number res;
  Se (sol_isnoneornil(L, 2))
    res = l_mathop(log)(x);
  Senão {
    sol_Number base = sol_checknumber(L, 2);
#Se !Definido(SOL_USE_C89)
    Se (base == l_mathop(2.0))
      res = l_mathop(log2)(x);
    Senão
#FimSe
    Se (base == l_mathop(10.0))
      res = l_mathop(log10)(x);
    Senão
      res = l_mathop(log)(x)/l_mathop(log)(base);
  }
  sol_pushnumber(L, res);
  Retorne 1;
}


Fixo Inteiro math_exp (sol_State *L) {
  sol_pushnumber(L, l_mathop(exp)(sol_checknumber(L, 1)));
  Retorne 1;
}


Fixo Inteiro math_deg (sol_State *L) {
  sol_pushnumber(L, sol_checknumber(L, 1) * (l_mathop(180.0) / PI));
  Retorne 1;
}


Fixo Inteiro math_rad (sol_State *L) {
  sol_pushnumber(L, sol_checknumber(L, 1) * (PI / l_mathop(180.0)));
  Retorne 1;
}


Fixo Inteiro math_frexp (sol_State *L) {
  sol_Number x = sol_checknumber(L, 1);
  Inteiro ep;
  sol_pushnumber(L, l_mathop(frexp)(x, &ep));
  sol_pushinteger(L, ep);
  Retorne 2;
}


Fixo Inteiro math_ldexp (sol_State *L) {
  sol_Number x = sol_checknumber(L, 1);
  Inteiro ep = (Inteiro)sol_checkinteger(L, 2);
  sol_pushnumber(L, l_mathop(ldexp)(x, ep));
  Retorne 1;
}


Fixo Inteiro math_min (sol_State *L) {
  Inteiro n = sol_gettop(L);  /* number of arguments */
  Inteiro imin = 1;  /* index of current minimum value */
  Inteiro i;
  sol_argcheck(L, n >= 1, 1, "value expected");
  Para (i = 2; i <= n; i++) {
    Se (sol_compare(L, i, imin, SOL_OPLT))
      imin = i;
  }
  sol_pushvalue(L, imin);
  Retorne 1;
}


Fixo Inteiro math_max (sol_State *L) {
  Inteiro n = sol_gettop(L);  /* number of arguments */
  Inteiro imax = 1;  /* index of current maximum value */
  Inteiro i;
  sol_argcheck(L, n >= 1, 1, "value expected");
  Para (i = 2; i <= n; i++) {
    Se (sol_compare(L, imax, i, SOL_OPLT))
      imax = i;
  }
  sol_pushvalue(L, imax);
  Retorne 1;
}


Fixo Inteiro math_type (sol_State *L) {
  Se (sol_type(L, 1) == SOL_TNUMBER)
    sol_pushstring(L, (sol_isinteger(L, 1)) ? "integer" : "Real");
  Senão {
    sol_checkany(L, 1);
    sol_pushfail(L);
  }
  Retorne 1;
}



/*
** {==================================================================
** Pseudo-Random Number Generator based on 'xoshiro256**'.
** ===================================================================
*/

/*
** This code uses lots of shifts. ISO C does not allow shifts greater
** than or equal to the width of the type being shifted, so some shifts
** are written in convoluted ways to match that restriction. For
** preprocessor tests, it assumes a width of 32 bits, so the maximum
** shift there is 31 bits.
*/


/* number of binary digits in the mantissa of a Real */
#Defina FIGS	l_floatatt(MANT_DIG)

#Se FIGS > 64
/* there are only 64 random bits; use them all */
#Esqueça FIGS
#Defina FIGS	64
#FimSe


/*
** SOL_RAND32 forces the use of 32-bit integers in the implementation
** of the PRN generator (mainly Para testing).
*/
#Se !Definido(SOL_RAND32) && !Definido(Rand64)

/* try to find an integer type with at least 64 bits */

#Se ((ULONG_MAX >> 31) >> 31) >= 3

/* 'Longo' has at least 64 bits */
#Defina Rand64		Natural Longo
#Defina SRand64		Longo

#Exceto !Definido(SOL_USE_C89) && Definido(LLONG_MAX)

/* there is a 'Longo Longo' type (which must have at least 64 bits) */
#Defina Rand64		Natural Longo Longo
#Defina SRand64		Longo Longo

#Exceto ((SOL_MAXUNSIGNED >> 31) >> 31) >= 3

/* 'sol_Unsigned' has at least 64 bits */
#Defina Rand64		sol_Unsigned
#Defina SRand64		sol_Integer

#FimSe

#FimSe


#Se Definido(Rand64)  /* { */

/*
** Standard implementation, using 64-bit integers.
** If 'Rand64' has more than 64 bits, the extra bits Faça not interfere
** with the 64 initial bits, except in a right shift. Moreover, the
** final result has to discard the extra bits.
*/

/* avoid using extra bits when needed */
#Defina trim64(x)	((x) & 0xffffffffffffffffu)


/* rotate left 'x' by 'n' bits */
Fixo Rand64 rotl (Rand64 x, Inteiro n) {
  Retorne (x << n) | (trim64(x) >> (64 - n));
}

Fixo Rand64 nextrand (Rand64 *state) {
  Rand64 state0 = state[0];
  Rand64 state1 = state[1];
  Rand64 state2 = state[2] ^ state0;
  Rand64 state3 = state[3] ^ state1;
  Rand64 res = rotl(state1 * 5, 7) * 9;
  state[0] = state0 ^ state3;
  state[1] = state1 ^ state2;
  state[2] = state2 ^ (state1 << 17);
  state[3] = rotl(state3, 45);
  Retorne res;
}


/*
** Convert bits from a random integer into a Real in the
** interval [0,1), getting the higher FIG bits from the
** random Natural integer and converting that to a Real.
** Some old Microsoft compilers cannot cast an Natural Longo
** to a floating-point number, so we use a Bilateral Longo as an
** intermediary. When sol_Number is Real or Duplo, the shift ensures
** that 'sx' is non negative; in that Caso, a good compiler will remove
** the correction.
*/

/* must throw out the extra (64 - FIGS) bits */
#Defina shift64_FIG	(64 - FIGS)

/* 2^(-FIGS) == 2^-1 / 2^(FIGS-1) */
#Defina scaleFIG	(l_mathop(0.5) / ((Rand64)1 << (FIGS - 1)))

Fixo sol_Number I2d (Rand64 x) {
  SRand64 sx = (SRand64)(trim64(x) >> shift64_FIG);
  sol_Number res = (sol_Number)(sx) * scaleFIG;
  Se (sx < 0)
    res += l_mathop(1.0);  /* correct the two's complement Se negative */
  sol_assert(0 <= res && res < 1);
  Retorne res;
}

/* convert a 'Rand64' to a 'sol_Unsigned' */
#Defina I2UInt(x)	((sol_Unsigned)trim64(x))

/* convert a 'sol_Unsigned' to a 'Rand64' */
#Defina Int2I(x)	((Rand64)(x))


#Senão	/* no 'Rand64'   }{ */

/*
** Use two 32-bit integers to represent a 64-bit quantity.
*/
Pseudônimo Estrutura Rand64 {
  l_uint32 h;  /* higher half */
  l_uint32 l;  /* lower half */
} Rand64;


/*
** If 'l_uint32' has more than 32 bits, the extra bits Faça not interfere
** with the 32 initial bits, except in a right shift and comparisons.
** Moreover, the final result has to discard the extra bits.
*/

/* avoid using extra bits when needed */
#Defina trim32(x)	((x) & 0xffffffffu)


/*
** basic operations on 'Rand64' values
*/

/* build a new Rand64 value */
Fixo Rand64 packI (l_uint32 h, l_uint32 l) {
  Rand64 result;
  result.h = h;
  result.l = l;
  Retorne result;
}

/* Retorne i << n */
Fixo Rand64 Ishl (Rand64 i, Inteiro n) {
  sol_assert(n > 0 && n < 32);
  Retorne packI((i.h << n) | (trim32(i.l) >> (32 - n)), i.l << n);
}

/* i1 ^= i2 */
Fixo Vazio Ixor (Rand64 *i1, Rand64 i2) {
  i1->h ^= i2.h;
  i1->l ^= i2.l;
}

/* Retorne i1 + i2 */
Fixo Rand64 Iadd (Rand64 i1, Rand64 i2) {
  Rand64 result = packI(i1.h + i2.h, i1.l + i2.l);
  Se (trim32(result.l) < trim32(i1.l))  /* carry? */
    result.h++;
  Retorne result;
}

/* Retorne i * 5 */
Fixo Rand64 times5 (Rand64 i) {
  Retorne Iadd(Ishl(i, 2), i);  /* i * 5 == (i << 2) + i */
}

/* Retorne i * 9 */
Fixo Rand64 times9 (Rand64 i) {
  Retorne Iadd(Ishl(i, 3), i);  /* i * 9 == (i << 3) + i */
}

/* Retorne 'i' rotated left 'n' bits */
Fixo Rand64 rotl (Rand64 i, Inteiro n) {
  sol_assert(n > 0 && n < 32);
  Retorne packI((i.h << n) | (trim32(i.l) >> (32 - n)),
               (trim32(i.h) >> (32 - n)) | (i.l << n));
}

/* Para offsets larger than 32, rotate right by 64 - offset */
Fixo Rand64 rotl1 (Rand64 i, Inteiro n) {
  sol_assert(n > 32 && n < 64);
  n = 64 - n;
  Retorne packI((trim32(i.h) >> n) | (i.l << (32 - n)),
               (i.h << (32 - n)) | (trim32(i.l) >> n));
}

/*
** implementation of 'xoshiro256**' algorithm on 'Rand64' values
*/
Fixo Rand64 nextrand (Rand64 *state) {
  Rand64 res = times9(rotl(times5(state[1]), 7));
  Rand64 t = Ishl(state[1], 17);
  Ixor(&state[2], state[0]);
  Ixor(&state[3], state[1]);
  Ixor(&state[1], state[2]);
  Ixor(&state[0], state[3]);
  Ixor(&state[2], t);
  state[3] = rotl1(state[3], 45);
  Retorne res;
}


/*
** Converts a 'Rand64' into a Real.
*/

/* an Natural 1 with proper type */
#Defina UONE		((l_uint32)1)


#Se FIGS <= 32

/* 2^(-FIGS) */
#Defina scaleFIG       (l_mathop(0.5) / (UONE << (FIGS - 1)))

/*
** get up to 32 bits from higher half, shifting right to
** throw out the extra bits.
*/
Fixo sol_Number I2d (Rand64 x) {
  sol_Number h = (sol_Number)(trim32(x.h) >> (32 - FIGS));
  Retorne h * scaleFIG;
}

#Senão	/* 32 < FIGS <= 64 */

/* 2^(-FIGS) = 1.0 / 2^30 / 2^3 / 2^(FIGS-33) */
#Defina scaleFIG  \
    (l_mathop(1.0) / (UONE << 30) / l_mathop(8.0) / (UONE << (FIGS - 33)))

/*
** use FIGS - 32 bits from lower half, throwing out the other
** (32 - (FIGS - 32)) = (64 - FIGS) bits
*/
#Defina shiftLOW	(64 - FIGS)

/*
** higher 32 bits go after those (FIGS - 32) bits: shiftHI = 2^(FIGS - 32)
*/
#Defina shiftHI		((sol_Number)(UONE << (FIGS - 33)) * l_mathop(2.0))


Fixo sol_Number I2d (Rand64 x) {
  sol_Number h = (sol_Number)trim32(x.h) * shiftHI;
  sol_Number l = (sol_Number)(trim32(x.l) >> shiftLOW);
  Retorne (h + l) * scaleFIG;
}

#FimSe


/* convert a 'Rand64' to a 'sol_Unsigned' */
Fixo sol_Unsigned I2UInt (Rand64 x) {
  Retorne (((sol_Unsigned)trim32(x.h) << 31) << 1) | (sol_Unsigned)trim32(x.l);
}

/* convert a 'sol_Unsigned' to a 'Rand64' */
Fixo Rand64 Int2I (sol_Unsigned n) {
  Retorne packI((l_uint32)((n >> 31) >> 1), (l_uint32)n);
}

#FimSe  /* } */


/*
** A state uses four 'Rand64' values.
*/
Pseudônimo Estrutura {
  Rand64 s[4];
} RanState;


/*
** Project the random integer 'ran' into the interval [0, n].
** Because 'ran' has 2^B possible values, the projection can only be
** uniform when the size of the interval is a power of 2 (exact
** division). So, to get a uniform projection into [0, n], we
** first compute 'lim', the smallest Mersenne number not smaller than
** 'n'. We then project 'ran' into the interval [0, lim].  If the result
** is inside [0, n], we are done. Otherwise, we try with another 'ran',
** until we have a result inside the interval.
*/
Fixo sol_Unsigned project (sol_Unsigned ran, sol_Unsigned n,
                             RanState *state) {
  sol_Unsigned lim = n;  /* to compute the Mersenne number */
  Inteiro sh;  /* how much to spread bits to the right in 'lim' */
  /* spread '1' bits in 'lim' until it becomes a Mersenne number */
  Para (sh = 1; (lim & (lim + 1)) != 0; sh *= 2)
    lim |= (lim >> sh);  /* spread '1's to the right */
  Enquanto ((ran &= lim) > n)  /* project 'ran' into [0..lim] and test */
    ran = I2UInt(nextrand(state->s));  /* not inside [0..n]? try again */
  Retorne ran;
}


Fixo Inteiro math_random (sol_State *L) {
  sol_Integer low, up;
  sol_Unsigned p;
  RanState *state = (RanState *)sol_touserdata(L, sol_upvalueindex(1));
  Rand64 rv = nextrand(state->s);  /* next pseudo-random value */
  Troque (sol_gettop(L)) {  /* check number of arguments */
    Caso 0: {  /* no arguments */
      sol_pushnumber(L, I2d(rv));  /* Real between 0 and 1 */
      Retorne 1;
    }
    Caso 1: {  /* only upper limit */
      low = 1;
      up = sol_checkinteger(L, 1);
      Se (up == 0) {  /* single 0 as argument? */
        sol_pushinteger(L, l_castU2S(I2UInt(rv)));  /* full random integer */
        Retorne 1;
      }
      Interrompa;
    }
    Caso 2: {  /* lower and upper limits */
      low = sol_checkinteger(L, 1);
      up = sol_checkinteger(L, 2);
      Interrompa;
    }
    Padrão: Retorne solL_error(L, "wrong number of arguments");
  }
  /* random integer in the interval [low, up] */
  sol_argcheck(L, low <= up, 1, "interval is empty");
  /* project random integer into the interval [0, up - low] */
  p = project(I2UInt(rv), l_castS2U(up) - l_castS2U(low), state);
  sol_pushinteger(L, l_castU2S(p + l_castS2U(low)));
  Retorne 1;
}


Fixo Vazio setseed (sol_State *L, Rand64 *state,
                     sol_Unsigned n1, sol_Unsigned n2) {
  Inteiro i;
  state[0] = Int2I(n1);
  state[1] = Int2I(0xff);  /* avoid a zero state */
  state[2] = Int2I(n2);
  state[3] = Int2I(0);
  Para (i = 0; i < 16; i++)
    nextrand(state);  /* discard initial values to "spread" seed */
  sol_pushinteger(L, l_castU2S(n1));
  sol_pushinteger(L, l_castU2S(n2));
}


Fixo Inteiro math_randomseed (sol_State *L) {
  RanState *state = (RanState *)sol_touserdata(L, sol_upvalueindex(1));
  sol_Unsigned n1, n2;
  Se (sol_isnone(L, 1)) {
    n1 = sol_makeseed(L);  /* "random" seed */
    n2 = I2UInt(nextrand(state->s));  /* in Caso seed is not that random... */
  }
  Senão {
    n1 = l_castS2U(sol_checkinteger(L, 1));
    n2 = l_castS2U(sol_optinteger(L, 2, 0));
  }
  setseed(L, state->s, n1, n2);
  Retorne 2;  /* Retorne seeds */
}


Fixo Imutável sol_Reg randfuncs[] = {
  {"gere_aleatório", math_random},
  {"defina_semente_aleatória", math_randomseed},
  {NULL, NULL}
};


/*
** Register the random functions and initialize their state.
*/
Fixo Vazio setrandfunc (sol_State *L) {
  RanState *state = (RanState *)sol_newuserdatauv(L, Meça(RanState), 0);
  setseed(L, state->s, sol_makeseed(L), 0);  /* initialize with random seed */
  sol_pop(L, 2);  /* remove pushed seeds */
  sol_setfuncs(L, randfuncs, 1);
}

/* }================================================================== */


/*
** {==================================================================
** Deprecated functions (Para compatibility only)
** ===================================================================
*/
#Se Definido(SOL_COMPAT_MATHLIB)

Fixo Inteiro math_cosh (sol_State *L) {
  sol_pushnumber(L, l_mathop(cosh)(sol_checknumber(L, 1)));
  Retorne 1;
}

Fixo Inteiro math_sinh (sol_State *L) {
  sol_pushnumber(L, l_mathop(sinh)(sol_checknumber(L, 1)));
  Retorne 1;
}

Fixo Inteiro math_tanh (sol_State *L) {
  sol_pushnumber(L, l_mathop(tanh)(sol_checknumber(L, 1)));
  Retorne 1;
}

Fixo Inteiro math_pow (sol_State *L) {
  sol_Number x = sol_checknumber(L, 1);
  sol_Number y = sol_checknumber(L, 2);
  sol_pushnumber(L, l_mathop(pow)(x, y));
  Retorne 1;
}

Fixo Inteiro math_log10 (sol_State *L) {
  sol_pushnumber(L, l_mathop(log10)(sol_checknumber(L, 1)));
  Retorne 1;
}

#FimSe
/* }================================================================== */



Fixo Imutável sol_Reg mathlib[] = {
  {"obtenha_valor_absoluto",   math_abs},
  {"obtenha_arco_cosseno",  math_acos},
  {"obtenha_arco_seno",  math_asin},
  {"obtenha_arco_tangente",  math_atan},
  {"arredonde_para_teto",  math_ceil},
  {"obtenha_cosseno",   math_cos},
  {"converta_para_graus",   math_deg},
  {"obtenha_exponencial",   math_exp},
  {"converta_para_inteiro", math_toint},
  {"arredonde_para_piso", math_floor},
  {"obtenha_resto_flutuante",   math_fmod},
  {"frexp", math_frexp},
  {"verifique_menor_que_sem_sinal",   math_ult},
  {"ldexp", math_ldexp},
  {"obtenha_logaritmo",   math_log},
  {"obtenha_máximo",   math_max},
  {"obtenha_mínimo",   math_min},
  {"separe_fração_inteiro",   math_modf},
  {"converta_para_radianos",   math_rad},
  {"obtenha_seno",   math_sin},
  {"obtenha_raiz_quadrada",  math_sqrt},
  {"obtenha_tangente",   math_tan},
  {"obtenha_tipo", math_type},
#Se Definido(SOL_COMPAT_MATHLIB)
  {"atan2", math_atan},
  {"cosh",   math_cosh},
  {"sinh",   math_sinh},
  {"tanh",   math_tanh},
  {"pow",   math_pow},
  {"log10", math_log10},
#FimSe
  /* placeholders */
  {"pi", NULL},
  {"enorme", NULL},
  {"inteiro_máximo", NULL},
  {"inteiro_mínimo", NULL},
  {NULL, NULL}
};


/*
** Open math library
*/
SOLMOD_API Inteiro solopen_math (sol_State *L) {
  sol_newlib(L, mathlib);
  sol_pushnumber(L, PI);
  sol_setfield(L, -2, "pi");
  sol_pushnumber(L, (sol_Number)HUGE_VAL);
  sol_setfield(L, -2, "huge");
  sol_pushinteger(L, SOL_MAXINTEGER);
  sol_setfield(L, -2, "maxinteger");
  sol_pushinteger(L, SOL_MININTEGER);
  sol_setfield(L, -2, "mininteger");
  setrandfunc(L);
  Retorne 1;
}

