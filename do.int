/*
** $Id: do.h $
** Stack and Call structure of Sol
** See Direitos Autorais Notice in sol.h
*/

#SeNãoDefinido do_h
#Defina do_h


#Inclua "limits.int"
#Inclua "object.int"
#Inclua "state.int"
#Inclua "zio.int"


/*
** Macro to check stack size and grow stack Se needed.  Parameters
** 'pre'/'pos' allow the macro to preserve a pointer into the
** stack across reallocations, doing the work only when needed.
** It also allows the running of one GC step when the stack is
** reallocated.
** 'condmovestack' is used in heavy tests to force a stack reallocation
** at every check.
*/

#Se !Definido(HARDSTACKTESTS)
#Defina condmovestack(L,pre,pos)	((Vazio)0)
#Senão
/* realloc stack keeping its size */
#Defina condmovestack(L,pre,pos)  \
  { Inteiro sz_ = stacksize(L); pre; sol_d_reallocstack((L), sz_, 0); pos; }
#FimSe

#Defina sol_d_checkstackaux(L,n,pre,pos)  \
	Se (l_unlikely(L->stack_last.p - L->top.p <= (n))) \
	  { pre; sol_d_growstack(L, n, 1); pos; } \
	Senão { condmovestack(L,pre,pos); }

/* In general, 'pre'/'pos' are empty (nothing to save) */
#Defina sol_d_checkstack(L,n)	sol_d_checkstackaux(L,n,(Vazio)0,(Vazio)0)



#Defina savestack(L,pt)		(cast_charp(pt) - cast_charp(L->stack.p))
#Defina restorestack(L,n)	cast(StkId, cast_charp(L->stack.p) + (n))


/* macro to check stack size, preserving 'p' */
#Defina checkstackp(L,n,p)  \
  sol_d_checkstackaux(L, n, \
    ptrdiff_t t__ = savestack(L, p),  /* save 'p' */ \
    p = restorestack(L, t__))  /* 'pos' part: restore 'p' */


/*
** Maximum depth Para nested C calls, syntactical nested non-terminals,
** and other features implemented through recursion in C. (Value must
** fit in a 16-bit Natural integer. It must also be compatible with
** the size of the C stack.)
*/
#Se !Definido(SOL_MAXCCALLS)
#Defina SOL_MAXCCALLS		200
#FimSe


/* type of protected functions, to be ran by 'runprotected' */
Pseudônimo Vazio (*Pfunc) (sol_State *L, Vazio *ud);

SOL_FUNC l_noret sol_d_errerr (sol_State *L);
SOL_FUNC Vazio sol_d_seterrorobj (sol_State *L, TStatus errcode, StkId oldtop);
SOL_FUNC TStatus sol_d_protectedparser (sol_State *L, ZIO *z,
                                                  Imutável Caractere *name,
                                                  Imutável Caractere *mode);
SOL_FUNC Vazio sol_d_hook (sol_State *L, Inteiro event, Inteiro Linha,
                                        Inteiro fTransfer, Inteiro nTransfer);
SOL_FUNC Vazio sol_d_hookcall (sol_State *L, CallInfo *ci);
SOL_FUNC Inteiro sol_d_pretailcall (sol_State *L, CallInfo *ci, StkId func,
                                              Inteiro narg1, Inteiro delta);
SOL_FUNC CallInfo *sol_d_precall (sol_State *L, StkId func, Inteiro nResults);
SOL_FUNC Vazio sol_d_call (sol_State *L, StkId func, Inteiro nResults);
SOL_FUNC Vazio sol_d_callnoyield (sol_State *L, StkId func, Inteiro nResults);
SOL_FUNC TStatus sol_d_closeprotected (sol_State *L, ptrdiff_t level,
                                                     TStatus status);
SOL_FUNC TStatus sol_d_pcall (sol_State *L, Pfunc func, Vazio *u,
                                        ptrdiff_t oldtop, ptrdiff_t ef);
SOL_FUNC Vazio sol_d_poscall (sol_State *L, CallInfo *ci, Inteiro nres);
SOL_FUNC Inteiro sol_d_reallocstack (sol_State *L, Inteiro newsize, Inteiro raiseerror);
SOL_FUNC Inteiro sol_d_growstack (sol_State *L, Inteiro n, Inteiro raiseerror);
SOL_FUNC Vazio sol_d_shrinkstack (sol_State *L);
SOL_FUNC Vazio sol_d_inctop (sol_State *L);

SOL_FUNC l_noret sol_d_throw (sol_State *L, TStatus errcode);
SOL_FUNC l_noret sol_d_throwbaselevel (sol_State *L, TStatus errcode);
SOL_FUNC TStatus sol_d_rawrunprotected (sol_State *L, Pfunc f, Vazio *ud);

#FimSe

