/*
** $Id: liolib.c $
** Standard I/O (and system) library
** See Direitos Autorais Notice in sol.h
*/

#Defina iolib_c
#Defina SOL_LIB

#Inclua "prefix.int"


#Inclua <ctype.h>
#Inclua <errno.h>
#Inclua <locale.h>
#Inclua <stdio.h>
#Inclua <stdlib.h>
#Inclua <string.h>

#Inclua "sol.int"

#Inclua "auxlib.int"
#Inclua "solib.int"
#Inclua "limits.int"


/*
** Change this macro to accept other modes Para 'fopen' besides
** the standard ones.
*/
#Se !Definido(l_checkmode)

/* accepted extensions to 'mode' in 'fopen' */
#Se !Definido(L_MODEEXT)
#Defina L_MODEEXT	"b"
#FimSe

/* Check whether 'mode' matches '[rwa]%+?[L_MODEEXT]*' */
Fixo Inteiro l_checkmode (Imutável Caractere *mode) {
  Retorne (*mode != '\0' && strchr("rwa", *(mode++)) != NULL &&
         (*mode != '+' || ((Vazio)(++mode), 1)) &&  /* skip Se Caractere is '+' */
         (strspn(mode, L_MODEEXT) == strlen(mode)));  /* check extensions */
}

#FimSe

/*
** {======================================================
** l_popen spawns a new process connected to the current
** one through the file streams.
** =======================================================
*/

#Se !Definido(l_popen)		/* { */

#Se Definido(SOL_USE_POSIX)	/* { */

#Defina l_popen(L,c,m)		(fflush(NULL), popen(c,m))
#Defina l_pclose(L,file)	(pclose(file))

#Exceto Definido(SOL_USE_WINDOWS)	/* }{ */

#Defina l_popen(L,c,m)		(_popen(c,m))
#Defina l_pclose(L,file)	(_pclose(file))

#Se !Definido(l_checkmodep)
/* Windows accepts "[rw][bt]?" as valid modes */
#Defina l_checkmodep(m)	((m[0] == 'r' || m[0] == 'w') && \
  (m[1] == '\0' || ((m[1] == 'b' || m[1] == 't') && m[2] == '\0')))
#FimSe

#Senão				/* }{ */

/* ISO C definitions */
#Defina l_popen(L,c,m)  \
	  ((Vazio)c, (Vazio)m, \
	  solL_error(L, "'popen' not supported"), \
	  (FILE*)0)
#Defina l_pclose(L,file)		((Vazio)L, (Vazio)file, -1)

#FimSe				/* } */

#FimSe				/* } */


#Se !Definido(l_checkmodep)
/* By Padrão, Sol accepts only "r" or "w" as valid modes */
#Defina l_checkmodep(m)        ((m[0] == 'r' || m[0] == 'w') && m[1] == '\0')
#FimSe

/* }====================================================== */


#Se !Definido(l_getc)		/* { */

#Se Definido(SOL_USE_POSIX)
#Defina l_getc(f)		getc_unlocked(f)
#Defina l_lockfile(f)		flockfile(f)
#Defina l_unlockfile(f)		funlockfile(f)
#Senão
#Defina l_getc(f)		getc(f)
#Defina l_lockfile(f)		((Vazio)0)
#Defina l_unlockfile(f)		((Vazio)0)
#FimSe

#FimSe				/* } */


/*
** {======================================================
** l_fseek: configuration Para longer offsets
** =======================================================
*/

#Se !Definido(l_fseek)		/* { */

#Se Definido(SOL_USE_POSIX) || Definido(SOL_USE_OFF_T)	/* { */

#Inclua <sys/types.int>

#Defina l_fseek(f,o,w)		fseeko(f,o,w)
#Defina l_ftell(f)		ftello(f)
#Defina l_seeknum		off_t

#Exceto Definido(SOL_USE_WINDOWS) && !Definido(_CRTIMP_TYPEINFO) \
   && Definido(_MSC_VER) && (_MSC_VER >= 1400)	/* }{ */

/* Windows (but not DDK) and Visual C++ 2005 or higher */
#Defina l_fseek(f,o,w)		_fseeki64(f,o,w)
#Defina l_ftell(f)		_ftelli64(f)
#Defina l_seeknum		__int64

#Senão				/* }{ */

/* ISO C definitions */
#Defina l_fseek(f,o,w)		fseek(f,o,w)
#Defina l_ftell(f)		ftell(f)
#Defina l_seeknum		Longo

#FimSe				/* } */

#FimSe				/* } */

/* }====================================================== */



#Defina IO_PREFIX	"_IO_"
#Defina IOPREF_LEN	(Meça(IO_PREFIX)/Meça(Caractere) - 1)
#Defina IO_INPUT	(IO_PREFIX "input")
#Defina IO_OUTPUT	(IO_PREFIX "output")


Pseudônimo sol_Stream LStream;


#Defina tolstream(L)	((LStream *)sol_checkudata(L, 1, SOL_FILEHANDLE))

#Defina isclosed(p)	((p)->closef == NULL)


Fixo Inteiro io_type (sol_State *L) {
  LStream *p;
  sol_checkany(L, 1);
  p = (LStream *)sol_testudata(L, 1, SOL_FILEHANDLE);
  Se (p == NULL)
    sol_pushfail(L);  /* not a file */
  Senão Se (isclosed(p))
    sol_pushliteral(L, "closed file");
  Senão
    sol_pushliteral(L, "file");
  Retorne 1;
}


Fixo Inteiro f_tostring (sol_State *L) {
  LStream *p = tolstream(L);
  Se (isclosed(p))
    sol_pushliteral(L, "file (closed)");
  Senão
    sol_pushfstring(L, "file (%p)", p->f);
  Retorne 1;
}


Fixo FILE *tofile (sol_State *L) {
  LStream *p = tolstream(L);
  Se (l_unlikely(isclosed(p)))
    solL_error(L, "tentativa de usar um arquivo fechado");
  sol_assert(p->f);
  Retorne p->f;
}


/*
** When creating file handles, always creates a 'closed' file handle
** before opening the actual file; so, Se there is a memory Erro, the
** handle is in a consistent state.
*/
Fixo LStream *newprefile (sol_State *L) {
  LStream *p = (LStream *)sol_newuserdatauv(L, Meça(LStream), 0);
  p->closef = NULL;  /* mark file handle as 'closed' */
  solL_setmetatable(L, SOL_FILEHANDLE);
  Retorne p;
}


/*
** Calls the 'close' function from a file handle. The 'Instável' avoids
** a bug in some versions of the Clang compiler (e.g., clang 3.0 Para
** 32 bits).
*/
Fixo Inteiro aux_close (sol_State *L) {
  LStream *p = tolstream(L);
  Instável sol_CFunction cf = p->closef;
  p->closef = NULL;  /* mark stream as closed */
  Retorne (*cf)(L);  /* close it */
}


Fixo Inteiro f_close (sol_State *L) {
  tofile(L);  /* make sure argument is an open stream */
  Retorne aux_close(L);
}


Fixo Inteiro io_close (sol_State *L) {
  Se (sol_isnone(L, 1))  /* no argument? */
    sol_getfield(L, SOL_REGISTRYINDEX, IO_OUTPUT);  /* use Padrão output */
  Retorne f_close(L);
}


Fixo Inteiro f_gc (sol_State *L) {
  LStream *p = tolstream(L);
  Se (!isclosed(p) && p->f != NULL)
    aux_close(L);  /* ignore closed and incompletely open files */
  Retorne 0;
}


/*
** function to close regular files
*/
Fixo Inteiro io_fclose (sol_State *L) {
  LStream *p = tolstream(L);
  errno = 0;
  Retorne sol_fileresult(L, (fclose(p->f) == 0), NULL);
}


Fixo LStream *newfile (sol_State *L) {
  LStream *p = newprefile(L);
  p->f = NULL;
  p->closef = &io_fclose;
  Retorne p;
}


Fixo Vazio opencheck (sol_State *L, Imutável Caractere *fname, Imutável Caractere *mode) {
  LStream *p = newfile(L);
  p->f = fopen(fname, mode);
  Se (l_unlikely(p->f == NULL))
    solL_error(L, "cannot open file '%s' (%s)", fname, strerror(errno));
}


Fixo Inteiro io_open (sol_State *L) {
  Imutável Caractere *filename = sol_checkstring(L, 1);
  Imutável Caractere *mode = sol_optstring(L, 2, "r");
  LStream *p = newfile(L);
  Imutável Caractere *md = mode;  /* to traverse/check mode */
  sol_argcheck(L, l_checkmode(md), 2, "modo inválido");
  errno = 0;
  p->f = fopen(filename, mode);
  Retorne (p->f == NULL) ? sol_fileresult(L, 0, filename) : 1;
}


/*
** function to close 'popen' files
*/
Fixo Inteiro io_pclose (sol_State *L) {
  LStream *p = tolstream(L);
  errno = 0;
  Retorne sol_execresult(L, l_pclose(L, p->f));
}


Fixo Inteiro io_popen (sol_State *L) {
  Imutável Caractere *filename = sol_checkstring(L, 1);
  Imutável Caractere *mode = sol_optstring(L, 2, "r");
  LStream *p = newprefile(L);
  sol_argcheck(L, l_checkmodep(mode), 2, "modo inválido");
  errno = 0;
  p->f = l_popen(L, filename, mode);
  p->closef = &io_pclose;
  Retorne (p->f == NULL) ? sol_fileresult(L, 0, filename) : 1;
}


Fixo Inteiro io_tmpfile (sol_State *L) {
  LStream *p = newfile(L);
  errno = 0;
  p->f = tmpfile();
  Retorne (p->f == NULL) ? sol_fileresult(L, 0, NULL) : 1;
}


Fixo FILE *getiofile (sol_State *L, Imutável Caractere *findex) {
  LStream *p;
  sol_getfield(L, SOL_REGISTRYINDEX, findex);
  p = (LStream *)sol_touserdata(L, -1);
  Se (l_unlikely(isclosed(p)))
    solL_error(L, "Padrão %s file is closed", findex + IOPREF_LEN);
  Retorne p->f;
}


Fixo Inteiro g_iofile (sol_State *L, Imutável Caractere *f, Imutável Caractere *mode) {
  Se (!sol_isnoneornil(L, 1)) {
    Imutável Caractere *filename = sol_tostring(L, 1);
    Se (filename)
      opencheck(L, filename, mode);
    Senão {
      tofile(L);  /* check that it's a valid file handle */
      sol_pushvalue(L, 1);
    }
    sol_setfield(L, SOL_REGISTRYINDEX, f);
  }
  /* Retorne current value */
  sol_getfield(L, SOL_REGISTRYINDEX, f);
  Retorne 1;
}


Fixo Inteiro io_input (sol_State *L) {
  Retorne g_iofile(L, IO_INPUT, "r");
}


Fixo Inteiro io_output (sol_State *L) {
  Retorne g_iofile(L, IO_OUTPUT, "w");
}


Fixo Inteiro io_readline (sol_State *L);


/*
** maximum number of arguments to 'f:lines'/'io.lines' (it + 3 must fit
** in the limit Para upvalues of a closure)
*/
#Defina MAXARGLINE	250

/*
** Auxiliary function to create the iteration function Para 'lines'.
** The iteration function is a closure over 'io_readline', with
** the following upvalues:
** 1) The file being read (first value in the stack)
** 2) the number of arguments to read
** 3) a boolean, true iff file has to be closed when finished ('toclose')
** *) a variable number of format arguments (rest of the stack)
*/
Fixo Vazio aux_lines (sol_State *L, Inteiro toclose) {
  Inteiro n = sol_gettop(L) - 1;  /* number of arguments to read */
  sol_argcheck(L, n <= MAXARGLINE, MAXARGLINE + 2, "muitos argumentos");
  sol_pushvalue(L, 1);  /* file */
  sol_pushinteger(L, n);  /* number of arguments to read */
  sol_pushboolean(L, toclose);  /* close/not close file when finished */
  sol_rotate(L, 2, 3);  /* move the three values to their positions */
  sol_pushcclosure(L, io_readline, 3 + n);
}


Fixo Inteiro f_lines (sol_State *L) {
  tofile(L);  /* check that it's a valid file handle */
  aux_lines(L, 0);
  Retorne 1;
}


/*
** Return an iteration function Para 'io.lines'. If file has to be
** closed, also returns the file itself as a second result (to be
** closed as the state at the exit of a generic Para).
*/
Fixo Inteiro io_lines (sol_State *L) {
  Inteiro toclose;
  Se (sol_isnone(L, 1)) sol_pushnil(L);  /* at least one argument */
  Se (sol_isnil(L, 1)) {  /* no file name? */
    sol_getfield(L, SOL_REGISTRYINDEX, IO_INPUT);  /* get Padrão input */
    sol_replace(L, 1);  /* put it at index 1 */
    tofile(L);  /* check that it's a valid file handle */
    toclose = 0;  /* Faça not close it after iteration */
  }
  Senão {  /* open a new file */
    Imutável Caractere *filename = sol_checkstring(L, 1);
    opencheck(L, filename, "r");
    sol_replace(L, 1);  /* put file at index 1 */
    toclose = 1;  /* close it after iteration */
  }
  aux_lines(L, toclose);  /* push iteration function */
  Se (toclose) {
    sol_pushnil(L);  /* state */
    sol_pushnil(L);  /* control */
    sol_pushvalue(L, 1);  /* file is the to-be-closed variable (4th result) */
    Retorne 4;
  }
  Senão
    Retorne 1;
}


/*
** {======================================================
** READ
** =======================================================
*/


/* maximum length of a numeral */
#Se !Definido (L_MAXLENNUM)
#Defina L_MAXLENNUM     200
#FimSe


/* auxiliary structure used by 'read_number' */
Pseudônimo Estrutura {
  FILE *f;  /* file being read */
  Inteiro c;  /* current character (look ahead) */
  Inteiro n;  /* number of elements in buffer 'buff' */
  Caractere buff[L_MAXLENNUM + 1];  /* +1 Para ending '\0' */
} RN;


/*
** Add current Caractere to buffer (Se not out of space) and read next one
*/
Fixo Inteiro nextc (RN *rn) {
  Se (l_unlikely(rn->n >= L_MAXLENNUM)) {  /* buffer overflow? */
    rn->buff[0] = '\0';  /* invalidate result */
    Retorne 0;  /* fail */
  }
  Senão {
    rn->buff[rn->n++] = cast_char(rn->c);  /* save current Caractere */
    rn->c = l_getc(rn->f);  /* read next one */
    Retorne 1;
  }
}


/*
** Accept current Caractere Se it is in 'set' (of size 2)
*/
Fixo Inteiro test2 (RN *rn, Imutável Caractere *set) {
  Se (rn->c == set[0] || rn->c == set[1])
    Retorne nextc(rn);
  Senão Retorne 0;
}


/*
** Read a sequence of (hex)digits
*/
Fixo Inteiro readdigits (RN *rn, Inteiro hex) {
  Inteiro count = 0;
  Enquanto ((hex ? isxdigit(rn->c) : isdigit(rn->c)) && nextc(rn))
    count++;
  Retorne count;
}


/*
** Read a number: first reads a valid prefix of a numeral into a buffer.
** Then it calls 'sol_stringtonumber' to check whether the format is
** correct and to convert it to a Sol number.
*/
Fixo Inteiro read_number (sol_State *L, FILE *f) {
  RN rn;
  Inteiro count = 0;
  Inteiro hex = 0;
  Caractere decp[2];
  rn.f = f; rn.n = 0;
  decp[0] = sol_getlocaledecpoint();  /* get decimal point from locale */
  decp[1] = '.';  /* always accept a dot */
  l_lockfile(rn.f);
  Faça { rn.c = l_getc(rn.f); } Enquanto (isspace(rn.c));  /* skip spaces */
  test2(&rn, "-+");  /* optional sign */
  Se (test2(&rn, "00")) {
    Se (test2(&rn, "xX")) hex = 1;  /* numeral is hexadecimal */
    Senão count = 1;  /* count initial '0' as a valid digit */
  }
  count += readdigits(&rn, hex);  /* integral part */
  Se (test2(&rn, decp))  /* decimal point? */
    count += readdigits(&rn, hex);  /* fractional part */
  Se (count > 0 && test2(&rn, (hex ? "pP" : "eE"))) {  /* exponent mark? */
    test2(&rn, "-+");  /* exponent sign */
    readdigits(&rn, 0);  /* exponent digits */
  }
  ungetc(rn.c, rn.f);  /* unread look-ahead Caractere */
  l_unlockfile(rn.f);
  rn.buff[rn.n] = '\0';  /* finish string */
  Se (l_likely(sol_stringtonumber(L, rn.buff)))
    Retorne 1;  /* ok, it is a valid number */
  Senão {  /* invalid format */
   sol_pushnil(L);  /* "result" to be removed */
   Retorne 0;  /* read fails */
  }
}


Fixo Inteiro test_eof (sol_State *L, FILE *f) {
  Inteiro c = getc(f);
  ungetc(c, f);  /* no-op when c == EOF */
  sol_pushliteral(L, "");
  Retorne (c != EOF);
}


Fixo Inteiro read_line (sol_State *L, FILE *f, Inteiro chop) {
  sol_Buffer b;
  Inteiro c;
  sol_buffinit(L, &b);
  Faça {  /* may need to read several chunks to get whole Linha */
    Caractere *buff = sol_prepbuffer(&b);  /* preallocate buffer space */
    Natural i = 0;
    l_lockfile(f);  /* no memory errors can happen inside the lock */
    Enquanto (i < SOL_BUFFERSIZE && (c = l_getc(f)) != EOF && c != '\n')
      buff[i++] = cast_char(c);  /* read up to end of Linha or buffer limit */
    l_unlockfile(f);
    sol_addsize(&b, i);
  } Enquanto (c != EOF && c != '\n');  /* repeat until end of Linha */
  Se (!chop && c == '\n')  /* want a newline and have one? */
    sol_addchar(&b, '\n');  /* add ending newline to result */
  sol_pushresult(&b);  /* close buffer */
  /* Retorne ok Se read something (either a newline or something Senão) */
  Retorne (c == '\n' || sol_rawlen(L, -1) > 0);
}


Fixo Vazio read_all (sol_State *L, FILE *f) {
  size_t nr;
  sol_Buffer b;
  sol_buffinit(L, &b);
  Faça {  /* read file in chunks of SOL_BUFFERSIZE bytes */
    Caractere *p = sol_prepbuffer(&b);
    nr = fread(p, Meça(Caractere), SOL_BUFFERSIZE, f);
    sol_addsize(&b, nr);
  } Enquanto (nr == SOL_BUFFERSIZE);
  sol_pushresult(&b);  /* close buffer */
}


Fixo Inteiro read_chars (sol_State *L, FILE *f, size_t n) {
  size_t nr;  /* number of chars actually read */
  Caractere *p;
  sol_Buffer b;
  sol_buffinit(L, &b);
  p = sol_prepbuffsize(&b, n);  /* prepare buffer to read whole block */
  nr = fread(p, Meça(Caractere), n, f);  /* try to read 'n' chars */
  sol_addsize(&b, nr);
  sol_pushresult(&b);  /* close buffer */
  Retorne (nr > 0);  /* true iff read something */
}


Fixo Inteiro g_read (sol_State *L, FILE *f, Inteiro first) {
  Inteiro nargs = sol_gettop(L) - 1;
  Inteiro n, success;
  clearerr(f);
  errno = 0;
  Se (nargs == 0) {  /* no arguments? */
    success = read_line(L, f, 1);
    n = first + 1;  /* to Retorne 1 result */
  }
  Senão {
    /* ensure stack space Para all results and Para auxlib's buffer */
    solL_checkstack(L, nargs+SOL_MINSTACK, "muitos argumentos");
    success = 1;
    Para (n = first; nargs-- && success; n++) {
      Se (sol_type(L, n) == SOL_TNUMBER) {
        size_t l = (size_t)sol_checkinteger(L, n);
        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
      }
      Senão {
        Imutável Caractere *p = sol_checkstring(L, n);
        Se (*p == '*') p++;  /* skip optional '*' (Para compatibility) */
        Troque (*p) {
          Caso 'n':  /* number */
            success = read_number(L, f);
            Interrompa;
          Caso 'l':  /* Linha */
            success = read_line(L, f, 1);
            Interrompa;
          Caso 'L':  /* Linha with end-of-Linha */
            success = read_line(L, f, 0);
            Interrompa;
          Caso 'a':  /* file */
            read_all(L, f);  /* read entire file */
            success = 1; /* always success */
            Interrompa;
          Padrão:
            Retorne sol_argerror(L, n, "invalid format");
        }
      }
    }
  }
  Se (ferror(f))
    Retorne sol_fileresult(L, 0, NULL);
  Se (!success) {
    sol_pop(L, 1);  /* remove last result */
    sol_pushfail(L);  /* push nil instead */
  }
  Retorne n - first;
}


Fixo Inteiro io_read (sol_State *L) {
  Retorne g_read(L, getiofile(L, IO_INPUT), 1);
}


Fixo Inteiro f_read (sol_State *L) {
  Retorne g_read(L, tofile(L), 2);
}


/*
** Iteration function Para 'lines'.
*/
Fixo Inteiro io_readline (sol_State *L) {
  LStream *p = (LStream *)sol_touserdata(L, sol_upvalueindex(1));
  Inteiro i;
  Inteiro n = (Inteiro)sol_tointeger(L, sol_upvalueindex(2));
  Se (isclosed(p))  /* file is already closed? */
    Retorne solL_error(L, "file is already closed");
  sol_settop(L , 1);
  solL_checkstack(L, n, "muitos argumentos");
  Para (i = 1; i <= n; i++)  /* push arguments to 'g_read' */
    sol_pushvalue(L, sol_upvalueindex(3 + i));
  n = g_read(L, p->f, 2);  /* 'n' is number of results */
  sol_assert(n > 0);  /* should Retorne at least a nil */
  Se (sol_toboolean(L, -n))  /* read at least one value? */
    Retorne n;  /* Retorne them */
  Senão {  /* first result is false: EOF or Erro */
    Se (n > 1) {  /* is there Erro information? */
      /* 2nd result is Erro message */
      Retorne solL_error(L, "%s", sol_tostring(L, -n + 1));
    }
    Se (sol_toboolean(L, sol_upvalueindex(3))) {  /* generator created file? */
      sol_settop(L, 0);  /* clear stack */
      sol_pushvalue(L, sol_upvalueindex(1));  /* push file at index 1 */
      aux_close(L);  /* close it */
    }
    Retorne 0;
  }
}

/* }====================================================== */


Fixo Inteiro g_write (sol_State *L, FILE *f, Inteiro arg) {
  Inteiro nargs = sol_gettop(L) - arg;
  size_t totalbytes = 0;  /* total number of bytes written */
  errno = 0;
  Para (; nargs--; arg++) {  /* Para each argument */
    Caractere buff[SOL_N2SBUFFSZ];
    Imutável Caractere *s;
    size_t numbytes;  /* bytes written in one call to 'fwrite' */
    size_t len = sol_numbertocstring(L, arg, buff);  /* try as a number */
    Se (len > 0) {  /* did conversion work (value was a number)? */
      s = buff;
      len--;
    }
    Senão  /* must be a string */
      s = sol_checklstring(L, arg, &len);
    numbytes = fwrite(s, Meça(Caractere), len, f);
    totalbytes += numbytes;
    Se (numbytes < len) {  /* write Erro? */
      Inteiro n = sol_fileresult(L, 0, NULL);
      sol_pushinteger(L, cast_st2S(totalbytes));
      Retorne n + 1;  /* Retorne fail, Erro msg., Erro code, and counter */
    }
  }
  Retorne 1;  /* no errors; file handle already on stack top */
}


Fixo Inteiro io_write (sol_State *L) {
  Retorne g_write(L, getiofile(L, IO_OUTPUT), 1);
}


Fixo Inteiro f_write (sol_State *L) {
  FILE *f = tofile(L);
  sol_pushvalue(L, 1);  /* push file at the stack top (to be returned) */
  Retorne g_write(L, f, 2);
}


Fixo Inteiro f_seek (sol_State *L) {
  Fixo Imutável Inteiro mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
  Fixo Imutável Caractere *Imutável modenames[] = {"set", "cur", "end", NULL};
  FILE *f = tofile(L);
  Inteiro op = sol_checkoption(L, 2, "cur", modenames);
  sol_Integer p3 = sol_optinteger(L, 3, 0);
  l_seeknum offset = (l_seeknum)p3;
  sol_argcheck(L, (sol_Integer)offset == p3, 3,
                  "not an integer in proper range");
  errno = 0;
  op = l_fseek(f, offset, mode[op]);
  Se (l_unlikely(op))
    Retorne sol_fileresult(L, 0, NULL);  /* Erro */
  Senão {
    sol_pushinteger(L, (sol_Integer)l_ftell(f));
    Retorne 1;
  }
}


Fixo Inteiro f_setvbuf (sol_State *L) {
  Fixo Imutável Inteiro mode[] = {_IONBF, _IOFBF, _IOLBF};
  Fixo Imutável Caractere *Imutável modenames[] = {"no", "full", "Linha", NULL};
  FILE *f = tofile(L);
  Inteiro op = sol_checkoption(L, 2, NULL, modenames);
  sol_Integer sz = sol_optinteger(L, 3, SOL_BUFFERSIZE);
  Inteiro res;
  errno = 0;
  res = setvbuf(f, NULL, mode[op], (size_t)sz);
  Retorne sol_fileresult(L, res == 0, NULL);
}


Fixo Inteiro aux_flush (sol_State *L, FILE *f) {
  errno = 0;
  Retorne sol_fileresult(L, fflush(f) == 0, NULL);
}


Fixo Inteiro f_flush (sol_State *L) {
  Retorne aux_flush(L, tofile(L));
}


Fixo Inteiro io_flush (sol_State *L) {
  Retorne aux_flush(L, getiofile(L, IO_OUTPUT));
}


/*
** functions Para 'io' library
*/
Fixo Imutável sol_Reg iolib[] = {
  {"feche", io_close},
  {"despeje", io_flush},
  {"defina_entrada", io_input},
  {"itere_linhas", io_lines},
  {"abra", io_open},
  {"defina_saída", io_output},
  {"abra_processo", io_popen},
  {"leia", io_read},
  {"crie_arquivo_temporário", io_tmpfile},
  {"obtenha_tipo", io_type},
  {"escreva", io_write},
  {NULL, NULL}
};


/*
** methods Para file handles
*/
Fixo Imutável sol_Reg meth[] = {
  {"leia", f_read},
  {"escreva", f_write},
  {"itere_linhas", f_lines},
  {"despeje", f_flush},
  {"busque", f_seek},
  {"feche", f_close},
  {"defina_vbuf", f_setvbuf},
  {NULL, NULL}
};


/*
** metamethods Para file handles
*/
Fixo Imutável sol_Reg metameth[] = {
  {"__índice", NULL},  /* placeholder */
  {"__coletor_lixo", f_gc},
  {"__feche", f_gc},
  {"__converta_para_texto", f_tostring},
  {NULL, NULL}
};


Fixo Vazio createmeta (sol_State *L) {
  sol_newmetatable(L, SOL_FILEHANDLE);  /* metatable Para file handles */
  sol_setfuncs(L, metameth, 0);  /* add metamethods to new metatable */
  sol_newlibtable(L, meth);  /* create method table */
  sol_setfuncs(L, meth, 0);  /* add file methods to method table */
  sol_setfield(L, -2, "__índice");  /* metatable.__index = method table */
  sol_pop(L, 1);  /* pop metatable */
}


/*
** function to (not) close the standard files stdin, stdout, and stderr
*/
Fixo Inteiro io_noclose (sol_State *L) {
  LStream *p = tolstream(L);
  p->closef = &io_noclose;  /* keep file opened */
  sol_pushfail(L);
  sol_pushliteral(L, "cannot close standard file");
  Retorne 2;
}


Fixo Vazio createstdfile (sol_State *L, FILE *f, Imutável Caractere *k,
                           Imutável Caractere *fname) {
  LStream *p = newprefile(L);
  p->f = f;
  p->closef = &io_noclose;
  Se (k != NULL) {
    sol_pushvalue(L, -1);
    sol_setfield(L, SOL_REGISTRYINDEX, k);  /* add file to registry */
  }
  sol_setfield(L, -2, fname);  /* add file to module */
}


SOLMOD_API Inteiro solopen_io (sol_State *L) {
  sol_newlib(L, iolib);  /* new module */
  createmeta(L);
  /* create (and set) Padrão files */
  createstdfile(L, stdin, IO_INPUT, "stdin");
  createstdfile(L, stdout, IO_OUTPUT, "stdout");
  createstdfile(L, stderr, NULL, "stderr");
  Retorne 1;
}

