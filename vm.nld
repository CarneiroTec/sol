/*
** $Id: lvm.c $
** Sol virtual machine
** See Direitos Autorais Notice in sol.h
*/

#Defina vm_c
#Defina SOL_CORE

#Inclua "prefix.int"

#Inclua <float.h>
#Inclua <limits.h>
#Inclua <math.h>
#Inclua <stdio.h>
#Inclua <stdlib.h>
#Inclua <string.h>

#Inclua "sol.int"

#Inclua "api.int"
#Inclua "debug.int"
#Inclua "do.int"
#Inclua "func.int"
#Inclua "gc.int"
#Inclua "object.int"
#Inclua "opcodes.int"
#Inclua "state.int"
#Inclua "string.int"
#Inclua "table.int"
#Inclua "tm.int"
#Inclua "vm.int"


/*
** By Padrão, use jump tables in the main interpreter loop on gcc
** and compatible compilers.
*/
#Se !Definido(SOL_USE_JUMPTABLE)
#Se Definido(__GNUC__)
#Defina SOL_USE_JUMPTABLE	1
#Senão
#Defina SOL_USE_JUMPTABLE	0
#FimSe
#FimSe



/* limit Para table tag-method chains (to avoid infinite loops) */
#Defina MAXTAGLOOP	2000


/*
** 'l_intfitsf' checks whether a given integer is in the range that
** can be converted to a Real without rounding. Used in comparisons.
*/

/* number of bits in the mantissa of a Real */
#Defina NBM		(l_floatatt(MANT_DIG))

/*
** Check whether some integers may not fit in a Real, testing whether
** (maxinteger >> NBM) > 0. (That implies (1 << NBM) <= maxinteger.)
** (The shifts are done in parts, to avoid shifting by more than the size
** of an integer. In a worst Caso, NBM == 113 Para Longo Duplo and
** meça(Longo) == 32.)
*/
#Se ((((SOL_MAXINTEGER >> (NBM / 4)) >> (NBM / 4)) >> (NBM / 4)) \
	>> (NBM - (3 * (NBM / 4))))  >  0

/* limit Para integers that fit in a Real */
#Defina MAXINTFITSF	((sol_Unsigned)1 << NBM)

/* check whether 'i' is in the interval [-MAXINTFITSF, MAXINTFITSF] */
#Defina l_intfitsf(i)	((MAXINTFITSF + l_castS2U(i)) <= (2 * MAXINTFITSF))

#Senão  /* all integers fit in a Real precisely */

#Defina l_intfitsf(i)	1

#FimSe


/*
** Try to convert a value from string to a number value.
** If the value is not a string or is a string not representing
** a valid numeral (or Se coercions from strings to numbers
** are disabled via macro 'cvt2num'), Faça not modify 'result'
** and Retorne 0.
*/
Fixo Inteiro l_strton (Imutável TValue *obj, TValue *result) {
  sol_assert(obj != result);
  Se (!cvt2num(obj))  /* is object not a string? */
    Retorne 0;
  Senão {
    TString *st = tsvalue(obj);
    size_t stlen;
    Imutável Caractere *s = getlstr(st, stlen);
    Retorne (sol_o_str2num(s, result) == stlen + 1);
  }
}


/*
** Try to convert a value to a Real. The Real Caso is already handled
** by the macro 'tonumber'.
*/
Inteiro sol_v_tonumber_ (Imutável TValue *obj, sol_Number *n) {
  TValue v;
  Se (ttisinteger(obj)) {
    *n = cast_num(ivalue(obj));
    Retorne 1;
  }
  Senão Se (l_strton(obj, &v)) {  /* string coercible to number? */
    *n = nvalue(&v);  /* convert result of 'sol_o_str2num' to a Real */
    Retorne 1;
  }
  Senão
    Retorne 0;  /* conversion failed */
}


/*
** try to convert a Real to an integer, rounding according to 'mode'.
*/
Inteiro sol_v_flttointeger (sol_Number n, sol_Integer *p, F2Imod mode) {
  sol_Number f = l_floor(n);
  Se (n != f) {  /* not an integral value? */
    Se (mode == F2Ieq) Retorne 0;  /* fails Se mode demands integral value */
    Senão Se (mode == F2Iceil)  /* needs ceiling? */
      f += 1;  /* convert floor to ceiling (remember: n != f) */
  }
  Retorne sol_numbertointeger(f, p);
}


/*
** try to convert a value to an integer, rounding according to 'mode',
** without string coercion.
** ("Fast track" handled by macro 'tointegerns'.)
*/
Inteiro sol_v_tointegerns (Imutável TValue *obj, sol_Integer *p, F2Imod mode) {
  Se (ttisfloat(obj))
    Retorne sol_v_flttointeger(fltvalue(obj), p, mode);
  Senão Se (ttisinteger(obj)) {
    *p = ivalue(obj);
    Retorne 1;
  }
  Senão
    Retorne 0;
}


/*
** try to convert a value to an integer.
*/
Inteiro sol_v_tointeger (Imutável TValue *obj, sol_Integer *p, F2Imod mode) {
  TValue v;
  Se (l_strton(obj, &v))  /* does 'obj' point to a numerical string? */
    obj = &v;  /* change it to point to its corresponding number */
  Retorne sol_v_tointegerns(obj, p, mode);
}


/*
** Try to convert a 'Para' limit to an integer, preserving the semantics
** of the loop. Return true Se the loop must not run; otherwise, '*p'
** gets the integer limit.
** (The following explanation assumes a positive step; it is valid Para
** negative steps mutatis mutandis.)
** If the limit is an integer or can be converted to an integer,
** rounding down, that is the limit.
** Otherwise, check whether the limit can be converted to a Real. If
** the Real is too large, clip it to SOL_MAXINTEGER.  If the Real
** is too negative, the loop should not run, because any initial
** integer value is greater than such limit; so, the function returns
** true to signal that. (For this latter Caso, no integer limit would be
** correct; even a limit of SOL_MININTEGER would run the loop once Para
** an initial value equal to SOL_MININTEGER.)
*/
Fixo Inteiro forlimit (sol_State *L, sol_Integer init, Imutável TValue *lim,
                                   sol_Integer *p, sol_Integer step) {
  Se (!sol_v_tointeger(lim, p, (step < 0 ? F2Iceil : F2Ifloor))) {
    /* not coercible to in integer */
    sol_Number flim;  /* try to convert to Real */
    Se (!tonumber(lim, &flim)) /* cannot convert to Real? */
      sol_g_forerror(L, lim, "limit");
    /* Senão 'flim' is a Real out of integer bounds */
    Se (sol_numlt(0, flim)) {  /* Se it is positive, it is too large */
      Se (step < 0) Retorne 1;  /* initial value must be less than it */
      *p = SOL_MAXINTEGER;  /* truncate */
    }
    Senão {  /* it is less than min integer */
      Se (step > 0) Retorne 1;  /* initial value must be greater than it */
      *p = SOL_MININTEGER;  /* truncate */
    }
  }
  Retorne (step > 0 ? init > *p : init < *p);  /* not to run? */
}


/*
** Prepare a numerical Para loop (opcode OP_FORPREP).
** Before execution, stack is as follows:
**   ra     : initial value
**   ra + 1 : limit
**   ra + 2 : step
** Return true to skip the loop. Otherwise,
** after preparation, stack will be as follows:
**   ra     : loop counter (integer loops) or limit (Real loops)
**   ra + 1 : step
**   ra + 2 : control variable
*/
Fixo Inteiro forprep (sol_State *L, StkId ra) {
  TValue *pinit = s2v(ra);
  TValue *plimit = s2v(ra + 1);
  TValue *pstep = s2v(ra + 2);
  Se (ttisinteger(pinit) && ttisinteger(pstep)) { /* integer loop? */
    sol_Integer init = ivalue(pinit);
    sol_Integer step = ivalue(pstep);
    sol_Integer limit;
    Se (step == 0)
      sol_g_runerror(L, "'Para' step is zero");
    Se (forlimit(L, init, plimit, &limit, step))
      Retorne 1;  /* skip the loop */
    Senão {  /* prepare loop counter */
      sol_Unsigned count;
      Se (step > 0) {  /* ascending loop? */
        count = l_castS2U(limit) - l_castS2U(init);
        Se (step != 1)  /* avoid division in the too common Caso */
          count /= l_castS2U(step);
      }
      Senão {  /* step < 0; descending loop */
        count = l_castS2U(init) - l_castS2U(limit);
        /* 'step+1' avoids negating 'mininteger' */
        count /= l_castS2U(-(step + 1)) + 1u;
      }
      /* use 'chgivalue' Para places that Para sure had integers */
      chgivalue(s2v(ra), l_castU2S(count));  /* change init to count */
      setivalue(s2v(ra + 1), step);  /* change limit to step */
      chgivalue(s2v(ra + 2), init);  /* change step to init */
    }
  }
  Senão {  /* try making all values floats */
    sol_Number init; sol_Number limit; sol_Number step;
    Se (l_unlikely(!tonumber(plimit, &limit)))
      sol_g_forerror(L, plimit, "limit");
    Se (l_unlikely(!tonumber(pstep, &step)))
      sol_g_forerror(L, pstep, "step");
    Se (l_unlikely(!tonumber(pinit, &init)))
      sol_g_forerror(L, pinit, "initial value");
    Se (step == 0)
      sol_g_runerror(L, "'Para' step is zero");
    Se (sol_numlt(0, step) ? sol_numlt(limit, init)
                            : sol_numlt(init, limit))
      Retorne 1;  /* skip the loop */
    Senão {
      /* make sure all values are floats */
      setfltvalue(s2v(ra), limit);
      setfltvalue(s2v(ra + 1), step);
      setfltvalue(s2v(ra + 2), init);  /* control variable */
    }
  }
  Retorne 0;
}


/*
** Execute a step of a Real numerical Para loop, returning
** true iff the loop must Continue. (The integer Caso is
** written online with opcode OP_FORLOOP, Para performance.)
*/
Fixo Inteiro floatforloop (StkId ra) {
  sol_Number step = fltvalue(s2v(ra + 1));
  sol_Number limit = fltvalue(s2v(ra));
  sol_Number idx = fltvalue(s2v(ra + 2));  /* control variable */
  idx = sol_numadd(L, idx, step);  /* increment index */
  Se (sol_numlt(0, step) ? sol_numle(idx, limit)
                          : sol_numle(limit, idx)) {
    chgfltvalue(s2v(ra + 2), idx);  /* update control variable */
    Retorne 1;  /* jump back */
  }
  Senão
    Retorne 0;  /* finish the loop */
}


/*
** Finish the table access 'val = t[key]' and Retorne the tag of the result.
*/
lu_byte sol_v_finishget (sol_State *L, Imutável TValue *t, TValue *key,
                                      StkId val, lu_byte tag) {
  Inteiro loop;  /* counter to avoid infinite loops */
  Imutável TValue *tm;  /* metamethod */
  Para (loop = 0; loop < MAXTAGLOOP; loop++) {
    Se (tag == SOL_VNOTABLE) {  /* 't' is not a table? */
      sol_assert(!ttistable(t));
      tm = sol_t_gettmbyobj(L, t, TM_INDEX);
      Se (l_unlikely(notm(tm)))
        sol_g_typeerror(L, t, "index");  /* no metamethod */
      /* Senão will try the metamethod */
    }
    Senão {  /* 't' is a table */
      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);  /* table's metamethod */
      Se (tm == NULL) {  /* no metamethod? */
        setnilvalue(s2v(val));  /* result is nil */
        Retorne SOL_VNIL;
      }
      /* Senão will try the metamethod */
    }
    Se (ttisfunction(tm)) {  /* is metamethod a function? */
      tag = sol_t_callTMres(L, tm, t, key, val);  /* call it */
      Retorne tag;  /* Retorne tag of the result */
    }
    t = tm;  /* Senão try to access 'tm[key]' */
    sol_v_fastget(t, key, s2v(val), sol_h_get, tag);
    Se (!tagisempty(tag))
      Retorne tag;  /* done */
    /* Senão repeat (tail call 'sol_v_finishget') */
  }
  sol_g_runerror(L, "'__index' chain too Longo; possible loop");
  Retorne 0;  /* to avoid warnings */
}


/*
** Finish a table assignment 't[key] = val'.
** About anchoring the table before the call to 'sol_h_finishset':
** This call may trigger an emergency collection. When loop>0,
** the table being accessed is a field in some metatable. If this
** metatable is weak and the table is not anchored, this collection
** could collect that table Enquanto it is being updated.
*/
Vazio sol_v_finishset (sol_State *L, Imutável TValue *t, TValue *key,
                      TValue *val, Inteiro hres) {
  Inteiro loop;  /* counter to avoid infinite loops */
  Para (loop = 0; loop < MAXTAGLOOP; loop++) {
    Imutável TValue *tm;  /* '__newindex' metamethod */
    Se (hres != HNOTATABLE) {  /* is 't' a table? */
      Table *h = hvalue(t);  /* save 't' table */
      tm = fasttm(L, h->metatable, TM_NEWINDEX);  /* get metamethod */
      Se (tm == NULL) {  /* no metamethod? */
        sethvalue2s(L, L->top.p, h);  /* anchor 't' */
        L->top.p++;  /* assume EXTRA_STACK */
        sol_h_finishset(L, h, key, val, hres);  /* set new value */
        L->top.p--;
        invalidateTMcache(h);
        sol_c_barrierback(L, obj2gco(h), val);
        Retorne;
      }
      /* Senão will try the metamethod */
    }
    Senão {  /* not a table; check metamethod */
      tm = sol_t_gettmbyobj(L, t, TM_NEWINDEX);
      Se (l_unlikely(notm(tm)))
        sol_g_typeerror(L, t, "index");
    }
    /* try the metamethod */
    Se (ttisfunction(tm)) {
      sol_t_callTM(L, tm, t, key, val);
      Retorne;
    }
    t = tm;  /* Senão repeat assignment over 'tm' */
    sol_v_fastset(t, key, val, hres, sol_h_pset);
    Se (hres == HOK) {
      sol_v_finishfastset(L, t, val);
      Retorne;  /* done */
    }
    /* Senão 'Retorne sol_v_finishset(L, t, key, val, slot)' (loop) */
  }
  sol_g_runerror(L, "'__newindex' chain too Longo; possible loop");
}


/*
** Compare two strings 'ts1' x 'ts2', returning an integer less-equal-
** -greater than zero Se 'ts1' is less-equal-greater than 'ts2'.
** The code is a little tricky because it allows '\0' in the strings
** and it uses 'strcoll' (to respect locales) Para each segment
** of the strings. Note that segments can compare equal but still
** have different lengths.
*/
Fixo Inteiro l_strcmp (Imutável TString *ts1, Imutável TString *ts2) {
  size_t rl1;  /* real length */
  Imutável Caractere *s1 = getlstr(ts1, rl1);
  size_t rl2;
  Imutável Caractere *s2 = getlstr(ts2, rl2);
  Para (;;) {  /* Para each segment */
    Inteiro temp = strcoll(s1, s2);
    Se (temp != 0)  /* not equal? */
      Retorne temp;  /* done */
    Senão {  /* strings are equal up to a '\0' */
      size_t zl1 = strlen(s1);  /* index of first '\0' in 's1' */
      size_t zl2 = strlen(s2);  /* index of first '\0' in 's2' */
      Se (zl2 == rl2)  /* 's2' is finished? */
        Retorne (zl1 == rl1) ? 0 : 1;  /* check 's1' */
      Senão Se (zl1 == rl1)  /* 's1' is finished? */
        Retorne -1;  /* 's1' is less than 's2' ('s2' is not finished) */
      /* both strings longer than 'zl'; go on comparing after the '\0' */
      zl1++; zl2++;
      s1 += zl1; rl1 -= zl1; s2 += zl2; rl2 -= zl2;
    }
  }
}


/*
** Check whether integer 'i' is less than Real 'f'. If 'i' has an
** exact representation as a Real ('l_intfitsf'), compare numbers as
** floats. Otherwise, use the equivalence 'i < f <=> i < ceil(f)'.
** If 'ceil(f)' is out of integer range, either 'f' is greater than
** all integers or less than all integers.
** (The test with 'l_intfitsf' is only Para performance; the Senão
** Caso is correct Para all values, but it is slow due to the conversion
** from Real to Inteiro.)
** When 'f' is NaN, comparisons must result in false.
*/
l_sinline Inteiro LTintfloat (sol_Integer i, sol_Number f) {
  Se (l_intfitsf(i))
    Retorne sol_numlt(cast_num(i), f);  /* compare them as floats */
  Senão {  /* i < f <=> i < ceil(f) */
    sol_Integer fi;
    Se (sol_v_flttointeger(f, &fi, F2Iceil))  /* fi = ceil(f) */
      Retorne i < fi;   /* compare them as integers */
    Senão  /* 'f' is either greater or less than all integers */
      Retorne f > 0;  /* greater? */
  }
}


/*
** Check whether integer 'i' is less than or equal to Real 'f'.
** See comments on previous function.
*/
l_sinline Inteiro LEintfloat (sol_Integer i, sol_Number f) {
  Se (l_intfitsf(i))
    Retorne sol_numle(cast_num(i), f);  /* compare them as floats */
  Senão {  /* i <= f <=> i <= floor(f) */
    sol_Integer fi;
    Se (sol_v_flttointeger(f, &fi, F2Ifloor))  /* fi = floor(f) */
      Retorne i <= fi;   /* compare them as integers */
    Senão  /* 'f' is either greater or less than all integers */
      Retorne f > 0;  /* greater? */
  }
}


/*
** Check whether Real 'f' is less than integer 'i'.
** See comments on previous function.
*/
l_sinline Inteiro LTfloatint (sol_Number f, sol_Integer i) {
  Se (l_intfitsf(i))
    Retorne sol_numlt(f, cast_num(i));  /* compare them as floats */
  Senão {  /* f < i <=> floor(f) < i */
    sol_Integer fi;
    Se (sol_v_flttointeger(f, &fi, F2Ifloor))  /* fi = floor(f) */
      Retorne fi < i;   /* compare them as integers */
    Senão  /* 'f' is either greater or less than all integers */
      Retorne f < 0;  /* less? */
  }
}


/*
** Check whether Real 'f' is less than or equal to integer 'i'.
** See comments on previous function.
*/
l_sinline Inteiro LEfloatint (sol_Number f, sol_Integer i) {
  Se (l_intfitsf(i))
    Retorne sol_numle(f, cast_num(i));  /* compare them as floats */
  Senão {  /* f <= i <=> ceil(f) <= i */
    sol_Integer fi;
    Se (sol_v_flttointeger(f, &fi, F2Iceil))  /* fi = ceil(f) */
      Retorne fi <= i;   /* compare them as integers */
    Senão  /* 'f' is either greater or less than all integers */
      Retorne f < 0;  /* less? */
  }
}


/*
** Return 'l < r', Para numbers.
*/
l_sinline Inteiro LTnum (Imutável TValue *l, Imutável TValue *r) {
  sol_assert(ttisnumber(l) && ttisnumber(r));
  Se (ttisinteger(l)) {
    sol_Integer li = ivalue(l);
    Se (ttisinteger(r))
      Retorne li < ivalue(r);  /* both are integers */
    Senão  /* 'l' is Inteiro and 'r' is Real */
      Retorne LTintfloat(li, fltvalue(r));  /* l < r ? */
  }
  Senão {
    sol_Number lf = fltvalue(l);  /* 'l' must be Real */
    Se (ttisfloat(r))
      Retorne sol_numlt(lf, fltvalue(r));  /* both are Real */
    Senão  /* 'l' is Real and 'r' is Inteiro */
      Retorne LTfloatint(lf, ivalue(r));
  }
}


/*
** Return 'l <= r', Para numbers.
*/
l_sinline Inteiro LEnum (Imutável TValue *l, Imutável TValue *r) {
  sol_assert(ttisnumber(l) && ttisnumber(r));
  Se (ttisinteger(l)) {
    sol_Integer li = ivalue(l);
    Se (ttisinteger(r))
      Retorne li <= ivalue(r);  /* both are integers */
    Senão  /* 'l' is Inteiro and 'r' is Real */
      Retorne LEintfloat(li, fltvalue(r));  /* l <= r ? */
  }
  Senão {
    sol_Number lf = fltvalue(l);  /* 'l' must be Real */
    Se (ttisfloat(r))
      Retorne sol_numle(lf, fltvalue(r));  /* both are Real */
    Senão  /* 'l' is Real and 'r' is Inteiro */
      Retorne LEfloatint(lf, ivalue(r));
  }
}


/*
** Retorne 'l < r' Para non-numbers.
*/
Fixo Inteiro lessthanothers (sol_State *L, Imutável TValue *l, Imutável TValue *r) {
  sol_assert(!ttisnumber(l) || !ttisnumber(r));
  Se (ttisstring(l) && ttisstring(r))  /* both are strings? */
    Retorne l_strcmp(tsvalue(l), tsvalue(r)) < 0;
  Senão
    Retorne sol_t_callorderTM(L, l, r, TM_LT);
}


/*
** Main operation less than; Retorne 'l < r'.
*/
Inteiro sol_v_lessthan (sol_State *L, Imutável TValue *l, Imutável TValue *r) {
  Se (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */
    Retorne LTnum(l, r);
  Senão Retorne lessthanothers(L, l, r);
}


/*
** Retorne 'l <= r' Para non-numbers.
*/
Fixo Inteiro lessequalothers (sol_State *L, Imutável TValue *l, Imutável TValue *r) {
  sol_assert(!ttisnumber(l) || !ttisnumber(r));
  Se (ttisstring(l) && ttisstring(r))  /* both are strings? */
    Retorne l_strcmp(tsvalue(l), tsvalue(r)) <= 0;
  Senão
    Retorne sol_t_callorderTM(L, l, r, TM_LE);
}


/*
** Main operation less than or equal to; Retorne 'l <= r'.
*/
Inteiro sol_v_lessequal (sol_State *L, Imutável TValue *l, Imutável TValue *r) {
  Se (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */
    Retorne LEnum(l, r);
  Senão Retorne lessequalothers(L, l, r);
}


/*
** Main operation Para equality of Sol values; Retorne 't1 == t2'.
** L == NULL means raw equality (no metamethods)
*/
Inteiro sol_v_equalobj (sol_State *L, Imutável TValue *t1, Imutável TValue *t2) {
  Imutável TValue *tm;
  Se (ttype(t1) != ttype(t2))  /* not the same type? */
    Retorne 0;
  Senão Se (ttypetag(t1) != ttypetag(t2)) {
    Troque (ttypetag(t1)) {
      Caso SOL_VNUMINT: {  /* integer == Real? */
        /* integer and Real can only be equal Se Real has an integer
           value equal to the integer */
        sol_Integer i2;
        Retorne (sol_v_flttointeger(fltvalue(t2), &i2, F2Ieq) &&
                ivalue(t1) == i2);
      }
      Caso SOL_VNUMFLT: {  /* Real == integer? */
        sol_Integer i1;  /* see comment in previous Caso */
        Retorne (sol_v_flttointeger(fltvalue(t1), &i1, F2Ieq) &&
                i1 == ivalue(t2));
      }
      Caso SOL_VSHRSTR: Caso SOL_VLNGSTR: {
        /* compare two strings with different variants: they can be
           equal when one string is a Curto string and the other is
           an external string  */
        Retorne sol_s_eqstr(tsvalue(t1), tsvalue(t2));
      }
      Padrão:
        /* only numbers (integer/Real) and strings (Longo/Curto) can have
           equal values with different variants */
        Retorne 0;
    }
  }
  Senão {  /* equal variants */
    Troque (ttypetag(t1)) {
      Caso SOL_VNIL: Caso SOL_VFALSE: Caso SOL_VTRUE:
        Retorne 1;
      Caso SOL_VNUMINT:
        Retorne (ivalue(t1) == ivalue(t2));
      Caso SOL_VNUMFLT:
        Retorne (fltvalue(t1) == fltvalue(t2));
      Caso SOL_VLIGHTUSERDATA: Retorne pvalue(t1) == pvalue(t2);
      Caso SOL_VSHRSTR:
        Retorne eqshrstr(tsvalue(t1), tsvalue(t2));
      Caso SOL_VLNGSTR:
        Retorne sol_s_eqstr(tsvalue(t1), tsvalue(t2));
      Caso SOL_VUSERDATA: {
        Se (uvalue(t1) == uvalue(t2)) Retorne 1;
        Senão Se (L == NULL) Retorne 0;
        tm = fasttm(L, uvalue(t1)->metatable, TM_EQ);
        Se (tm == NULL)
          tm = fasttm(L, uvalue(t2)->metatable, TM_EQ);
        Interrompa;  /* will try TM */
      }
      Caso SOL_VTABLE: {
        Se (hvalue(t1) == hvalue(t2)) Retorne 1;
        Senão Se (L == NULL) Retorne 0;
        tm = fasttm(L, hvalue(t1)->metatable, TM_EQ);
        Se (tm == NULL)
          tm = fasttm(L, hvalue(t2)->metatable, TM_EQ);
        Interrompa;  /* will try TM */
      }
      Caso SOL_VLCF:
        Retorne (fvalue(t1) == fvalue(t2));
      Padrão:  /* functions and threads */
        Retorne (gcvalue(t1) == gcvalue(t2));
    }
    Se (tm == NULL)  /* no TM? */
      Retorne 0;  /* objects are different */
    Senão {
      Inteiro tag = sol_t_callTMres(L, tm, t1, t2, L->top.p);  /* call TM */
      Retorne !tagisfalse(tag);
    }
  }
}


/* macro used by 'sol_v_concat' to ensure that element at 'o' is a string */
#Defina tostring(L,o)  \
	(ttisstring(o) || (cvt2str(o) && (sol_o_tostring(L, o), 1)))

#Defina isemptystr(o)	(ttisshrstring(o) && tsvalue(o)->shrlen == 0)

/* copy strings in stack from top - n up to top - 1 to buffer */
Fixo Vazio copy2buff (StkId top, Inteiro n, Caractere *buff) {
  size_t tl = 0;  /* size already copied */
  Faça {
    TString *st = tsvalue(s2v(top - n));
    size_t l;  /* length of string being copied */
    Imutável Caractere *s = getlstr(st, l);
    memcpy(buff + tl, s, l * meça(Caractere));
    tl += l;
  } Enquanto (--n > 0);
}


/*
** Main operation Para concatenation: concat 'total' values in the stack,
** from 'L->top.p - total' up to 'L->top.p - 1'.
*/
Vazio sol_v_concat (sol_State *L, Inteiro total) {
  Se (total == 1)
    Retorne;  /* "all" values already concatenated */
  Faça {
    StkId top = L->top.p;
    Inteiro n = 2;  /* number of elements handled in this pass (at least 2) */
    Se (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||
        !tostring(L, s2v(top - 1)))
      sol_t_tryconcatTM(L);  /* may invalidate 'top' */
    Senão Se (isemptystr(s2v(top - 1)))  /* second operand is empty? */
      cast_void(tostring(L, s2v(top - 2)));  /* result is first operand */
    Senão Se (isemptystr(s2v(top - 2))) {  /* first operand is empty string? */
      setobjs2s(L, top - 2, top - 1);  /* result is second op. */
    }
    Senão {
      /* at least two non-empty string values; get as many as possible */
      size_t tl = tsslen(tsvalue(s2v(top - 1)));
      TString *ts;
      /* collect total length and number of strings */
      Para (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {
        size_t l = tsslen(tsvalue(s2v(top - n - 1)));
        Se (l_unlikely(l >= MAX_SIZE - meça(TString) - tl)) {
          L->top.p = top - total;  /* pop strings to avoid wasting stack */
          sol_g_runerror(L, "estouro de comprimento de texto");
        }
        tl += l;
      }
      Se (tl <= SOL_MAXSHORTLEN) {  /* is result a Curto string? */
        Caractere buff[SOL_MAXSHORTLEN];
        copy2buff(top, n, buff);  /* copy strings to buffer */
        ts = sol_s_newlstr(L, buff, tl);
      }
      Senão {  /* Longo string; copy strings directly to final result */
        ts = sol_s_createlngstrobj(L, tl);
        copy2buff(top, n, getlngstr(ts));
      }
      setsvalue2s(L, top - n, ts);  /* create result */
    }
    total -= n - 1;  /* got 'n' strings to create one new */
    L->top.p -= n - 1;  /* popped 'n' strings and pushed one */
  } Enquanto (total > 1);  /* repeat until only 1 result left */
}


/*
** Main operation 'ra = #rb'.
*/
Vazio sol_v_objlen (sol_State *L, StkId ra, Imutável TValue *rb) {
  Imutável TValue *tm;
  Troque (ttypetag(rb)) {
    Caso SOL_VTABLE: {
      Table *h = hvalue(rb);
      tm = fasttm(L, h->metatable, TM_LEN);
      Se (tm) Interrompa;  /* metamethod? Interrompa Troque to call it */
      setivalue(s2v(ra), l_castU2S(sol_h_getn(L, h)));  /* Senão primitive len */
      Retorne;
    }
    Caso SOL_VSHRSTR: {
      setivalue(s2v(ra), tsvalue(rb)->shrlen);
      Retorne;
    }
    Caso SOL_VLNGSTR: {
      setivalue(s2v(ra), cast_st2S(tsvalue(rb)->u.lnglen));
      Retorne;
    }
    Padrão: {  /* try metamethod */
      tm = sol_t_gettmbyobj(L, rb, TM_LEN);
      Se (l_unlikely(notm(tm)))  /* no metamethod? */
        sol_g_typeerror(L, rb, "get length of");
      Interrompa;
    }
  }
  sol_t_callTMres(L, tm, rb, rb, ra);
}


/*
** Integer division; Retorne 'm // n', that is, floor(m/n).
** C division truncates its result (rounds towards zero).
** 'floor(q) == trunc(q)' when 'q >= 0' or when 'q' is integer,
** otherwise 'floor(q) == trunc(q) - 1'.
*/
sol_Integer sol_v_idiv (sol_State *L, sol_Integer m, sol_Integer n) {
  Se (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  /* special cases: -1 or 0 */
    Se (n == 0)
      sol_g_runerror(L, "tentativa de dividir por zero");
    Retorne intop(-, 0, m);   /* n==-1; avoid overflow with 0x80000...//-1 */
  }
  Senão {
    sol_Integer q = m / n;  /* perform C division */
    Se ((m ^ n) < 0 && m % n != 0)  /* 'm/n' would be negative non-integer? */
      q -= 1;  /* correct result Para different rounding */
    Retorne q;
  }
}


/*
** Integer modulus; Retorne 'm % n'. (Assume that C '%' with
** negative operands follows C99 behavior. See previous comment
** about sol_v_idiv.)
*/
sol_Integer sol_v_mod (sol_State *L, sol_Integer m, sol_Integer n) {
  Se (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  /* special cases: -1 or 0 */
    Se (n == 0)
      sol_g_runerror(L, "tentativa de executar 'n%%0'");
    Retorne 0;   /* m % -1 == 0; avoid overflow with 0x80000...%-1 */
  }
  Senão {
    sol_Integer r = m % n;
    Se (r != 0 && (r ^ n) < 0)  /* 'm/n' would be non-integer negative? */
      r += n;  /* correct result Para different rounding */
    Retorne r;
  }
}


/*
** Float modulus
*/
sol_Number sol_v_modf (sol_State *L, sol_Number m, sol_Number n) {
  sol_Number r;
  sol_nummod(L, m, n, r);
  Retorne r;
}


/* number of bits in an integer */
#Defina NBITS	l_numbits(sol_Integer)


/*
** Shift left operation. (Shift right just negates 'y'.)
*/
sol_Integer sol_v_shiftl (sol_Integer x, sol_Integer y) {
  Se (y < 0) {  /* shift right? */
    Se (y <= -NBITS) Retorne 0;
    Senão Retorne intop(>>, x, -y);
  }
  Senão {  /* shift left */
    Se (y >= NBITS) Retorne 0;
    Senão Retorne intop(<<, x, y);
  }
}


/*
** create a new Sol closure, push it in the stack, and initialize
** its upvalues.
*/
Fixo Vazio pushclosure (sol_State *L, Proto *p, UpVal **encup, StkId base,
                         StkId ra) {
  Inteiro nup = p->sizeupvalues;
  Upvaldesc *uv = p->upvalues;
  Inteiro i;
  LClosure *ncl = sol_f_newLclosure(L, nup);
  ncl->p = p;
  setclLvalue2s(L, ra, ncl);  /* anchor new closure in stack */
  Para (i = 0; i < nup; i++) {  /* fill in its upvalues */
    Se (uv[i].instack)  /* upvalue refers to local variable? */
      ncl->upvals[i] = sol_f_findupval(L, base + uv[i].idx);
    Senão  /* get upvalue from enclosing function */
      ncl->upvals[i] = encup[uv[i].idx];
    sol_c_objbarrier(L, ncl, ncl->upvals[i]);
  }
}


/*
** finish execution of an opcode interrupted by a yield
*/
Vazio sol_v_finishOp (sol_State *L) {
  CallInfo *ci = L->ci;
  StkId base = ci->func.p + 1;
  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */
  OpCode op = GET_OPCODE(inst);
  Troque (op) {  /* finish its execution */
    Caso OP_MMBIN: Caso OP_MMBINI: Caso OP_MMBINK: {
      setobjs2s(L, base + GETARG_A(*(ci->u.l.savedpc - 2)), --L->top.p);
      Interrompa;
    }
    Caso OP_UNM: Caso OP_BNOT: Caso OP_LEN:
    Caso OP_GETTABUP: Caso OP_GETTABLE: Caso OP_GETI:
    Caso OP_GETFIELD: Caso OP_SELF: {
      setobjs2s(L, base + GETARG_A(inst), --L->top.p);
      Interrompa;
    }
    Caso OP_LT: Caso OP_LE:
    Caso OP_LTI: Caso OP_LEI:
    Caso OP_GTI: Caso OP_GEI:
    Caso OP_EQ: {  /* note that 'OP_EQI'/'OP_EQK' cannot yield */
      Inteiro res = !l_isfalse(s2v(L->top.p - 1));
      L->top.p--;
      sol_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);
      Se (res != GETARG_k(inst))  /* condition failed? */
        ci->u.l.savedpc++;  /* skip jump instruction */
      Interrompa;
    }
    Caso OP_CONCAT: {
      StkId top = L->top.p - 1;  /* top when 'sol_t_tryconcatTM' was called */
      Inteiro a = GETARG_A(inst);      /* first element to concatenate */
      Inteiro total = cast_int(top - 1 - (base + a));  /* yet to concatenate */
      setobjs2s(L, top - 2, top);  /* put TM result in proper position */
      L->top.p = top - 1;  /* top is one after last element (at top-2) */
      sol_v_concat(L, total);  /* concat them (may yield again) */
      Interrompa;
    }
    Caso OP_CLOSE: {  /* yielded closing variables */
      ci->u.l.savedpc--;  /* repeat instruction to close other vars. */
      Interrompa;
    }
    Caso OP_RETURN: {  /* yielded closing variables */
      StkId ra = base + GETARG_A(inst);
      /* adjust top to signal correct number of returns, in Caso the
         Retorne is "up to top" ('isIT') */
      L->top.p = ra + ci->u2.nres;
      /* repeat instruction to close other vars. and complete the Retorne */
      ci->u.l.savedpc--;
      Interrompa;
    }
    Padrão: {
      /* only these other opcodes can yield */
      sol_assert(op == OP_TFORCALL || op == OP_CALL ||
           op == OP_TAILCALL || op == OP_SETTABUP || op == OP_SETTABLE ||
           op == OP_SETI || op == OP_SETFIELD);
      Interrompa;
    }
  }
}




/*
** {==================================================================
** Macros Para arithmetic/bitwise/comparison opcodes in 'sol_v_execute'
**
** All these macros are to be used exclusively inside the main
** iterpreter loop (function sol_v_execute) and may access directly
** the local variables of that function (L, i, pc, ci, etc.).
** ===================================================================
*/

#Defina l_addi(L,a,b)	intop(+, a, b)
#Defina l_subi(L,a,b)	intop(-, a, b)
#Defina l_muli(L,a,b)	intop(*, a, b)
#Defina l_band(a,b)	intop(&, a, b)
#Defina l_bor(a,b)	intop(|, a, b)
#Defina l_bxor(a,b)	intop(^, a, b)

#Defina l_lti(a,b)	(a < b)
#Defina l_lei(a,b)	(a <= b)
#Defina l_gti(a,b)	(a > b)
#Defina l_gei(a,b)	(a >= b)


/*
** Arithmetic operations with immediate operands. 'iop' is the integer
** operation, 'fop' is the Real operation.
*/
#Defina op_arithI(L,iop,fop) {  \
  TValue *ra = vRA(i); \
  TValue *v1 = vRB(i);  \
  Inteiro imm = GETARG_sC(i);  \
  Se (ttisinteger(v1)) {  \
    sol_Integer iv1 = ivalue(v1);  \
    pc++; setivalue(ra, iop(L, iv1, imm));  \
  }  \
  Senão Se (ttisfloat(v1)) {  \
    sol_Number nb = fltvalue(v1);  \
    sol_Number fimm = cast_num(imm);  \
    pc++; setfltvalue(ra, fop(L, nb, fimm)); \
  }}


/*
** Auxiliary function Para arithmetic operations over floats and others
** with two operands.
*/
#Defina op_arithf_aux(L,v1,v2,fop) {  \
  sol_Number n1; sol_Number n2;  \
  Se (tonumberns(v1, n1) && tonumberns(v2, n2)) {  \
    StkId ra = RA(i);  \
    pc++; setfltvalue(s2v(ra), fop(L, n1, n2));  \
  }}


/*
** Arithmetic operations over floats and others with Registrador operands.
*/
#Defina op_arithf(L,fop) {  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = vRC(i);  \
  op_arithf_aux(L, v1, v2, fop); }


/*
** Arithmetic operations with K operands Para floats.
*/
#Defina op_arithfK(L,fop) {  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = KC(i); sol_assert(ttisnumber(v2));  \
  op_arithf_aux(L, v1, v2, fop); }


/*
** Arithmetic operations over integers and floats.
*/
#Defina op_arith_aux(L,v1,v2,iop,fop) {  \
  Se (ttisinteger(v1) && ttisinteger(v2)) {  \
    StkId ra = RA(i); \
    sol_Integer i1 = ivalue(v1); sol_Integer i2 = ivalue(v2);  \
    pc++; setivalue(s2v(ra), iop(L, i1, i2));  \
  }  \
  Senão op_arithf_aux(L, v1, v2, fop); }


/*
** Arithmetic operations with Registrador operands.
*/
#Defina op_arith(L,iop,fop) {  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = vRC(i);  \
  op_arith_aux(L, v1, v2, iop, fop); }


/*
** Arithmetic operations with K operands.
*/
#Defina op_arithK(L,iop,fop) {  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = KC(i); sol_assert(ttisnumber(v2));  \
  op_arith_aux(L, v1, v2, iop, fop); }


/*
** Bitwise operations with constant operand.
*/
#Defina op_bitwiseK(L,op) {  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = KC(i);  \
  sol_Integer i1;  \
  sol_Integer i2 = ivalue(v2);  \
  Se (tointegerns(v1, &i1)) {  \
    StkId ra = RA(i); \
    pc++; setivalue(s2v(ra), op(i1, i2));  \
  }}


/*
** Bitwise operations with Registrador operands.
*/
#Defina op_bitwise(L,op) {  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = vRC(i);  \
  sol_Integer i1; sol_Integer i2;  \
  Se (tointegerns(v1, &i1) && tointegerns(v2, &i2)) {  \
    StkId ra = RA(i); \
    pc++; setivalue(s2v(ra), op(i1, i2));  \
  }}


/*
** Order operations with Registrador operands. 'opn' actually works
** Para all numbers, but the fast track improves performance Para
** integers.
*/
#Defina op_order(L,opi,opn,other) {  \
  TValue *ra = vRA(i); \
  Inteiro cond;  \
  TValue *rb = vRB(i);  \
  Se (ttisinteger(ra) && ttisinteger(rb)) {  \
    sol_Integer ia = ivalue(ra);  \
    sol_Integer ib = ivalue(rb);  \
    cond = opi(ia, ib);  \
  }  \
  Senão Se (ttisnumber(ra) && ttisnumber(rb))  \
    cond = opn(ra, rb);  \
  Senão  \
    Protect(cond = other(L, ra, rb));  \
  docondjump(); }


/*
** Order operations with immediate operand. (Immediate operand is
** always small enough to have an exact representation as a Real.)
*/
#Defina op_orderI(L,opi,opf,inv,tm) {  \
  TValue *ra = vRA(i); \
  Inteiro cond;  \
  Inteiro im = GETARG_sB(i);  \
  Se (ttisinteger(ra))  \
    cond = opi(ivalue(ra), im);  \
  Senão Se (ttisfloat(ra)) {  \
    sol_Number fa = fltvalue(ra);  \
    sol_Number fim = cast_num(im);  \
    cond = opf(fa, fim);  \
  }  \
  Senão {  \
    Inteiro isf = GETARG_C(i);  \
    Protect(cond = sol_t_callorderiTM(L, ra, im, inv, isf, tm));  \
  }  \
  docondjump(); }

/* }================================================================== */


/*
** {==================================================================
** Function 'sol_v_execute': main interpreter loop
** ===================================================================
*/

/*
** some macros Para common tasks in 'sol_v_execute'
*/


#Defina RA(i)	(base+GETARG_A(i))
#Defina vRA(i)	s2v(RA(i))
#Defina RB(i)	(base+GETARG_B(i))
#Defina vRB(i)	s2v(RB(i))
#Defina KB(i)	(k+GETARG_B(i))
#Defina RC(i)	(base+GETARG_C(i))
#Defina vRC(i)	s2v(RC(i))
#Defina KC(i)	(k+GETARG_C(i))
#Defina RKC(i)	((TESTARG_k(i)) ? k + GETARG_C(i) : s2v(base + GETARG_C(i)))



#Defina updatetrap(ci)  (trap = ci->u.l.trap)

#Defina updatebase(ci)	(base = ci->func.p + 1)


#Defina updatestack(ci)  \
	{ Se (l_unlikely(trap)) { updatebase(ci); ra = RA(i); } }


/*
** Execute a jump instruction. The 'updatetrap' allows signals to stop
** tight loops. (Without it, the local copy of 'trap' could never change.)
*/
#Defina dojump(ci,i,e)	{ pc += GETARG_sJ(i) + e; updatetrap(ci); }


/* Para test instructions, execute the jump instruction that follows it */
#Defina donextjump(ci)	{ Instruction ni = *pc; dojump(ci, ni, 1); }

/*
** Faça a conditional jump: skip next instruction Se 'cond' is not what
** was expected (parameter 'k'), Senão Faça next instruction, which must
** be a jump.
*/
#Defina docondjump()	Se (cond != GETARG_k(i)) pc++; Senão donextjump(ci);


/*
** Correct global 'pc'.
*/
#Defina savepc(ci)	(ci->u.l.savedpc = pc)


/*
** Whenever code can raise errors, the global 'pc' and the global
** 'top' must be correct to report occasional errors.
*/
#Defina savestate(L,ci)		(savepc(ci), L->top.p = ci->top.p)


/*
** Protect code that, in general, can raise errors, reallocate the
** stack, and change the hooks.
*/
#Defina Protect(exp)  (savestate(L,ci), (exp), updatetrap(ci))

/* special version that does not change the top */
#Defina ProtectNT(exp)  (savepc(ci), (exp), updatetrap(ci))

/*
** Protect code that can only raise errors. (That is, it cannot change
** the stack or hooks.)
*/
#Defina halfProtect(exp)  (savestate(L,ci), (exp))

/*
** macro executed during Sol functions at points where the
** function can yield.
*/
#Se !Definido(sol_threadyield)
#Defina sol_threadyield(L)	{sol_unlock(L); sol_lock(L);}
#FimSe

/* 'c' is the limit of live values in the stack */
#Defina checkGC(L,c)  \
	{ sol_c_condGC(L, (savepc(ci), L->top.p = (c)), \
                         updatetrap(ci)); \
           sol_threadyield(L); }


/* fetch an instruction and prepare its execution */
#Defina vmfetch()	{ \
  Se (l_unlikely(trap)) {  /* stack reallocation or hooks? */ \
    trap = sol_g_traceexec(L, pc);  /* handle hooks */ \
    updatebase(ci);  /* correct stack */ \
  } \
  i = *(pc++); \
}

#Defina vmdispatch(o)	Troque(o)
#Defina vmcase(l)	Caso l:
#Defina vmbreak		Interrompa


Vazio sol_v_execute (sol_State *L, CallInfo *ci) {
  LClosure *cl;
  TValue *k;
  StkId base;
  Imutável Instruction *pc;
  Inteiro trap;
#Se SOL_USE_JUMPTABLE
#Inclua "jumptab.int"
#FimSe
 startfunc:
  trap = L->hookmask;
 returning:  /* trap already set */
  cl = ci_func(ci);
  k = cl->p->k;
  pc = ci->u.l.savedpc;
  Se (l_unlikely(trap))
    trap = sol_g_tracecall(L);
  base = ci->func.p + 1;
  /* main loop of interpreter */
  Para (;;) {
    Instruction i;  /* instruction being executed */
    vmfetch();
    #Se 0
    { /* low-level Linha tracing Para debugging Sol */
      #Inclua "opnames.int"
      Inteiro pcrel = pcRel(pc, cl->p);
      printf("Linha: %d; %s (%d)\n", sol_g_getfuncline(cl->p, pcrel),
             opnames[GET_OPCODE(i)], pcrel);
    }
    #FimSe
    sol_assert(base == ci->func.p + 1);
    sol_assert(base <= L->top.p && L->top.p <= L->stack_last.p);
    /* Para tests, invalidate top Para instructions not expecting it */
    sol_assert(sol_p_isIT(i) || (cast_void(L->top.p = base), 1));
    vmdispatch (GET_OPCODE(i)) {
      vmcase(OP_MOVE) {
        StkId ra = RA(i);
        setobjs2s(L, ra, RB(i));
        vmbreak;
      }
      vmcase(OP_LOADI) {
        StkId ra = RA(i);
        sol_Integer b = GETARG_sBx(i);
        setivalue(s2v(ra), b);
        vmbreak;
      }
      vmcase(OP_LOADF) {
        StkId ra = RA(i);
        Inteiro b = GETARG_sBx(i);
        setfltvalue(s2v(ra), cast_num(b));
        vmbreak;
      }
      vmcase(OP_LOADK) {
        StkId ra = RA(i);
        TValue *rb = k + GETARG_Bx(i);
        setobj2s(L, ra, rb);
        vmbreak;
      }
      vmcase(OP_LOADKX) {
        StkId ra = RA(i);
        TValue *rb;
        rb = k + GETARG_Ax(*pc); pc++;
        setobj2s(L, ra, rb);
        vmbreak;
      }
      vmcase(OP_LOADFALSE) {
        StkId ra = RA(i);
        setbfvalue(s2v(ra));
        vmbreak;
      }
      vmcase(OP_LFALSESKIP) {
        StkId ra = RA(i);
        setbfvalue(s2v(ra));
        pc++;  /* skip next instruction */
        vmbreak;
      }
      vmcase(OP_LOADTRUE) {
        StkId ra = RA(i);
        setbtvalue(s2v(ra));
        vmbreak;
      }
      vmcase(OP_LOADNIL) {
        StkId ra = RA(i);
        Inteiro b = GETARG_B(i);
        Faça {
          setnilvalue(s2v(ra++));
        } Enquanto (b--);
        vmbreak;
      }
      vmcase(OP_GETUPVAL) {
        StkId ra = RA(i);
        Inteiro b = GETARG_B(i);
        setobj2s(L, ra, cl->upvals[b]->v.p);
        vmbreak;
      }
      vmcase(OP_SETUPVAL) {
        StkId ra = RA(i);
        UpVal *uv = cl->upvals[GETARG_B(i)];
        setobj(L, uv->v.p, s2v(ra));
        sol_c_barrier(L, uv, s2v(ra));
        vmbreak;
      }
      vmcase(OP_GETTABUP) {
        StkId ra = RA(i);
        TValue *upval = cl->upvals[GETARG_B(i)]->v.p;
        TValue *rc = KC(i);
        TString *key = tsvalue(rc);  /* key must be a Curto string */
        lu_byte tag;
        sol_v_fastget(upval, key, s2v(ra), sol_h_getshortstr, tag);
        Se (tagisempty(tag))
          Protect(sol_v_finishget(L, upval, rc, ra, tag));
        vmbreak;
      }
      vmcase(OP_GETTABLE) {
        StkId ra = RA(i);
        TValue *rb = vRB(i);
        TValue *rc = vRC(i);
        lu_byte tag;
        Se (ttisinteger(rc)) {  /* fast track Para integers? */
          sol_v_fastgeti(rb, ivalue(rc), s2v(ra), tag);
        }
        Senão
          sol_v_fastget(rb, rc, s2v(ra), sol_h_get, tag);
        Se (tagisempty(tag))
          Protect(sol_v_finishget(L, rb, rc, ra, tag));
        vmbreak;
      }
      vmcase(OP_GETI) {
        StkId ra = RA(i);
        TValue *rb = vRB(i);
        Inteiro c = GETARG_C(i);
        lu_byte tag;
        sol_v_fastgeti(rb, c, s2v(ra), tag);
        Se (tagisempty(tag)) {
          TValue key;
          setivalue(&key, c);
          Protect(sol_v_finishget(L, rb, &key, ra, tag));
        }
        vmbreak;
      }
      vmcase(OP_GETFIELD) {
        StkId ra = RA(i);
        TValue *rb = vRB(i);
        TValue *rc = KC(i);
        TString *key = tsvalue(rc);  /* key must be a Curto string */
        lu_byte tag;
        sol_v_fastget(rb, key, s2v(ra), sol_h_getshortstr, tag);
        Se (tagisempty(tag))
          Protect(sol_v_finishget(L, rb, rc, ra, tag));
        vmbreak;
      }
      vmcase(OP_SETTABUP) {
        Inteiro hres;
        TValue *upval = cl->upvals[GETARG_A(i)]->v.p;
        TValue *rb = KB(i);
        TValue *rc = RKC(i);
        TString *key = tsvalue(rb);  /* key must be a Curto string */
        sol_v_fastset(upval, key, rc, hres, sol_h_psetshortstr);
        Se (hres == HOK)
          sol_v_finishfastset(L, upval, rc);
        Senão
          Protect(sol_v_finishset(L, upval, rb, rc, hres));
        vmbreak;
      }
      vmcase(OP_SETTABLE) {
        StkId ra = RA(i);
        Inteiro hres;
        TValue *rb = vRB(i);  /* key (table is in 'ra') */
        TValue *rc = RKC(i);  /* value */
        Se (ttisinteger(rb)) {  /* fast track Para integers? */
          sol_v_fastseti(s2v(ra), ivalue(rb), rc, hres);
        }
        Senão {
          sol_v_fastset(s2v(ra), rb, rc, hres, sol_h_pset);
        }
        Se (hres == HOK)
          sol_v_finishfastset(L, s2v(ra), rc);
        Senão
          Protect(sol_v_finishset(L, s2v(ra), rb, rc, hres));
        vmbreak;
      }
      vmcase(OP_SETI) {
        StkId ra = RA(i);
        Inteiro hres;
        Inteiro b = GETARG_B(i);
        TValue *rc = RKC(i);
        sol_v_fastseti(s2v(ra), b, rc, hres);
        Se (hres == HOK)
          sol_v_finishfastset(L, s2v(ra), rc);
        Senão {
          TValue key;
          setivalue(&key, b);
          Protect(sol_v_finishset(L, s2v(ra), &key, rc, hres));
        }
        vmbreak;
      }
      vmcase(OP_SETFIELD) {
        StkId ra = RA(i);
        Inteiro hres;
        TValue *rb = KB(i);
        TValue *rc = RKC(i);
        TString *key = tsvalue(rb);  /* key must be a Curto string */
        sol_v_fastset(s2v(ra), key, rc, hres, sol_h_psetshortstr);
        Se (hres == HOK)
          sol_v_finishfastset(L, s2v(ra), rc);
        Senão
          Protect(sol_v_finishset(L, s2v(ra), rb, rc, hres));
        vmbreak;
      }
      vmcase(OP_NEWTABLE) {
        StkId ra = RA(i);
        Natural b = cast_uint(GETARG_vB(i));  /* log2(hash size) + 1 */
        Natural c = cast_uint(GETARG_vC(i));  /* array size */
        Table *t;
        Se (b > 0)
          b = 1u << (b - 1);  /* hash size is 2^(b - 1) */
        Se (TESTARG_k(i)) {  /* non-zero extra argument? */
          sol_assert(GETARG_Ax(*pc) != 0);
          /* add it to array size */
          c += cast_uint(GETARG_Ax(*pc)) * (MAXARG_vC + 1);
        }
        pc++;  /* skip extra argument */
        L->top.p = ra + 1;  /* correct top in Caso of emergency GC */
        t = sol_h_new(L);  /* memory allocation */
        sethvalue2s(L, ra, t);
        Se (b != 0 || c != 0)
          sol_h_resize(L, t, c, b);  /* idem */
        checkGC(L, ra + 1);
        vmbreak;
      }
      vmcase(OP_SELF) {
        StkId ra = RA(i);
        lu_byte tag;
        TValue *rb = vRB(i);
        TValue *rc = KC(i);
        TString *key = tsvalue(rc);  /* key must be a Curto string */
        setobj2s(L, ra + 1, rb);
        sol_v_fastget(rb, key, s2v(ra), sol_h_getshortstr, tag);
        Se (tagisempty(tag))
          Protect(sol_v_finishget(L, rb, rc, ra, tag));
        vmbreak;
      }
      vmcase(OP_ADDI) {
        op_arithI(L, l_addi, sol_numadd);
        vmbreak;
      }
      vmcase(OP_ADDK) {
        op_arithK(L, l_addi, sol_numadd);
        vmbreak;
      }
      vmcase(OP_SUBK) {
        op_arithK(L, l_subi, sol_numsub);
        vmbreak;
      }
      vmcase(OP_MULK) {
        op_arithK(L, l_muli, sol_nummul);
        vmbreak;
      }
      vmcase(OP_MODK) {
        savestate(L, ci);  /* in Caso of division by 0 */
        op_arithK(L, sol_v_mod, sol_v_modf);
        vmbreak;
      }
      vmcase(OP_POWK) {
        op_arithfK(L, sol_numpow);
        vmbreak;
      }
      vmcase(OP_DIVK) {
        op_arithfK(L, sol_numdiv);
        vmbreak;
      }
      vmcase(OP_IDIVK) {
        savestate(L, ci);  /* in Caso of division by 0 */
        op_arithK(L, sol_v_idiv, sol_numidiv);
        vmbreak;
      }
      vmcase(OP_BANDK) {
        op_bitwiseK(L, l_band);
        vmbreak;
      }
      vmcase(OP_BORK) {
        op_bitwiseK(L, l_bor);
        vmbreak;
      }
      vmcase(OP_BXORK) {
        op_bitwiseK(L, l_bxor);
        vmbreak;
      }
      vmcase(OP_SHLI) {
        StkId ra = RA(i);
        TValue *rb = vRB(i);
        Inteiro ic = GETARG_sC(i);
        sol_Integer ib;
        Se (tointegerns(rb, &ib)) {
          pc++; setivalue(s2v(ra), sol_v_shiftl(ic, ib));
        }
        vmbreak;
      }
      vmcase(OP_SHRI) {
        StkId ra = RA(i);
        TValue *rb = vRB(i);
        Inteiro ic = GETARG_sC(i);
        sol_Integer ib;
        Se (tointegerns(rb, &ib)) {
          pc++; setivalue(s2v(ra), sol_v_shiftl(ib, -ic));
        }
        vmbreak;
      }
      vmcase(OP_ADD) {
        op_arith(L, l_addi, sol_numadd);
        vmbreak;
      }
      vmcase(OP_SUB) {
        op_arith(L, l_subi, sol_numsub);
        vmbreak;
      }
      vmcase(OP_MUL) {
        op_arith(L, l_muli, sol_nummul);
        vmbreak;
      }
      vmcase(OP_MOD) {
        savestate(L, ci);  /* in Caso of division by 0 */
        op_arith(L, sol_v_mod, sol_v_modf);
        vmbreak;
      }
      vmcase(OP_POW) {
        op_arithf(L, sol_numpow);
        vmbreak;
      }
      vmcase(OP_DIV) {  /* Real division (always with floats) */
        op_arithf(L, sol_numdiv);
        vmbreak;
      }
      vmcase(OP_IDIV) {  /* floor division */
        savestate(L, ci);  /* in Caso of division by 0 */
        op_arith(L, sol_v_idiv, sol_numidiv);
        vmbreak;
      }
      vmcase(OP_BAND) {
        op_bitwise(L, l_band);
        vmbreak;
      }
      vmcase(OP_BOR) {
        op_bitwise(L, l_bor);
        vmbreak;
      }
      vmcase(OP_BXOR) {
        op_bitwise(L, l_bxor);
        vmbreak;
      }
      vmcase(OP_SHL) {
        op_bitwise(L, sol_v_shiftl);
        vmbreak;
      }
      vmcase(OP_SHR) {
        op_bitwise(L, sol_v_shiftr);
        vmbreak;
      }
      vmcase(OP_MMBIN) {
        StkId ra = RA(i);
        Instruction pi = *(pc - 2);  /* original arith. expression */
        TValue *rb = vRB(i);
        TMS tm = (TMS)GETARG_C(i);
        StkId result = RA(pi);
        sol_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);
        Protect(sol_t_trybinTM(L, s2v(ra), rb, result, tm));
        vmbreak;
      }
      vmcase(OP_MMBINI) {
        StkId ra = RA(i);
        Instruction pi = *(pc - 2);  /* original arith. expression */
        Inteiro imm = GETARG_sB(i);
        TMS tm = (TMS)GETARG_C(i);
        Inteiro flip = GETARG_k(i);
        StkId result = RA(pi);
        Protect(sol_t_trybiniTM(L, s2v(ra), imm, flip, result, tm));
        vmbreak;
      }
      vmcase(OP_MMBINK) {
        StkId ra = RA(i);
        Instruction pi = *(pc - 2);  /* original arith. expression */
        TValue *imm = KB(i);
        TMS tm = (TMS)GETARG_C(i);
        Inteiro flip = GETARG_k(i);
        StkId result = RA(pi);
        Protect(sol_t_trybinassocTM(L, s2v(ra), imm, flip, result, tm));
        vmbreak;
      }
      vmcase(OP_UNM) {
        StkId ra = RA(i);
        TValue *rb = vRB(i);
        sol_Number nb;
        Se (ttisinteger(rb)) {
          sol_Integer ib = ivalue(rb);
          setivalue(s2v(ra), intop(-, 0, ib));
        }
        Senão Se (tonumberns(rb, nb)) {
          setfltvalue(s2v(ra), sol_numunm(L, nb));
        }
        Senão
          Protect(sol_t_trybinTM(L, rb, rb, ra, TM_UNM));
        vmbreak;
      }
      vmcase(OP_BNOT) {
        StkId ra = RA(i);
        TValue *rb = vRB(i);
        sol_Integer ib;
        Se (tointegerns(rb, &ib)) {
          setivalue(s2v(ra), intop(^, ~l_castS2U(0), ib));
        }
        Senão
          Protect(sol_t_trybinTM(L, rb, rb, ra, TM_BNOT));
        vmbreak;
      }
      vmcase(OP_NOT) {
        StkId ra = RA(i);
        TValue *rb = vRB(i);
        Se (l_isfalse(rb))
          setbtvalue(s2v(ra));
        Senão
          setbfvalue(s2v(ra));
        vmbreak;
      }
      vmcase(OP_LEN) {
        StkId ra = RA(i);
        Protect(sol_v_objlen(L, ra, vRB(i)));
        vmbreak;
      }
      vmcase(OP_CONCAT) {
        StkId ra = RA(i);
        Inteiro n = GETARG_B(i);  /* number of elements to concatenate */
        L->top.p = ra + n;  /* mark the end of concat operands */
        ProtectNT(sol_v_concat(L, n));
        checkGC(L, L->top.p); /* 'sol_v_concat' ensures correct top */
        vmbreak;
      }
      vmcase(OP_CLOSE) {
        StkId ra = RA(i);
        sol_assert(!GETARG_B(i));  /* 'close must be alive */
        Protect(sol_f_close(L, ra, SOL_OK, 1));
        vmbreak;
      }
      vmcase(OP_TBC) {
        StkId ra = RA(i);
        /* create new to-be-closed upvalue */
        halfProtect(sol_f_newtbcupval(L, ra));
        vmbreak;
      }
      vmcase(OP_JMP) {
        dojump(ci, i, 0);
        vmbreak;
      }
      vmcase(OP_EQ) {
        StkId ra = RA(i);
        Inteiro cond;
        TValue *rb = vRB(i);
        Protect(cond = sol_v_equalobj(L, s2v(ra), rb));
        docondjump();
        vmbreak;
      }
      vmcase(OP_LT) {
        op_order(L, l_lti, LTnum, lessthanothers);
        vmbreak;
      }
      vmcase(OP_LE) {
        op_order(L, l_lei, LEnum, lessequalothers);
        vmbreak;
      }
      vmcase(OP_EQK) {
        StkId ra = RA(i);
        TValue *rb = KB(i);
        /* basic types Faça not use '__eq'; we can use raw equality */
        Inteiro cond = sol_v_rawequalobj(s2v(ra), rb);
        docondjump();
        vmbreak;
      }
      vmcase(OP_EQI) {
        StkId ra = RA(i);
        Inteiro cond;
        Inteiro im = GETARG_sB(i);
        Se (ttisinteger(s2v(ra)))
          cond = (ivalue(s2v(ra)) == im);
        Senão Se (ttisfloat(s2v(ra)))
          cond = sol_numeq(fltvalue(s2v(ra)), cast_num(im));
        Senão
          cond = 0;  /* other types cannot be equal to a number */
        docondjump();
        vmbreak;
      }
      vmcase(OP_LTI) {
        op_orderI(L, l_lti, sol_numlt, 0, TM_LT);
        vmbreak;
      }
      vmcase(OP_LEI) {
        op_orderI(L, l_lei, sol_numle, 0, TM_LE);
        vmbreak;
      }
      vmcase(OP_GTI) {
        op_orderI(L, l_gti, sol_numgt, 1, TM_LT);
        vmbreak;
      }
      vmcase(OP_GEI) {
        op_orderI(L, l_gei, sol_numge, 1, TM_LE);
        vmbreak;
      }
      vmcase(OP_TEST) {
        StkId ra = RA(i);
        Inteiro cond = !l_isfalse(s2v(ra));
        docondjump();
        vmbreak;
      }
      vmcase(OP_TESTSET) {
        StkId ra = RA(i);
        TValue *rb = vRB(i);
        Se (l_isfalse(rb) == GETARG_k(i))
          pc++;
        Senão {
          setobj2s(L, ra, rb);
          donextjump(ci);
        }
        vmbreak;
      }
      vmcase(OP_CALL) {
        StkId ra = RA(i);
        CallInfo *newci;
        Inteiro b = GETARG_B(i);
        Inteiro nresults = GETARG_C(i) - 1;
        Se (b != 0)  /* fixed number of arguments? */
          L->top.p = ra + b;  /* top signals number of arguments */
        /* Senão previous instruction set top */
        savepc(ci);  /* in Caso of errors */
        Se ((newci = sol_d_precall(L, ra, nresults)) == NULL)
          updatetrap(ci);  /* C call; nothing Senão to be done */
        Senão {  /* Sol call: run function in this same C frame */
          ci = newci;
          Execute startfunc;
        }
        vmbreak;
      }
      vmcase(OP_TAILCALL) {
        StkId ra = RA(i);
        Inteiro b = GETARG_B(i);  /* number of arguments + 1 (function) */
        Inteiro n;  /* number of results when calling a C function */
        Inteiro nparams1 = GETARG_C(i);
        /* delta is virtual 'func' - real 'func' (vararg functions) */
        Inteiro delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
        Se (b != 0)
          L->top.p = ra + b;
        Senão  /* previous instruction set top */
          b = cast_int(L->top.p - ra);
        savepc(ci);  /* several calls here can raise errors */
        Se (TESTARG_k(i)) {
          sol_f_closeupval(L, base);  /* close upvalues from current call */
          sol_assert(L->tbclist.p < base);  /* no pending tbc variables */
          sol_assert(base == ci->func.p + 1);
        }
        Se ((n = sol_d_pretailcall(L, ci, ra, b, delta)) < 0)  /* Sol function? */
          Execute startfunc;  /* execute the callee */
        Senão {  /* C function? */
          ci->func.p -= delta;  /* restore 'func' (Se vararg) */
          sol_d_poscall(L, ci, n);  /* finish caller */
          updatetrap(ci);  /* 'sol_d_poscall' can change hooks */
          Execute ret;  /* caller returns after the tail call */
        }
      }
      vmcase(OP_RETURN) {
        StkId ra = RA(i);
        Inteiro n = GETARG_B(i) - 1;  /* number of results */
        Inteiro nparams1 = GETARG_C(i);
        Se (n < 0)  /* not fixed? */
          n = cast_int(L->top.p - ra);  /* get what is available */
        savepc(ci);
        Se (TESTARG_k(i)) {  /* may there be open upvalues? */
          ci->u2.nres = n;  /* save number of returns */
          Se (L->top.p < ci->top.p)
            L->top.p = ci->top.p;
          sol_f_close(L, base, CLOSEKTOP, 1);
          updatetrap(ci);
          updatestack(ci);
        }
        Se (nparams1)  /* vararg function? */
          ci->func.p -= ci->u.l.nextraargs + nparams1;
        L->top.p = ra + n;  /* set call Para 'sol_d_poscall' */
        sol_d_poscall(L, ci, n);
        updatetrap(ci);  /* 'sol_d_poscall' can change hooks */
        Execute ret;
      }
      vmcase(OP_RETURN0) {
        Se (l_unlikely(L->hookmask)) {
          StkId ra = RA(i);
          L->top.p = ra;
          savepc(ci);
          sol_d_poscall(L, ci, 0);  /* no hurry... */
          trap = 1;
        }
        Senão {  /* Faça the 'poscall' here */
          Inteiro nres = get_nresults(ci->callstatus);
          L->ci = ci->previous;  /* back to caller */
          L->top.p = base - 1;
          Para (; l_unlikely(nres > 0); nres--)
            setnilvalue(s2v(L->top.p++));  /* all results are nil */
        }
        Execute ret;
      }
      vmcase(OP_RETURN1) {
        Se (l_unlikely(L->hookmask)) {
          StkId ra = RA(i);
          L->top.p = ra + 1;
          savepc(ci);
          sol_d_poscall(L, ci, 1);  /* no hurry... */
          trap = 1;
        }
        Senão {  /* Faça the 'poscall' here */
          Inteiro nres = get_nresults(ci->callstatus);
          L->ci = ci->previous;  /* back to caller */
          Se (nres == 0)
            L->top.p = base - 1;  /* asked Para no results */
          Senão {
            StkId ra = RA(i);
            setobjs2s(L, base - 1, ra);  /* at least this result */
            L->top.p = base;
            Para (; l_unlikely(nres > 1); nres--)
              setnilvalue(s2v(L->top.p++));  /* complete missing results */
          }
        }
       ret:  /* Retorne from a Sol function */
        Se (ci->callstatus & CIST_FRESH)
          Retorne;  /* end this frame */
        Senão {
          ci = ci->previous;
          Execute returning;  /* Continue running caller in this frame */
        }
      }
      vmcase(OP_FORLOOP) {
        StkId ra = RA(i);
        Se (ttisinteger(s2v(ra + 1))) {  /* integer loop? */
          sol_Unsigned count = l_castS2U(ivalue(s2v(ra)));
          Se (count > 0) {  /* still more iterations? */
            sol_Integer step = ivalue(s2v(ra + 1));
            sol_Integer idx = ivalue(s2v(ra + 2));  /* control variable */
            chgivalue(s2v(ra), l_castU2S(count - 1));  /* update counter */
            idx = intop(+, idx, step);  /* add step to index */
            chgivalue(s2v(ra + 2), idx);  /* update control variable */
            pc -= GETARG_Bx(i);  /* jump back */
          }
        }
        Senão Se (floatforloop(ra))  /* Real loop */
          pc -= GETARG_Bx(i);  /* jump back */
        updatetrap(ci);  /* allows a signal to Interrompa the loop */
        vmbreak;
      }
      vmcase(OP_FORPREP) {
        StkId ra = RA(i);
        savestate(L, ci);  /* in Caso of errors */
        Se (forprep(L, ra))
          pc += GETARG_Bx(i) + 1;  /* skip the loop */
        vmbreak;
      }
      vmcase(OP_TFORPREP) {
       /* before: 'ra' has the iterator function, 'ra + 1' has the state,
          'ra + 2' has the initial value Para the control variable, and
          'ra + 3' has the closing variable. This opcode then swaps the
          control and the closing variables and marks the closing variable
          as to-be-closed.
       */
       StkId ra = RA(i);
       TValue temp;  /* to swap control and closing variables */
       setobj(L, &temp, s2v(ra + 3));
       setobjs2s(L, ra + 3, ra + 2);
       setobj2s(L, ra + 2, &temp);
        /* create to-be-closed upvalue (Se closing var. is not nil) */
        halfProtect(sol_f_newtbcupval(L, ra + 2));
        pc += GETARG_Bx(i);  /* go to end of the loop */
        i = *(pc++);  /* fetch next instruction */
        sol_assert(GET_OPCODE(i) == OP_TFORCALL && ra == RA(i));
        Execute l_tforcall;
      }
      vmcase(OP_TFORCALL) {
       l_tforcall: {
        /* 'ra' has the iterator function, 'ra + 1' has the state,
           'ra + 2' has the closing variable, and 'ra + 3' has the control
           variable. The call will use the stack starting at 'ra + 3',
           so that it preserves the first three values, and the first
           Retorne will be the new value Para the control variable.
        */
        StkId ra = RA(i);
        setobjs2s(L, ra + 5, ra + 3);  /* copy the control variable */
        setobjs2s(L, ra + 4, ra + 1);  /* copy state */
        setobjs2s(L, ra + 3, ra);  /* copy function */
        L->top.p = ra + 3 + 3;
        ProtectNT(sol_d_call(L, ra + 3, GETARG_C(i)));  /* Faça the call */
        updatestack(ci);  /* stack may have changed */
        i = *(pc++);  /* go to next instruction */
        sol_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));
        Execute l_tforloop;
      }}
      vmcase(OP_TFORLOOP) {
       l_tforloop: {
        StkId ra = RA(i);
        Se (!ttisnil(s2v(ra + 3)))  /* Continue loop? */
          pc -= GETARG_Bx(i);  /* jump back */
        vmbreak;
      }}
      vmcase(OP_SETLIST) {
        StkId ra = RA(i);
        Natural n = cast_uint(GETARG_vB(i));
        Natural last = cast_uint(GETARG_vC(i));
        Table *h = hvalue(s2v(ra));
        Se (n == 0)
          n = cast_uint(L->top.p - ra) - 1;  /* get up to the top */
        Senão
          L->top.p = ci->top.p;  /* correct top in Caso of emergency GC */
        last += n;
        Se (TESTARG_k(i)) {
          last += cast_uint(GETARG_Ax(*pc)) * (MAXARG_vC + 1);
          pc++;
        }
        /* when 'n' is known, table should have proper size */
        Se (last > h->asize) {  /* needs more space? */
          /* fixed-size sets should have space preallocated */
          sol_assert(GETARG_vB(i) == 0);
          sol_h_resizearray(L, h, last);  /* preallocate it at once */
        }
        Para (; n > 0; n--) {
          TValue *val = s2v(ra + n);
          obj2arr(h, last - 1, val);
          last--;
          sol_c_barrierback(L, obj2gco(h), val);
        }
        vmbreak;
      }
      vmcase(OP_CLOSURE) {
        StkId ra = RA(i);
        Proto *p = cl->p->p[GETARG_Bx(i)];
        halfProtect(pushclosure(L, p, cl->upvals, base, ra));
        checkGC(L, ra + 1);
        vmbreak;
      }
      vmcase(OP_VARARG) {
        StkId ra = RA(i);
        Inteiro n = GETARG_C(i) - 1;  /* required results */
        Protect(sol_t_getvarargs(L, ci, ra, n));
        vmbreak;
      }
      vmcase(OP_VARARGPREP) {
        ProtectNT(sol_t_adjustvarargs(L, GETARG_A(i), ci, cl->p));
        Se (l_unlikely(trap)) {  /* previous "Protect" updated trap */
          sol_d_hookcall(L, ci);
          L->oldpc = 1;  /* next opcode will be seen as a "new" Linha */
        }
        updatebase(ci);  /* function has new base after adjustment */
        vmbreak;
      }
      vmcase(OP_EXTRAARG) {
        sol_assert(0);
        vmbreak;
      }
    }
  }
}

/* }================================================================== */
