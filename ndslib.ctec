/*
** ndslib.ctec - Biblioteca NDS (Notação de Dados Sol)
** Fornece funções para ler, analisar, converter e exportar dados NDS
*/

#Defina ndslib_c
#Defina SOL_LIB

#Inclua "prefix.int"

#Inclua <stdio.h>
#Inclua <stdlib.h>
#Inclua <string.h>
#Inclua <ctype.h>

#Inclua "sol.int"
#Inclua "auxlib.int"
#Inclua "solib.int"

#Defina CaractereNãoSinalizado Natural Caractere


/* ============================================================
** Helpers para serialização
** ============================================================ */

/* Buffer dinâmico para construir strings */
Pseudônimo Estrutura {
    Caractere *data;
    size_t len;
    size_t cap;
} NdsBuffer;

Fixo Vazio nds_buf_init(NdsBuffer *b) {
    b->cap = 256;
    b->data = (Caractere*)malloc(b->cap);
    b->data[0] = '\0';
    b->len = 0;
}

Fixo Vazio nds_buf_free(NdsBuffer *b) {
    Se (b->data) free(b->data);
    b->data = NULL;
    b->len = b->cap = 0;
}

Fixo Vazio nds_buf_grow(NdsBuffer *b, size_t need) {
    Se (b->len + need + 1 > b->cap) {
        b->cap = (b->len + need + 1) * 2;
        b->data = (Caractere*)realloc(b->data, b->cap);
    }
}

Fixo Vazio nds_buf_append(NdsBuffer *b, Imutável Caractere *s) {
    size_t slen = strlen(s);
    nds_buf_grow(b, slen);
    memcpy(b->data + b->len, s, slen);
    b->len += slen;
    b->data[b->len] = '\0';
}

Fixo Vazio nds_buf_append_char(NdsBuffer *b, Caractere c) {
    nds_buf_grow(b, 1);
    b->data[b->len++] = c;
    b->data[b->len] = '\0';
}

Fixo Vazio nds_buf_append_escaped(NdsBuffer *b, Imutável Caractere *s) {
    nds_buf_append_char(b, '"');
    Para (; *s; s++) {
        Troque (*s) {
            Caso '\n': nds_buf_append(b, "\\n"); Interrompa;
            Caso '\r': nds_buf_append(b, "\\r"); Interrompa;
            Caso '\t': nds_buf_append(b, "\\t"); Interrompa;
            Caso '\\': nds_buf_append(b, "\\\\"); Interrompa;
            Caso '"': nds_buf_append(b, "\\\""); Interrompa;
            Padrão: nds_buf_append_char(b, *s); Interrompa;
        }
    }
    nds_buf_append_char(b, '"');
}

/* Verifica se é identificador válido */
Fixo Inteiro nds_is_valid_id(Imutável Caractere *s) {
    Se (!s || !*s) Retorne 0;
    Se (!isalpha((CaractereNãoSinalizado)*s) && *s != '_') Retorne 0;
    Para (s++; *s; s++) {
        Se (!isalnum((CaractereNãoSinalizado)*s) && *s != '_') Retorne 0;
    }
    Retorne 1;
}

/* Forward declaration */
Fixo Vazio nds_serialize_value(sol_State *L, Inteiro idx, NdsBuffer *b, Inteiro indent, Inteiro pretty);

/* Serializa tabela */
Fixo Vazio nds_serialize_table(sol_State *L, Inteiro idx, NdsBuffer *b, Inteiro indent, Inteiro pretty) {
    Inteiro is_array = 1;
    sol_Integer max_idx = 0;
    sol_Integer count = 0;
    
    /* Verifica se é array denso */
    sol_pushnil(L);
    Enquanto (sol_next(L, idx < 0 ? idx - 1 : idx)) {
        count++;
        Se (sol_type(L, -2) != SOL_TNUMBER) {
            is_array = 0;
        } Senão {
            sol_Integer k = sol_tointeger(L, -2);
            Se (k < 1 || k != (sol_Integer)sol_tonumber(L, -2)) is_array = 0;
            Se (k > max_idx) max_idx = k;
        }
        sol_pop(L, 1);
    }
    Se (count != max_idx) is_array = 0;
    
    nds_buf_append_char(b, '{');
    Se (pretty && count > 0) nds_buf_append_char(b, '\n');
    
    Inteiro first = 1;
    sol_pushnil(L);
    Enquanto (sol_next(L, idx < 0 ? idx - 1 : idx)) {
        Se (!first) {
            nds_buf_append_char(b, ',');
            Se (pretty) nds_buf_append_char(b, '\n');
        }
        first = 0;
        
        /* Indentação */
        Se (pretty) {
            Para (Inteiro i = 0; i < indent + 1; i++) nds_buf_append(b, "    ");
        }
        
        /* Chave (só se não for array) */
        Se (!is_array) {
            Se (sol_type(L, -2) == SOL_TSTRING) {
                Imutável Caractere *key = sol_tostring(L, -2);
                Se (nds_is_valid_id(key)) {
                    nds_buf_append(b, key);
                } Senão {
                    nds_buf_append_char(b, '[');
                    nds_buf_append_escaped(b, key);
                    nds_buf_append_char(b, ']');
                }
            } Senão Se (sol_type(L, -2) == SOL_TNUMBER) {
                Caractere num[32];
                snprintf(num, 32, "[%lld]", (Longo Longo)sol_tointeger(L, -2));
                nds_buf_append(b, num);
            }
            nds_buf_append(b, " = ");
        }
        
        /* Valor */
        nds_serialize_value(L, -1, b, indent + 1, pretty);
        sol_pop(L, 1);
    }
    
    Se (pretty && count > 0) {
        nds_buf_append_char(b, '\n');
        Para (Inteiro i = 0; i < indent; i++) nds_buf_append(b, "    ");
    }
    nds_buf_append_char(b, '}');
}

/* Serializa valor qualquer */
Fixo Vazio nds_serialize_value(sol_State *L, Inteiro idx, NdsBuffer *b, Inteiro indent, Inteiro pretty) {
    Inteiro t = sol_type(L, idx);
    
    Troque (t) {
        Caso SOL_TNIL:
            nds_buf_append(b, "nulo");
            Interrompa;
            
        Caso SOL_TBOOLEAN:
            nds_buf_append(b, sol_toboolean(L, idx) ? "verdadeiro" : "falso");
            Interrompa;
            
        Caso SOL_TNUMBER:
            Se (sol_isinteger(L, idx)) {
                Caractere num[32];
                snprintf(num, 32, "%lld", (Longo Longo)sol_tointeger(L, idx));
                nds_buf_append(b, num);
            } Senão {
                Caractere num[64];
                snprintf(num, 64, "%.14g", sol_tonumber(L, idx));
                nds_buf_append(b, num);
            }
            Interrompa;
            
        Caso SOL_TSTRING:
            nds_buf_append_escaped(b, sol_tostring(L, idx));
            Interrompa;
            
        Caso SOL_TTABLE:
            nds_serialize_table(L, idx, b, indent, pretty);
            Interrompa;
            
        Padrão:
            nds_buf_append(b, "nulo");
            Interrompa;
    }
}

/* ============================================================
** Funções expostas para Sol
** ============================================================ */

/*
** nds.carregue(texto) -> tabela
** Analisa string NDS e retorna tabela Sol
*/
Fixo Inteiro nds_parse(sol_State *L) {
    size_t len;
    Imutável Caractere *texto = sol_checklstring(L, 1, &len);
    
    /* Monta código: "retorne {" + texto + "}" */
    sol_Buffer buf;
    sol_buffinit(L, &buf);
    sol_addlstring(&buf, "retorne {", 9);
    sol_addlstring(&buf, texto, len);
    sol_addlstring(&buf, "}", 1);
    sol_pushresult(&buf);
    
    /* Compila e executa */
    Imutável Caractere *code = sol_tostring(L, -1);
    size_t code_len = sol_rawlen(L, -1);
    
    Se (sol_loadbuffer(L, code, code_len, "nds") != SOL_OK) {
        Retorne sol_error(L);
    }
    sol_remove(L, -2); /* remove string do código */
    
    Se (sol_pcall(L, 0, 1, 0) != SOL_OK) {
        Retorne sol_error(L);
    }
    
    Retorne 1;
}

/*
** nds.serialize(tabela, [pretty]) -> texto
** Converte tabela Sol para string NDS
*/
Fixo Inteiro nds_stringify(sol_State *L) {
    sol_checktype(L, 1, SOL_TTABLE);
    Inteiro pretty = sol_toboolean(L, 2);
    
    NdsBuffer b;
    nds_buf_init(&b);
    
    /* Serializa como conteúdo de arquivo (sem {} externo) */
    Inteiro first = 1;
    sol_pushnil(L);
    Enquanto (sol_next(L, 1)) {
        Se (!first) {
            nds_buf_append_char(&b, ',');
            Se (pretty) nds_buf_append_char(&b, '\n');
        }
        first = 0;
        
        /* Chave */
        Se (sol_type(L, -2) == SOL_TSTRING) {
            Imutável Caractere *key = sol_tostring(L, -2);
            Se (nds_is_valid_id(key)) {
                nds_buf_append(&b, key);
            } Senão {
                nds_buf_append_char(&b, '[');
                nds_buf_append_escaped(&b, key);
                nds_buf_append_char(&b, ']');
            }
        } Senão Se (sol_type(L, -2) == SOL_TNUMBER) {
            Caractere num[32];
            snprintf(num, 32, "[%lld]", (Longo Longo)sol_tointeger(L, -2));
            nds_buf_append(&b, num);
        }
        
        nds_buf_append(&b, "=");
        nds_serialize_value(L, -1, &b, 0, pretty);
        
        sol_pop(L, 1);
    }
    
    sol_pushlstring(L, b.data, b.len);
    nds_buf_free(&b);
    Retorne 1;
}

/*
** nds.carregue_arquivo(caminho) -> tabela, [erro]
** Lê arquivo NDS e retorna tabela
*/
Fixo Inteiro nds_load_file(sol_State *L) {
    Imutável Caractere *path = sol_checkstring(L, 1);
    
    FILE *f = fopen(path, "rb");
    Se (!f) {
        sol_pushnil(L);
        sol_pushfstring(L, "não foi possível abrir arquivo: %s", path);
        Retorne 2;
    }
    
    /* Lê conteúdo */
    fseek(f, 0, SEEK_END);
    Longo size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    Caractere *content = (Caractere*)malloc(size + 1);
    fread(content, 1, size, f);
    content[size] = '\0';
    fclose(f);
    
    /* Analisa */
    sol_pushlstring(L, content, size);
    free(content);
    
    sol_pushcfunction(L, nds_parse);
    sol_pushvalue(L, -2);
    Se (sol_pcall(L, 1, 1, 0) != SOL_OK) {
        sol_pushnil(L);
        sol_insert(L, -2);
        Retorne 2;
    }
    
    Retorne 1;
}

/*
** nds.salve(caminho, tabela, [pretty]) -> sucesso, [erro]
** Salva tabela em arquivo NDS
*/
Fixo Inteiro nds_save_file(sol_State *L) {
    Imutável Caractere *path = sol_checkstring(L, 1);
    sol_checktype(L, 2, SOL_TTABLE);
    Inteiro pretty = sol_toboolean(L, 3);
    
    /* Serializa */
    sol_pushcfunction(L, nds_stringify);
    sol_pushvalue(L, 2);
    sol_pushboolean(L, pretty);
    Se (sol_pcall(L, 2, 1, 0) != SOL_OK) {
        sol_pushboolean(L, 0);
        sol_insert(L, -2);
        Retorne 2;
    }
    
    size_t len;
    Imutável Caractere *content = sol_tolstring(L, -1, &len);
    
    /* Escreve */
    FILE *f = fopen(path, "wb");
    Se (!f) {
        sol_pushboolean(L, 0);
        sol_pushfstring(L, "não foi possível criar arquivo: %s", path);
        Retorne 2;
    }
    
    fwrite(content, 1, len, f);
    fclose(f);
    
    sol_pushboolean(L, 1);
    Retorne 1;
}

/*
** nds.codifique(tabela, [pretty]) -> texto
** Alias para serialize (nome mais intuitivo)
*/
Fixo Inteiro nds_encode(sol_State *L) {
    Retorne nds_stringify(L);
}

/*
** nds.decodifique(texto) -> tabela
** Alias para carregue (nome mais intuitivo)
*/
Fixo Inteiro nds_decode(sol_State *L) {
    Retorne nds_parse(L);
}


/* ============================================================
** Registro da biblioteca
** ============================================================ */

Fixo Imutável sol_Reg nds_funcs[] = {
    {"carregue", nds_parse},
    {"serialize", nds_stringify},
    {"carregue_arquivo", nds_load_file},
    {"salve", nds_save_file},
    {"codifique", nds_encode},
    {"decodifique", nds_decode},
    {NULL, NULL}
};

SOLMOD_API Inteiro solopen_nds(sol_State *L) {
    sol_newlib(L, nds_funcs);
    Retorne 1;
}
