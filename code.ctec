/*
** $Id: lcode.c $
** Code generator Para Sol
** See Copyright Notice in sol.h
*/

#Defina code_c
#Defina SOL_CORE

#Inclua "prefix.int"


#Inclua <float.h>
#Inclua <limits.h>
#Inclua <math.h>
#Inclua <stdlib.h>

#Inclua "sol.int"

#Inclua "code.int"
#Inclua "debug.int"
#Inclua "do.int"
#Inclua "gc.int"
#Inclua "lex.int"
#Inclua "mem.int"
#Inclua "object.int"
#Inclua "opcodes.int"
#Inclua "parser.int"
#Inclua "string.int"
#Inclua "table.int"
#Inclua "vm.int"


/* (note that expressions VJMP also have jumps.) */
#Defina hasjumps(e)	((e)->t != (e)->f)


Fixo Inteiro codesJ (FuncState *fs, OpCode o, Inteiro sj, Inteiro k);



/* semantic Erro */
l_noret sol_k_semerror (LexState *ls, Imutável Caractere *fmt, ...) {
  Imutável Caractere *msg;
  va_list argp;
  pushvfstring(ls->L, argp, fmt, msg);
  ls->t.token = 0;  /* remove "near <token>" from final message */
  sol_x_syntaxerror(ls, msg);
}


/*
** If expression is a numeric constant, fills 'v' with its value
** and returns 1. Otherwise, returns 0.
*/
Fixo Inteiro tonumeral (Imutável expdesc *e, TValue *v) {
  Se (hasjumps(e))
    Retorne 0;  /* not a numeral */
  Troque (e->k) {
    Caso VKINT:
      Se (v) setivalue(v, e->u.ival);
      Retorne 1;
    Caso VKFLT:
      Se (v) setfltvalue(v, e->u.nval);
      Retorne 1;
    Padrão: Retorne 0;
  }
}


/*
** Get the constant value from a constant expression
*/
Fixo TValue *const2val (FuncState *fs, Imutável expdesc *e) {
  sol_assert(e->k == VCONST);
  Retorne &fs->ls->dyd->actvar.arr[e->u.info].k;
}


/*
** If expression is a constant, fills 'v' with its value
** and returns 1. Otherwise, returns 0.
*/
Inteiro sol_k_exp2const (FuncState *fs, Imutável expdesc *e, TValue *v) {
  Se (hasjumps(e))
    Retorne 0;  /* not a constant */
  Troque (e->k) {
    Caso VFALSE:
      setbfvalue(v);
      Retorne 1;
    Caso VTRUE:
      setbtvalue(v);
      Retorne 1;
    Caso VNIL:
      setnilvalue(v);
      Retorne 1;
    Caso VKSTR: {
      setsvalue(fs->ls->L, v, e->u.strval);
      Retorne 1;
    }
    Caso VCONST: {
      setobj(fs->ls->L, v, const2val(fs, e));
      Retorne 1;
    }
    Padrão: Retorne tonumeral(e, v);
  }
}


/*
** Return the previous instruction of the current code. If there
** may be a jump target between the current instruction and the
** previous one, Retorne an invalid instruction (to avoid wrong
** optimizations).
*/
Fixo Instruction *previousinstruction (FuncState *fs) {
  Fixo Imutável Instruction invalidinstruction = ~(Instruction)0;
  Se (fs->pc > fs->lasttarget)
    Retorne &fs->f->code[fs->pc - 1];  /* previous instruction */
  Senão
    Retorne cast(Instruction*, &invalidinstruction);
}


/*
** Create a OP_LOADNIL instruction, but try to optimize: Se the previous
** instruction is also OP_LOADNIL and ranges are compatible, adjust
** range of previous instruction instead of emitting a new one. (For
** instance, 'local a; local b' will generate a single opcode.)
*/
Vazio sol_k_nil (FuncState *fs, Inteiro from, Inteiro n) {
  Inteiro l = from + n - 1;  /* last Registrador to set nil */
  Instruction *previous = previousinstruction(fs);
  Se (GET_OPCODE(*previous) == OP_LOADNIL) {  /* previous is LOADNIL? */
    Inteiro pfrom = GETARG_A(*previous);  /* get previous range */
    Inteiro pl = pfrom + GETARG_B(*previous);
    Se ((pfrom <= from && from <= pl + 1) ||
        (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */
      Se (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */
      Se (pl > l) l = pl;  /* l = max(l, pl) */
      SETARG_A(*previous, from);
      SETARG_B(*previous, l - from);
      Retorne;
    }  /* Senão go through */
  }
  sol_k_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  /* Senão no optimization */
}


/*
** Gets the destination address of a jump instruction. Used to traverse
** a list of jumps.
*/
Fixo Inteiro getjump (FuncState *fs, Inteiro pc) {
  Inteiro offset = GETARG_sJ(fs->f->code[pc]);
  Se (offset == NO_JUMP)  /* point to itself represents end of list */
    Retorne NO_JUMP;  /* end of list */
  Senão
    Retorne (pc+1)+offset;  /* turn offset into absolute position */
}


/*
** Fix jump instruction at position 'pc' to jump to 'dest'.
** (Jump addresses are relative in Sol)
*/
Fixo Vazio fixjump (FuncState *fs, Inteiro pc, Inteiro dest) {
  Instruction *jmp = &fs->f->code[pc];
  Inteiro offset = dest - (pc + 1);
  sol_assert(dest != NO_JUMP);
  Se (!(-OFFSET_sJ <= offset && offset <= MAXARG_sJ - OFFSET_sJ))
    sol_x_syntaxerror(fs->ls, "control structure too Longo");
  sol_assert(GET_OPCODE(*jmp) == OP_JMP);
  SETARG_sJ(*jmp, offset);
}


/*
** Concatenate jump-list 'l2' into jump-list 'l1'
*/
Vazio sol_k_concat (FuncState *fs, Inteiro *l1, Inteiro l2) {
  Se (l2 == NO_JUMP) Retorne;  /* nothing to concatenate? */
  Senão Se (*l1 == NO_JUMP)  /* no original list? */
    *l1 = l2;  /* 'l1' points to 'l2' */
  Senão {
    Inteiro list = *l1;
    Inteiro next;
    Enquanto ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */
      list = next;
    fixjump(fs, list, l2);  /* last element links to 'l2' */
  }
}


/*
** Create a jump instruction and Retorne its position, so its destination
** can be fixed later (with 'fixjump').
*/
Inteiro sol_k_jump (FuncState *fs) {
  Retorne codesJ(fs, OP_JMP, NO_JUMP, 0);
}


/*
** Code a 'Retorne' instruction
*/
Vazio sol_k_ret (FuncState *fs, Inteiro first, Inteiro nret) {
  OpCode op;
  Troque (nret) {
    Caso 0: op = OP_RETURN0; Interrompa;
    Caso 1: op = OP_RETURN1; Interrompa;
    Padrão: op = OP_RETURN; Interrompa;
  }
  sol_y_checklimit(fs, nret + 1, MAXARG_B, "returns");
  sol_k_codeABC(fs, op, first, nret + 1, 0);
}


/*
** Code a "conditional jump", that is, a test or comparison opcode
** followed by a jump. Return jump position.
*/
Fixo Inteiro condjump (FuncState *fs, OpCode op, Inteiro A, Inteiro B, Inteiro C, Inteiro k) {
  sol_k_codeABCk(fs, op, A, B, C, k);
  Retorne sol_k_jump(fs);
}


/*
** returns current 'pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
*/
Inteiro sol_k_getlabel (FuncState *fs) {
  fs->lasttarget = fs->pc;
  Retorne fs->pc;
}


/*
** Returns the position of the instruction "controlling" a given
** jump (that is, its condition), or the jump itself Se it is
** unconditional.
*/
Fixo Instruction *getjumpcontrol (FuncState *fs, Inteiro pc) {
  Instruction *pi = &fs->f->code[pc];
  Se (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))
    Retorne pi-1;
  Senão
    Retorne pi;
}


/*
** Patch destination Registrador Para a TESTSET instruction.
** If instruction in position 'node' is not a TESTSET, Retorne 0 ("fails").
** Otherwise, Se 'reg' is not 'NO_REG', set it as the destination
** Registrador. Otherwise, change instruction to a simple 'TEST' (produces
** no Registrador value)
*/
Fixo Inteiro patchtestreg (FuncState *fs, Inteiro node, Inteiro reg) {
  Instruction *i = getjumpcontrol(fs, node);
  Se (GET_OPCODE(*i) != OP_TESTSET)
    Retorne 0;  /* cannot patch other instructions */
  Se (reg != NO_REG && reg != GETARG_B(*i))
    SETARG_A(*i, reg);
  Senão {
     /* no Registrador to put value or Registrador already has the value;
        change instruction to simple test */
    *i = CREATE_ABCk(OP_TEST, GETARG_B(*i), 0, 0, GETARG_k(*i));
  }
  Retorne 1;
}


/*
** Traverse a list of tests ensuring no one produces a value
*/
Fixo Vazio removevalues (FuncState *fs, Inteiro list) {
  Para (; list != NO_JUMP; list = getjump(fs, list))
      patchtestreg(fs, list, NO_REG);
}


/*
** Traverse a list of tests, patching their destination address and
** registers: tests producing values jump to 'vtarget' (and put their
** values in 'reg'), other tests jump to 'dtarget'.
*/
Fixo Vazio patchlistaux (FuncState *fs, Inteiro list, Inteiro vtarget, Inteiro reg,
                          Inteiro dtarget) {
  Enquanto (list != NO_JUMP) {
    Inteiro next = getjump(fs, list);
    Se (patchtestreg(fs, list, reg))
      fixjump(fs, list, vtarget);
    Senão
      fixjump(fs, list, dtarget);  /* jump to Padrão target */
    list = next;
  }
}


/*
** Path all jumps in 'list' to jump to 'target'.
** (The assert means that we cannot fix a jump to a forward address
** because we only know addresses once code is generated.)
*/
Vazio sol_k_patchlist (FuncState *fs, Inteiro list, Inteiro target) {
  sol_assert(target <= fs->pc);
  patchlistaux(fs, list, target, NO_REG, target);
}


Vazio sol_k_patchtohere (FuncState *fs, Inteiro list) {
  Inteiro hr = sol_k_getlabel(fs);  /* mark "here" as a jump target */
  sol_k_patchlist(fs, list, hr);
}


/* limit Para difference between lines in relative Linha info. */
#Defina LIMLINEDIFF	0x80


/*
** Save Linha info Para a new instruction. If difference from last Linha
** does not fit in a byte, of after that many instructions, save a new
** absolute Linha info; (in that Caso, the special value 'ABSLINEINFO'
** in 'lineinfo' signals the existence of this absolute information.)
** Otherwise, store the difference from last Linha in 'lineinfo'.
*/
Fixo Vazio savelineinfo (FuncState *fs, Proto *f, Inteiro Linha) {
  Inteiro linedif = Linha - fs->previousline;
  Inteiro pc = fs->pc - 1;  /* last instruction coded */
  Se (abs(linedif) >= LIMLINEDIFF || fs->iwthabs++ >= MAXIWTHABS) {
    sol_m_growvector(fs->ls->L, f->abslineinfo, fs->nabslineinfo,
                    f->sizeabslineinfo, AbsLineInfo, INT_MAX, "lines");
    f->abslineinfo[fs->nabslineinfo].pc = pc;
    f->abslineinfo[fs->nabslineinfo++].Linha = Linha;
    linedif = ABSLINEINFO;  /* signal that there is absolute information */
    fs->iwthabs = 1;  /* restart counter */
  }
  sol_m_growvector(fs->ls->L, f->lineinfo, pc, f->sizelineinfo, ls_byte,
                  INT_MAX, "opcodes");
  f->lineinfo[pc] = cast(ls_byte, linedif);
  fs->previousline = Linha;  /* last Linha saved */
}


/*
** Remove Linha information from the last instruction.
** If Linha information Para that instruction is absolute, set 'iwthabs'
** above its max to force the new (replacing) instruction to have
** absolute Linha info, too.
*/
Fixo Vazio removelastlineinfo (FuncState *fs) {
  Proto *f = fs->f;
  Inteiro pc = fs->pc - 1;  /* last instruction coded */
  Se (f->lineinfo[pc] != ABSLINEINFO) {  /* relative Linha info? */
    fs->previousline -= f->lineinfo[pc];  /* correct last Linha saved */
    fs->iwthabs--;  /* undo previous increment */
  }
  Senão {  /* absolute Linha information */
    sol_assert(f->abslineinfo[fs->nabslineinfo - 1].pc == pc);
    fs->nabslineinfo--;  /* remove it */
    fs->iwthabs = MAXIWTHABS + 1;  /* force next Linha info to be absolute */
  }
}


/*
** Remove the last instruction created, correcting Linha information
** accordingly.
*/
Fixo Vazio removelastinstruction (FuncState *fs) {
  removelastlineinfo(fs);
  fs->pc--;
}


/*
** Emit instruction 'i', checking Para array sizes and saving also its
** Linha information. Return 'i' position.
*/
Inteiro sol_k_code (FuncState *fs, Instruction i) {
  Proto *f = fs->f;
  /* put new instruction in code array */
  sol_m_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,
                  INT_MAX, "opcodes");
  f->code[fs->pc++] = i;
  savelineinfo(fs, f, fs->ls->lastline);
  Retorne fs->pc - 1;  /* index of new instruction */
}


/*
** Format and emit an 'iABC' instruction. (Assertions check consistency
** of parameters versus opcode.)
*/
Inteiro sol_k_codeABCk (FuncState *fs, OpCode o, Inteiro A, Inteiro B, Inteiro C, Inteiro k) {
  sol_assert(getOpMode(o) == iABC);
  sol_assert(A <= MAXARG_A && B <= MAXARG_B &&
             C <= MAXARG_C && (k & ~1) == 0);
  Retorne sol_k_code(fs, CREATE_ABCk(o, A, B, C, k));
}


Inteiro sol_k_codevABCk (FuncState *fs, OpCode o, Inteiro A, Inteiro B, Inteiro C, Inteiro k) {
  sol_assert(getOpMode(o) == ivABC);
  sol_assert(A <= MAXARG_A && B <= MAXARG_vB &&
             C <= MAXARG_vC && (k & ~1) == 0);
  Retorne sol_k_code(fs, CREATE_vABCk(o, A, B, C, k));
}


/*
** Format and emit an 'iABx' instruction.
*/
Inteiro sol_k_codeABx (FuncState *fs, OpCode o, Inteiro A, Inteiro Bc) {
  sol_assert(getOpMode(o) == iABx);
  sol_assert(A <= MAXARG_A && Bc <= MAXARG_Bx);
  Retorne sol_k_code(fs, CREATE_ABx(o, A, Bc));
}


/*
** Format and emit an 'iAsBx' instruction.
*/
Fixo Inteiro codeAsBx (FuncState *fs, OpCode o, Inteiro A, Inteiro Bc) {
  Inteiro b = Bc + OFFSET_sBx;
  sol_assert(getOpMode(o) == iAsBx);
  sol_assert(A <= MAXARG_A && b <= MAXARG_Bx);
  Retorne sol_k_code(fs, CREATE_ABx(o, A, b));
}


/*
** Format and emit an 'isJ' instruction.
*/
Fixo Inteiro codesJ (FuncState *fs, OpCode o, Inteiro sj, Inteiro k) {
  Inteiro j = sj + OFFSET_sJ;
  sol_assert(getOpMode(o) == isJ);
  sol_assert(j <= MAXARG_sJ && (k & ~1) == 0);
  Retorne sol_k_code(fs, CREATE_sJ(o, j, k));
}


/*
** Emit an "extra argument" instruction (format 'iAx')
*/
Fixo Inteiro codeextraarg (FuncState *fs, Inteiro A) {
  sol_assert(A <= MAXARG_Ax);
  Retorne sol_k_code(fs, CREATE_Ax(OP_EXTRAARG, A));
}


/*
** Emit a "load constant" instruction, using either 'OP_LOADK'
** (Se constant index 'k' fits in 18 bits) or an 'OP_LOADKX'
** instruction with "extra argument".
*/
Fixo Inteiro sol_k_codek (FuncState *fs, Inteiro reg, Inteiro k) {
  Se (k <= MAXARG_Bx)
    Retorne sol_k_codeABx(fs, OP_LOADK, reg, k);
  Senão {
    Inteiro p = sol_k_codeABx(fs, OP_LOADKX, reg, 0);
    codeextraarg(fs, k);
    Retorne p;
  }
}


/*
** Check Registrador-stack level, keeping track of its maximum size
** in field 'maxstacksize'
*/
Vazio sol_k_checkstack (FuncState *fs, Inteiro n) {
  Inteiro newstack = fs->freereg + n;
  Se (newstack > fs->f->maxstacksize) {
    sol_y_checklimit(fs, newstack, MAX_FSTACK, "registers");
    fs->f->maxstacksize = cast_byte(newstack);
  }
}


/*
** Reserve 'n' registers in Registrador stack
*/
Vazio sol_k_reserveregs (FuncState *fs, Inteiro n) {
  sol_k_checkstack(fs, n);
  fs->freereg =  cast_byte(fs->freereg + n);
}


/*
** Free Registrador 'reg', Se it is neither a constant index nor
** a local variable.
)
*/
Fixo Vazio freereg (FuncState *fs, Inteiro reg) {
  Se (reg >= sol_y_nvarstack(fs)) {
    fs->freereg--;
    sol_assert(reg == fs->freereg);
  }
}


/*
** Free two registers in proper order
*/
Fixo Vazio freeregs (FuncState *fs, Inteiro r1, Inteiro r2) {
  Se (r1 > r2) {
    freereg(fs, r1);
    freereg(fs, r2);
  }
  Senão {
    freereg(fs, r2);
    freereg(fs, r1);
  }
}


/*
** Free Registrador used by expression 'e' (Se any)
*/
Fixo Vazio freeexp (FuncState *fs, expdesc *e) {
  Se (e->k == VNONRELOC)
    freereg(fs, e->u.info);
}


/*
** Free registers used by expressions 'e1' and 'e2' (Se any) in proper
** order.
*/
Fixo Vazio freeexps (FuncState *fs, expdesc *e1, expdesc *e2) {
  Inteiro r1 = (e1->k == VNONRELOC) ? e1->u.info : -1;
  Inteiro r2 = (e2->k == VNONRELOC) ? e2->u.info : -1;
  freeregs(fs, r1, r2);
}


/*
** Add constant 'v' to prototype's list of constants (field 'k').
*/
Fixo Inteiro addk (FuncState *fs, Proto *f, TValue *v) {
  sol_State *L = fs->ls->L;
  Inteiro oldsize = f->sizek;
  Inteiro k = fs->nk;
  sol_m_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, "constants");
  Enquanto (oldsize < f->sizek)
    setnilvalue(&f->k[oldsize++]);
  setobj(L, &f->k[k], v);
  fs->nk++;
  sol_c_barrier(L, f, v);
  Retorne k;
}


/*
** Use scanner's table to cache position of constants in constant list
** and try to reuse constants. Because some values should not be used
** as keys (nil cannot be a key, integer keys can collapse with Real
** keys), the caller must provide a useful 'key' Para indexing the cache.
*/
Fixo Inteiro k2proto (FuncState *fs, TValue *key, TValue *v) {
  TValue val;
  Proto *f = fs->f;
  Inteiro tag = sol_h_get(fs->kcache, key, &val);  /* query scanner table */
  Se (!tagisempty(tag)) {  /* is there an index there? */
    Inteiro k = cast_int(ivalue(&val));
    /* collisions can happen only Para Real keys */
    sol_assert(ttisfloat(key) || sol_v_rawequalobj(&f->k[k], v));
    Retorne k;  /* reuse index */
  }
  Senão {  /* constant not found; create a new entry */
    Inteiro k = addk(fs, f, v);
    /* cache it Para reuse; numerical value does not need GC barrier;
       table is not a metatable, so it does not need to invalidate cache */
    setivalue(&val, k);
    sol_h_set(fs->ls->L, fs->kcache, key, &val);
    Retorne k;
  }
}


/*
** Add a string to list of constants and Retorne its index.
*/
Fixo Inteiro stringK (FuncState *fs, TString *s) {
  TValue o;
  setsvalue(fs->ls->L, &o, s);
  Retorne k2proto(fs, &o, &o);  /* use string itself as key */
}


/*
** Add an integer to list of constants and Retorne its index.
*/
Fixo Inteiro sol_k_intK (FuncState *fs, sol_Integer n) {
  TValue o;
  setivalue(&o, n);
  Retorne k2proto(fs, &o, &o);  /* use integer itself as key */
}

/*
** Add a Real to list of constants and Retorne its index. Floats
** with integral values need a different key, to avoid collision
** with actual integers. To that end, we add to the number its smaller
** power-of-two fraction that is still significant in its scale.
** (For doubles, the fraction would be 2^-52).
** This method is not bulletproof: different numbers may generate the
** same key (e.g., very large numbers will overflow to 'inf') and Para
** floats larger than 2^53 the result is still an integer. For those
** cases, just generate a new entry. At worst, this only wastes an entry
** with a duplicate.
*/
Fixo Inteiro sol_k_numberK (FuncState *fs, sol_Number r) {
  TValue o, kv;
  setfltvalue(&o, r);  /* value as a TValue */
  Se (r == 0) {  /* handle zero as a special Caso */
    setpvalue(&kv, fs);  /* use FuncState as index */
    Retorne k2proto(fs, &kv, &o);  /* cannot collide */
  }
  Senão {
    Imutável Inteiro nbm = l_floatatt(MANT_DIG);
    Imutável sol_Number q = l_mathop(ldexp)(l_mathop(1.0), -nbm + 1);
    Imutável sol_Number k =  r * (1 + q);  /* key */
    sol_Integer ik;
    setfltvalue(&kv, k);  /* key as a TValue */
    Se (!sol_v_flttointeger(k, &ik, F2Ieq)) {  /* not an integer value? */
      Inteiro n = k2proto(fs, &kv, &o);  /* use key */
      Se (sol_v_rawequalobj(&fs->f->k[n], &o))  /* correct value? */
        Retorne n;
    }
    /* Senão, either key is still an integer or there was a collision;
       anyway, Faça not try to reuse constant; instead, create a new one */
    Retorne addk(fs, fs->f, &o);
  }
}


/*
** Add a false to list of constants and Retorne its index.
*/
Fixo Inteiro boolF (FuncState *fs) {
  TValue o;
  setbfvalue(&o);
  Retorne k2proto(fs, &o, &o);  /* use boolean itself as key */
}


/*
** Add a true to list of constants and Retorne its index.
*/
Fixo Inteiro boolT (FuncState *fs) {
  TValue o;
  setbtvalue(&o);
  Retorne k2proto(fs, &o, &o);  /* use boolean itself as key */
}


/*
** Add nil to list of constants and Retorne its index.
*/
Fixo Inteiro nilK (FuncState *fs) {
  TValue k, v;
  setnilvalue(&v);
  /* cannot use nil as key; instead use table itself */
  sethvalue(fs->ls->L, &k, fs->kcache);
  Retorne k2proto(fs, &k, &v);
}


/*
** Check whether 'i' can be stored in an 'sC' operand. Equivalent to
** (0 <= int2sC(i) && int2sC(i) <= MAXARG_C) but without risk of
** overflows in the hidden addition inside 'int2sC'.
*/
Fixo Inteiro fitsC (sol_Integer i) {
  Retorne (l_castS2U(i) + OFFSET_sC <= cast_uint(MAXARG_C));
}


/*
** Check whether 'i' can be stored in an 'sBx' operand.
*/
Fixo Inteiro fitsBx (sol_Integer i) {
  Retorne (-OFFSET_sBx <= i && i <= MAXARG_Bx - OFFSET_sBx);
}


Vazio sol_k_int (FuncState *fs, Inteiro reg, sol_Integer i) {
  Se (fitsBx(i))
    codeAsBx(fs, OP_LOADI, reg, cast_int(i));
  Senão
    sol_k_codek(fs, reg, sol_k_intK(fs, i));
}


Fixo Vazio sol_k_float (FuncState *fs, Inteiro reg, sol_Number f) {
  sol_Integer fi;
  Se (sol_v_flttointeger(f, &fi, F2Ieq) && fitsBx(fi))
    codeAsBx(fs, OP_LOADF, reg, cast_int(fi));
  Senão
    sol_k_codek(fs, reg, sol_k_numberK(fs, f));
}


/*
** Convert a constant in 'v' into an expression description 'e'
*/
Fixo Vazio const2exp (TValue *v, expdesc *e) {
  Troque (ttypetag(v)) {
    Caso SOL_VNUMINT:
      e->k = VKINT; e->u.ival = ivalue(v);
      Interrompa;
    Caso SOL_VNUMFLT:
      e->k = VKFLT; e->u.nval = fltvalue(v);
      Interrompa;
    Caso SOL_VFALSE:
      e->k = VFALSE;
      Interrompa;
    Caso SOL_VTRUE:
      e->k = VTRUE;
      Interrompa;
    Caso SOL_VNIL:
      e->k = VNIL;
      Interrompa;
    Caso SOL_VSHRSTR:  Caso SOL_VLNGSTR:
      e->k = VKSTR; e->u.strval = tsvalue(v);
      Interrompa;
    Padrão: sol_assert(0);
  }
}


/*
** Fix an expression to Retorne the number of results 'nresults'.
** 'e' must be a multi-ret expression (function call or vararg).
*/
Vazio sol_k_setreturns (FuncState *fs, expdesc *e, Inteiro nresults) {
  Instruction *pc = &getinstruction(fs, e);
  sol_y_checklimit(fs, nresults + 1, MAXARG_C, "multiple results");
  Se (e->k == VCALL)  /* expression is an open function call? */
    SETARG_C(*pc, nresults + 1);
  Senão {
    sol_assert(e->k == VVARARG);
    SETARG_C(*pc, nresults + 1);
    SETARG_A(*pc, fs->freereg);
    sol_k_reserveregs(fs, 1);
  }
}


/*
** Convert a VKSTR to a VK
*/
Fixo Inteiro str2K (FuncState *fs, expdesc *e) {
  sol_assert(e->k == VKSTR);
  e->u.info = stringK(fs, e->u.strval);
  e->k = VK;
  Retorne e->u.info;
}


/*
** Fix an expression to Retorne one result.
** If expression is not a multi-ret expression (function call or
** vararg), it already returns one result, so nothing needs to be done.
** Function calls become VNONRELOC expressions (as its result comes
** fixed in the base Registrador of the call), Enquanto vararg expressions
** become VRELOC (as OP_VARARG puts its results where it wants).
** (Calls are created returning one result, so that does not need
** to be fixed.)
*/
Vazio sol_k_setoneret (FuncState *fs, expdesc *e) {
  Se (e->k == VCALL) {  /* expression is an open function call? */
    /* already returns 1 value */
    sol_assert(GETARG_C(getinstruction(fs, e)) == 2);
    e->k = VNONRELOC;  /* result has fixed position */
    e->u.info = GETARG_A(getinstruction(fs, e));
  }
  Senão Se (e->k == VVARARG) {
    SETARG_C(getinstruction(fs, e), 2);
    e->k = VRELOC;  /* can relocate its simple result */
  }
}


/*
** Ensure that expression 'e' is not a variable (nor a <Imutável>).
** (Expression still may have jump lists.)
*/
Vazio sol_k_dischargevars (FuncState *fs, expdesc *e) {
  Troque (e->k) {
    Caso VCONST: {
      const2exp(const2val(fs, e), e);
      Interrompa;
    }
    Caso VLOCAL: {  /* already in a Registrador */
      Inteiro temp = e->u.var.ridx;
      e->u.info = temp;  /* (can't Faça a direct assignment; values overlap) */
      e->k = VNONRELOC;  /* becomes a non-relocatable value */
      Interrompa;
    }
    Caso VUPVAL: {  /* move value to some (pending) Registrador */
      e->u.info = sol_k_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);
      e->k = VRELOC;
      Interrompa;
    }
    Caso VINDEXUP: {
      e->u.info = sol_k_codeABC(fs, OP_GETTABUP, 0, e->u.ind.t, e->u.ind.idx);
      e->k = VRELOC;
      Interrompa;
    }
    Caso VINDEXI: {
      freereg(fs, e->u.ind.t);
      e->u.info = sol_k_codeABC(fs, OP_GETI, 0, e->u.ind.t, e->u.ind.idx);
      e->k = VRELOC;
      Interrompa;
    }
    Caso VINDEXSTR: {
      freereg(fs, e->u.ind.t);
      e->u.info = sol_k_codeABC(fs, OP_GETFIELD, 0, e->u.ind.t, e->u.ind.idx);
      e->k = VRELOC;
      Interrompa;
    }
    Caso VINDEXED: {
      freeregs(fs, e->u.ind.t, e->u.ind.idx);
      e->u.info = sol_k_codeABC(fs, OP_GETTABLE, 0, e->u.ind.t, e->u.ind.idx);
      e->k = VRELOC;
      Interrompa;
    }
    Caso VVARARG: Caso VCALL: {
      sol_k_setoneret(fs, e);
      Interrompa;
    }
    Padrão: Interrompa;  /* there is one value available (somewhere) */
  }
}


/*
** Ensure expression value is in Registrador 'reg', making 'e' a
** non-relocatable expression.
** (Expression still may have jump lists.)
*/
Fixo Vazio discharge2reg (FuncState *fs, expdesc *e, Inteiro reg) {
  sol_k_dischargevars(fs, e);
  Troque (e->k) {
    Caso VNIL: {
      sol_k_nil(fs, reg, 1);
      Interrompa;
    }
    Caso VFALSE: {
      sol_k_codeABC(fs, OP_LOADFALSE, reg, 0, 0);
      Interrompa;
    }
    Caso VTRUE: {
      sol_k_codeABC(fs, OP_LOADTRUE, reg, 0, 0);
      Interrompa;
    }
    Caso VKSTR: {
      str2K(fs, e);
    }  /* FALLTHROUGH */
    Caso VK: {
      sol_k_codek(fs, reg, e->u.info);
      Interrompa;
    }
    Caso VKFLT: {
      sol_k_float(fs, reg, e->u.nval);
      Interrompa;
    }
    Caso VKINT: {
      sol_k_int(fs, reg, e->u.ival);
      Interrompa;
    }
    Caso VRELOC: {
      Instruction *pc = &getinstruction(fs, e);
      SETARG_A(*pc, reg);  /* instruction will put result in 'reg' */
      Interrompa;
    }
    Caso VNONRELOC: {
      Se (reg != e->u.info)
        sol_k_codeABC(fs, OP_MOVE, reg, e->u.info, 0);
      Interrompa;
    }
    Padrão: {
      sol_assert(e->k == VJMP);
      Retorne;  /* nothing to Faça... */
    }
  }
  e->u.info = reg;
  e->k = VNONRELOC;
}


/*
** Ensure expression value is in a Registrador, making 'e' a
** non-relocatable expression.
** (Expression still may have jump lists.)
*/
Fixo Vazio discharge2anyreg (FuncState *fs, expdesc *e) {
  Se (e->k != VNONRELOC) {  /* no fixed Registrador yet? */
    sol_k_reserveregs(fs, 1);  /* get a Registrador */
    discharge2reg(fs, e, fs->freereg-1);  /* put value there */
  }
}


Fixo Inteiro code_loadbool (FuncState *fs, Inteiro A, OpCode op) {
  sol_k_getlabel(fs);  /* those instructions may be jump targets */
  Retorne sol_k_codeABC(fs, op, A, 0, 0);
}


/*
** check whether list has any jump that Faça not produce a value
** or produce an inverted value
*/
Fixo Inteiro need_value (FuncState *fs, Inteiro list) {
  Para (; list != NO_JUMP; list = getjump(fs, list)) {
    Instruction i = *getjumpcontrol(fs, list);
    Se (GET_OPCODE(i) != OP_TESTSET) Retorne 1;
  }
  Retorne 0;  /* not found */
}


/*
** Ensures final expression result (which includes results from its
** jump lists) is in Registrador 'reg'.
** If expression has jumps, need to patch these jumps either to
** its final position or to "load" instructions (Para those tests
** that Faça not produce values).
*/
Fixo Vazio exp2reg (FuncState *fs, expdesc *e, Inteiro reg) {
  discharge2reg(fs, e, reg);
  Se (e->k == VJMP)  /* expression itself is a test? */
    sol_k_concat(fs, &e->t, e->u.info);  /* put this jump in 't' list */
  Se (hasjumps(e)) {
    Inteiro final;  /* position after whole expression */
    Inteiro p_f = NO_JUMP;  /* position of an eventual LOAD false */
    Inteiro p_t = NO_JUMP;  /* position of an eventual LOAD true */
    Se (need_value(fs, e->t) || need_value(fs, e->f)) {
      Inteiro fj = (e->k == VJMP) ? NO_JUMP : sol_k_jump(fs);
      p_f = code_loadbool(fs, reg, OP_LFALSESKIP);  /* skip next inst. */
      p_t = code_loadbool(fs, reg, OP_LOADTRUE);
      /* jump around these booleans Se 'e' is not a test */
      sol_k_patchtohere(fs, fj);
    }
    final = sol_k_getlabel(fs);
    patchlistaux(fs, e->f, final, reg, p_f);
    patchlistaux(fs, e->t, final, reg, p_t);
  }
  e->f = e->t = NO_JUMP;
  e->u.info = reg;
  e->k = VNONRELOC;
}


/*
** Ensures final expression result is in next available Registrador.
*/
Vazio sol_k_exp2nextreg (FuncState *fs, expdesc *e) {
  sol_k_dischargevars(fs, e);
  freeexp(fs, e);
  sol_k_reserveregs(fs, 1);
  exp2reg(fs, e, fs->freereg - 1);
}


/*
** Ensures final expression result is in some (any) Registrador
** and Retorne that Registrador.
*/
Inteiro sol_k_exp2anyreg (FuncState *fs, expdesc *e) {
  sol_k_dischargevars(fs, e);
  Se (e->k == VNONRELOC) {  /* expression already has a Registrador? */
    Se (!hasjumps(e))  /* no jumps? */
      Retorne e->u.info;  /* result is already in a Registrador */
    Se (e->u.info >= sol_y_nvarstack(fs)) {  /* reg. is not a local? */
      exp2reg(fs, e, e->u.info);  /* put final result in it */
      Retorne e->u.info;
    }
    /* Senão expression has jumps and cannot change its Registrador
       to hold the jump values, because it is a local variable.
       Go through to the Padrão Caso. */
  }
  sol_k_exp2nextreg(fs, e);  /* Padrão: use next available Registrador */
  Retorne e->u.info;
}


/*
** Ensures final expression result is either in a Registrador
** or in an upvalue.
*/
Vazio sol_k_exp2anyregup (FuncState *fs, expdesc *e) {
  Se (e->k != VUPVAL || hasjumps(e))
    sol_k_exp2anyreg(fs, e);
}


/*
** Ensures final expression result is either in a Registrador
** or it is a constant.
*/
Vazio sol_k_exp2val (FuncState *fs, expdesc *e) {
  Se (e->k == VJMP || hasjumps(e))
    sol_k_exp2anyreg(fs, e);
  Senão
    sol_k_dischargevars(fs, e);
}


/*
** Try to make 'e' a K expression with an index in the range of R/K
** indices. Return true iff succeeded.
*/
Fixo Inteiro sol_k_exp2K (FuncState *fs, expdesc *e) {
  Se (!hasjumps(e)) {
    Inteiro info;
    Troque (e->k) {  /* move constants to 'k' */
      Caso VTRUE: info = boolT(fs); Interrompa;
      Caso VFALSE: info = boolF(fs); Interrompa;
      Caso VNIL: info = nilK(fs); Interrompa;
      Caso VKINT: info = sol_k_intK(fs, e->u.ival); Interrompa;
      Caso VKFLT: info = sol_k_numberK(fs, e->u.nval); Interrompa;
      Caso VKSTR: info = stringK(fs, e->u.strval); Interrompa;
      Caso VK: info = e->u.info; Interrompa;
      Padrão: Retorne 0;  /* not a constant */
    }
    Se (info <= MAXINDEXRK) {  /* does constant fit in 'argC'? */
      e->k = VK;  /* make expression a 'K' expression */
      e->u.info = info;
      Retorne 1;
    }
  }
  /* Senão, expression doesn't fit; leave it unchanged */
  Retorne 0;
}


/*
** Ensures final expression result is in a valid R/K index
** (that is, it is either in a Registrador or in 'k' with an index
** in the range of R/K indices).
** Returns 1 iff expression is K.
*/
Fixo Inteiro exp2RK (FuncState *fs, expdesc *e) {
  Se (sol_k_exp2K(fs, e))
    Retorne 1;
  Senão {  /* not a constant in the right range: put it in a Registrador */
    sol_k_exp2anyreg(fs, e);
    Retorne 0;
  }
}


Fixo Vazio codeABRK (FuncState *fs, OpCode o, Inteiro A, Inteiro B,
                      expdesc *ec) {
  Inteiro k = exp2RK(fs, ec);
  sol_k_codeABCk(fs, o, A, B, ec->u.info, k);
}


/*
** Generate code to store result of expression 'ex' into variable 'var'.
*/
Vazio sol_k_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
  Troque (var->k) {
    Caso VLOCAL: {
      freeexp(fs, ex);
      exp2reg(fs, ex, var->u.var.ridx);  /* compute 'ex' into proper place */
      Retorne;
    }
    Caso VUPVAL: {
      Inteiro e = sol_k_exp2anyreg(fs, ex);
      sol_k_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);
      Interrompa;
    }
    Caso VINDEXUP: {
      codeABRK(fs, OP_SETTABUP, var->u.ind.t, var->u.ind.idx, ex);
      Interrompa;
    }
    Caso VINDEXI: {
      codeABRK(fs, OP_SETI, var->u.ind.t, var->u.ind.idx, ex);
      Interrompa;
    }
    Caso VINDEXSTR: {
      codeABRK(fs, OP_SETFIELD, var->u.ind.t, var->u.ind.idx, ex);
      Interrompa;
    }
    Caso VINDEXED: {
      codeABRK(fs, OP_SETTABLE, var->u.ind.t, var->u.ind.idx, ex);
      Interrompa;
    }
    Padrão: sol_assert(0);  /* invalid var kind to store */
  }
  freeexp(fs, ex);
}


/*
** Negate condition 'e' (where 'e' is a comparison).
*/
Fixo Vazio negatecondition (FuncState *fs, expdesc *e) {
  Instruction *pc = getjumpcontrol(fs, e->u.info);
  sol_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&
                                           GET_OPCODE(*pc) != OP_TEST);
  SETARG_k(*pc, (GETARG_k(*pc) ^ 1));
}


/*
** Emit instruction to jump Se 'e' is 'cond' (that is, Se 'cond'
** is true, code will jump Se 'e' is true.) Return jump position.
** Optimize when 'e' is 'not' something, inverting the condition
** and removing the 'not'.
*/
Fixo Inteiro jumponcond (FuncState *fs, expdesc *e, Inteiro cond) {
  Se (e->k == VRELOC) {
    Instruction ie = getinstruction(fs, e);
    Se (GET_OPCODE(ie) == OP_NOT) {
      removelastinstruction(fs);  /* remove previous OP_NOT */
      Retorne condjump(fs, OP_TEST, GETARG_B(ie), 0, 0, !cond);
    }
    /* Senão go through */
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  Retorne condjump(fs, OP_TESTSET, NO_REG, e->u.info, 0, cond);
}


/*
** Emit code to go through Se 'e' is true, jump otherwise.
*/
Vazio sol_k_goiftrue (FuncState *fs, expdesc *e) {
  Inteiro pc;  /* pc of new jump */
  sol_k_dischargevars(fs, e);
  Troque (e->k) {
    Caso VJMP: {  /* condition? */
      negatecondition(fs, e);  /* jump when it is false */
      pc = e->u.info;  /* save jump position */
      Interrompa;
    }
    Caso VK: Caso VKFLT: Caso VKINT: Caso VKSTR: Caso VTRUE: {
      pc = NO_JUMP;  /* always true; Faça nothing */
      Interrompa;
    }
    Padrão: {
      pc = jumponcond(fs, e, 0);  /* jump when false */
      Interrompa;
    }
  }
  sol_k_concat(fs, &e->f, pc);  /* insert new jump in false list */
  sol_k_patchtohere(fs, e->t);  /* true list jumps to here (to go through) */
  e->t = NO_JUMP;
}


/*
** Emit code to go through Se 'e' is false, jump otherwise.
*/
Vazio sol_k_goiffalse (FuncState *fs, expdesc *e) {
  Inteiro pc;  /* pc of new jump */
  sol_k_dischargevars(fs, e);
  Troque (e->k) {
    Caso VJMP: {
      pc = e->u.info;  /* already jump Se true */
      Interrompa;
    }
    Caso VNIL: Caso VFALSE: {
      pc = NO_JUMP;  /* always false; Faça nothing */
      Interrompa;
    }
    Padrão: {
      pc = jumponcond(fs, e, 1);  /* jump Se true */
      Interrompa;
    }
  }
  sol_k_concat(fs, &e->t, pc);  /* insert new jump in 't' list */
  sol_k_patchtohere(fs, e->f);  /* false list jumps to here (to go through) */
  e->f = NO_JUMP;
}


/*
** Code 'not e', doing constant folding.
*/
Fixo Vazio codenot (FuncState *fs, expdesc *e) {
  Troque (e->k) {
    Caso VNIL: Caso VFALSE: {
      e->k = VTRUE;  /* true == not nil == not false */
      Interrompa;
    }
    Caso VK: Caso VKFLT: Caso VKINT: Caso VKSTR: Caso VTRUE: {
      e->k = VFALSE;  /* false == not "x" == not 0.5 == not 1 == not true */
      Interrompa;
    }
    Caso VJMP: {
      negatecondition(fs, e);
      Interrompa;
    }
    Caso VRELOC:
    Caso VNONRELOC: {
      discharge2anyreg(fs, e);
      freeexp(fs, e);
      e->u.info = sol_k_codeABC(fs, OP_NOT, 0, e->u.info, 0);
      e->k = VRELOC;
      Interrompa;
    }
    Padrão: sol_assert(0);  /* cannot happen */
  }
  /* interchange true and false lists */
  { Inteiro temp = e->f; e->f = e->t; e->t = temp; }
  removevalues(fs, e->f);  /* values are useless when negated */
  removevalues(fs, e->t);
}


/*
** Check whether expression 'e' is a Curto literal string
*/
Fixo Inteiro isKstr (FuncState *fs, expdesc *e) {
  Retorne (e->k == VK && !hasjumps(e) && e->u.info <= MAXARG_B &&
          ttisshrstring(&fs->f->k[e->u.info]));
}

/*
** Check whether expression 'e' is a literal integer.
*/
Fixo Inteiro isKint (expdesc *e) {
  Retorne (e->k == VKINT && !hasjumps(e));
}


/*
** Check whether expression 'e' is a literal integer in
** proper range to fit in Registrador C
*/
Fixo Inteiro isCint (expdesc *e) {
  Retorne isKint(e) && (l_castS2U(e->u.ival) <= l_castS2U(MAXARG_C));
}


/*
** Check whether expression 'e' is a literal integer in
** proper range to fit in Registrador sC
*/
Fixo Inteiro isSCint (expdesc *e) {
  Retorne isKint(e) && fitsC(e->u.ival);
}


/*
** Check whether expression 'e' is a literal integer or Real in
** proper range to fit in a Registrador (sB or sC).
*/
Fixo Inteiro isSCnumber (expdesc *e, Inteiro *pi, Inteiro *isfloat) {
  sol_Integer i;
  Se (e->k == VKINT)
    i = e->u.ival;
  Senão Se (e->k == VKFLT && sol_v_flttointeger(e->u.nval, &i, F2Ieq))
    *isfloat = 1;
  Senão
    Retorne 0;  /* not a number */
  Se (!hasjumps(e) && fitsC(i)) {
    *pi = int2sC(cast_int(i));
    Retorne 1;
  }
  Senão
    Retorne 0;
}


/*
** Emit SELF instruction or equivalent: the code will convert
** expression 'e' into 'e.key(e,'.
*/
Vazio sol_k_self (FuncState *fs, expdesc *e, expdesc *key) {
  Inteiro ereg, base;
  sol_k_exp2anyreg(fs, e);
  ereg = e->u.info;  /* Registrador where 'e' (the receiver) was placed */
  freeexp(fs, e);
  base = e->u.info = fs->freereg;  /* base Registrador Para op_self */
  e->k = VNONRELOC;  /* self expression has a fixed Registrador */
  sol_k_reserveregs(fs, 2);  /* method and 'self' produced by op_self */
  sol_assert(key->k == VKSTR);
  /* is method name a Curto string in a valid K index? */
  Se (strisshr(key->u.strval) && sol_k_exp2K(fs, key)) {
    /* can use 'self' opcode */
    sol_k_codeABCk(fs, OP_SELF, base, ereg, key->u.info, 0);
  }
  Senão {  /* cannot use 'self' opcode; use move+gettable */
    sol_k_exp2anyreg(fs, key);  /* put method name in a Registrador */
    sol_k_codeABC(fs, OP_MOVE, base + 1, ereg, 0);  /* copy self to base+1 */
    sol_k_codeABC(fs, OP_GETTABLE, base, ereg, key->u.info);  /* get method */
  }
  freeexp(fs, key);
}


/*
** Create expression 't[k]'. 't' must have its final result already in a
** Registrador or upvalue. Upvalues can only be indexed by literal strings.
** Keys can be literal strings in the constant table or arbitrary
** values in registers.
*/
Vazio sol_k_indexed (FuncState *fs, expdesc *t, expdesc *k) {
  Inteiro keystr = -1;
  Se (k->k == VKSTR)
    keystr = str2K(fs, k);
  sol_assert(!hasjumps(t) &&
             (t->k == VLOCAL || t->k == VNONRELOC || t->k == VUPVAL));
  Se (t->k == VUPVAL && !isKstr(fs, k))  /* upvalue indexed by non 'Kstr'? */
    sol_k_exp2anyreg(fs, t);  /* put it in a Registrador */
  Se (t->k == VUPVAL) {
    lu_byte temp = cast_byte(t->u.info);  /* upvalue index */
    t->u.ind.t = temp;  /* (can't Faça a direct assignment; values overlap) */
    sol_assert(isKstr(fs, k));
    t->u.ind.idx = cast_short(k->u.info);  /* literal Curto string */
    t->k = VINDEXUP;
  }
  Senão {
    /* Registrador index of the table */
    t->u.ind.t = cast_byte((t->k == VLOCAL) ? t->u.var.ridx: t->u.info);
    Se (isKstr(fs, k)) {
      t->u.ind.idx = cast_short(k->u.info);  /* literal Curto string */
      t->k = VINDEXSTR;
    }
    Senão Se (isCint(k)) {  /* Inteiro. constant in proper range? */
      t->u.ind.idx = cast_short(k->u.ival);
      t->k = VINDEXI;
    }
    Senão {
      t->u.ind.idx = cast_short(sol_k_exp2anyreg(fs, k));  /* Registrador */
      t->k = VINDEXED;
    }
  }
  t->u.ind.keystr = keystr;  /* string index in 'k' */
  t->u.ind.ro = 0;  /* by Padrão, not read-only */
}


/*
** Return false Se folding can raise an Erro.
** Bitwise operations need operands convertible to integers; division
** operations cannot have 0 as divisor.
*/
Fixo Inteiro validop (Inteiro op, TValue *v1, TValue *v2) {
  Troque (op) {
    Caso SOL_OPBAND: Caso SOL_OPBOR: Caso SOL_OPBXOR:
    Caso SOL_OPSHL: Caso SOL_OPSHR: Caso SOL_OPBNOT: {  /* conversion errors */
      sol_Integer i;
      Retorne (sol_v_tointegerns(v1, &i, SOL_FLOORN2I) &&
              sol_v_tointegerns(v2, &i, SOL_FLOORN2I));
    }
    Caso SOL_OPDIV: Caso SOL_OPIDIV: Caso SOL_OPMOD:  /* division by 0 */
      Retorne (nvalue(v2) != 0);
    Padrão: Retorne 1;  /* everything Senão is valid */
  }
}


/*
** Try to "constant-fold" an operation; Retorne 1 iff successful.
** (In this Caso, 'e1' has the final result.)
*/
Fixo Inteiro constfolding (FuncState *fs, Inteiro op, expdesc *e1,
                                        Imutável expdesc *e2) {
  TValue v1, v2, res;
  Se (!tonumeral(e1, &v1) || !tonumeral(e2, &v2) || !validop(op, &v1, &v2))
    Retorne 0;  /* non-numeric operands or not safe to fold */
  sol_o_rawarith(fs->ls->L, op, &v1, &v2, &res);  /* does operation */
  Se (ttisinteger(&res)) {
    e1->k = VKINT;
    e1->u.ival = ivalue(&res);
  }
  Senão {  /* folds neither NaN nor 0.0 (to avoid problems with -0.0) */
    sol_Number n = fltvalue(&res);
    Se (sol_numisnan(n) || n == 0)
      Retorne 0;
    e1->k = VKFLT;
    e1->u.nval = n;
  }
  Retorne 1;
}


/*
** Convert a BinOpr to an OpCode  (ORDER OPR - ORDER OP)
*/
l_sinline OpCode binopr2op (BinOpr opr, BinOpr baser, OpCode base) {
  sol_assert(baser <= opr &&
            ((baser == OPR_ADD && opr <= OPR_SHR) ||
             (baser == OPR_LT && opr <= OPR_LE)));
  Retorne cast(OpCode, (cast_int(opr) - cast_int(baser)) + cast_int(base));
}


/*
** Convert a UnOpr to an OpCode  (ORDER OPR - ORDER OP)
*/
l_sinline OpCode unopr2op (UnOpr opr) {
  Retorne cast(OpCode, (cast_int(opr) - cast_int(OPR_MINUS)) +
                                       cast_int(OP_UNM));
}


/*
** Convert a BinOpr to a tag method  (ORDER OPR - ORDER TM)
*/
l_sinline TMS binopr2TM (BinOpr opr) {
  sol_assert(OPR_ADD <= opr && opr <= OPR_SHR);
  Retorne cast(TMS, (cast_int(opr) - cast_int(OPR_ADD)) + cast_int(TM_ADD));
}


/*
** Emit code Para unary expressions that "produce values"
** (everything but 'not').
** Expression to produce final result will be encoded in 'e'.
*/
Fixo Vazio codeunexpval (FuncState *fs, OpCode op, expdesc *e, Inteiro Linha) {
  Inteiro r = sol_k_exp2anyreg(fs, e);  /* opcodes operate only on registers */
  freeexp(fs, e);
  e->u.info = sol_k_codeABC(fs, op, 0, r, 0);  /* generate opcode */
  e->k = VRELOC;  /* all those operations are relocatable */
  sol_k_fixline(fs, Linha);
}


/*
** Emit code Para binary expressions that "produce values"
** (everything but logical operators 'and'/'or' and comparison
** operators).
** Expression to produce final result will be encoded in 'e1'.
*/
Fixo Vazio finishbinexpval (FuncState *fs, expdesc *e1, expdesc *e2,
                             OpCode op, Inteiro v2, Inteiro flip, Inteiro Linha,
                             OpCode mmop, TMS event) {
  Inteiro v1 = sol_k_exp2anyreg(fs, e1);
  Inteiro pc = sol_k_codeABCk(fs, op, 0, v1, v2, 0);
  freeexps(fs, e1, e2);
  e1->u.info = pc;
  e1->k = VRELOC;  /* all those operations are relocatable */
  sol_k_fixline(fs, Linha);
  sol_k_codeABCk(fs, mmop, v1, v2, cast_int(event), flip);  /* metamethod */
  sol_k_fixline(fs, Linha);
}


/*
** Emit code Para binary expressions that "produce values" over
** two registers.
*/
Fixo Vazio codebinexpval (FuncState *fs, BinOpr opr,
                           expdesc *e1, expdesc *e2, Inteiro Linha) {
  OpCode op = binopr2op(opr, OPR_ADD, OP_ADD);
  Inteiro v2 = sol_k_exp2anyreg(fs, e2);  /* make sure 'e2' is in a Registrador */
  /* 'e1' must be already in a Registrador or it is a constant */
  sol_assert((VNIL <= e1->k && e1->k <= VKSTR) ||
             e1->k == VNONRELOC || e1->k == VRELOC);
  sol_assert(OP_ADD <= op && op <= OP_SHR);
  finishbinexpval(fs, e1, e2, op, v2, 0, Linha, OP_MMBIN, binopr2TM(opr));
}


/*
** Code binary operators with immediate operands.
*/
Fixo Vazio codebini (FuncState *fs, OpCode op,
                       expdesc *e1, expdesc *e2, Inteiro flip, Inteiro Linha,
                       TMS event) {
  Inteiro v2 = int2sC(cast_int(e2->u.ival));  /* immediate operand */
  sol_assert(e2->k == VKINT);
  finishbinexpval(fs, e1, e2, op, v2, flip, Linha, OP_MMBINI, event);
}


/*
** Code binary operators with K operand.
*/
Fixo Vazio codebinK (FuncState *fs, BinOpr opr,
                      expdesc *e1, expdesc *e2, Inteiro flip, Inteiro Linha) {
  TMS event = binopr2TM(opr);
  Inteiro v2 = e2->u.info;  /* K index */
  OpCode op = binopr2op(opr, OPR_ADD, OP_ADDK);
  finishbinexpval(fs, e1, e2, op, v2, flip, Linha, OP_MMBINK, event);
}


/* Try to code a binary operator negating its second operand.
** For the metamethod, 2nd operand must keep its original value.
*/
Fixo Inteiro finishbinexpneg (FuncState *fs, expdesc *e1, expdesc *e2,
                             OpCode op, Inteiro Linha, TMS event) {
  Se (!isKint(e2))
    Retorne 0;  /* not an integer constant */
  Senão {
    sol_Integer i2 = e2->u.ival;
    Se (!(fitsC(i2) && fitsC(-i2)))
      Retorne 0;  /* not in the proper range */
    Senão {  /* operating a small integer constant */
      Inteiro v2 = cast_int(i2);
      finishbinexpval(fs, e1, e2, op, int2sC(-v2), 0, Linha, OP_MMBINI, event);
      /* correct metamethod argument */
      SETARG_B(fs->f->code[fs->pc - 1], int2sC(v2));
      Retorne 1;  /* successfully coded */
    }
  }
}


Fixo Vazio swapexps (expdesc *e1, expdesc *e2) {
  expdesc temp = *e1; *e1 = *e2; *e2 = temp;  /* swap 'e1' and 'e2' */
}


/*
** Code binary operators with no constant operand.
*/
Fixo Vazio codebinNoK (FuncState *fs, BinOpr opr,
                        expdesc *e1, expdesc *e2, Inteiro flip, Inteiro Linha) {
  Se (flip)
    swapexps(e1, e2);  /* back to original order */
  codebinexpval(fs, opr, e1, e2, Linha);  /* use standard operators */
}


/*
** Code arithmetic operators ('+', '-', ...). If second operand is a
** constant in the proper range, use variant opcodes with K operands.
*/
Fixo Vazio codearith (FuncState *fs, BinOpr opr,
                       expdesc *e1, expdesc *e2, Inteiro flip, Inteiro Linha) {
  Se (tonumeral(e2, NULL) && sol_k_exp2K(fs, e2))  /* K operand? */
    codebinK(fs, opr, e1, e2, flip, Linha);
  Senão  /* 'e2' is neither an immediate nor a K operand */
    codebinNoK(fs, opr, e1, e2, flip, Linha);
}


/*
** Code commutative operators ('+', '*'). If first operand is a
** numeric constant, change order of operands to try to use an
** immediate or K operator.
*/
Fixo Vazio codecommutative (FuncState *fs, BinOpr op,
                             expdesc *e1, expdesc *e2, Inteiro Linha) {
  Inteiro flip = 0;
  Se (tonumeral(e1, NULL)) {  /* is first operand a numeric constant? */
    swapexps(e1, e2);  /* change order */
    flip = 1;
  }
  Se (op == OPR_ADD && isSCint(e2))  /* immediate operand? */
    codebini(fs, OP_ADDI, e1, e2, flip, Linha, TM_ADD);
  Senão
    codearith(fs, op, e1, e2, flip, Linha);
}


/*
** Code bitwise operations; they are all commutative, so the function
** tries to put an integer constant as the 2nd operand (a K operand).
*/
Fixo Vazio codebitwise (FuncState *fs, BinOpr opr,
                         expdesc *e1, expdesc *e2, Inteiro Linha) {
  Inteiro flip = 0;
  Se (e1->k == VKINT) {
    swapexps(e1, e2);  /* 'e2' will be the constant operand */
    flip = 1;
  }
  Se (e2->k == VKINT && sol_k_exp2K(fs, e2))  /* K operand? */
    codebinK(fs, opr, e1, e2, flip, Linha);
  Senão  /* no constants */
    codebinNoK(fs, opr, e1, e2, flip, Linha);
}


/*
** Emit code Para order comparisons. When using an immediate operand,
** 'isfloat' tells whether the original value was a Real.
*/
Fixo Vazio codeorder (FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {
  Inteiro r1, r2;
  Inteiro im;
  Inteiro isfloat = 0;
  OpCode op;
  Se (isSCnumber(e2, &im, &isfloat)) {
    /* use immediate operand */
    r1 = sol_k_exp2anyreg(fs, e1);
    r2 = im;
    op = binopr2op(opr, OPR_LT, OP_LTI);
  }
  Senão Se (isSCnumber(e1, &im, &isfloat)) {
    /* transform (A < B) to (B > A) and (A <= B) to (B >= A) */
    r1 = sol_k_exp2anyreg(fs, e2);
    r2 = im;
    op = binopr2op(opr, OPR_LT, OP_GTI);
  }
  Senão {  /* regular Caso, compare two registers */
    r1 = sol_k_exp2anyreg(fs, e1);
    r2 = sol_k_exp2anyreg(fs, e2);
    op = binopr2op(opr, OPR_LT, OP_LT);
  }
  freeexps(fs, e1, e2);
  e1->u.info = condjump(fs, op, r1, r2, isfloat, 1);
  e1->k = VJMP;
}


/*
** Emit code Para equality comparisons ('==', '~=').
** 'e1' was already put as RK by 'sol_k_infix'.
*/
Fixo Vazio codeeq (FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {
  Inteiro r1, r2;
  Inteiro im;
  Inteiro isfloat = 0;  /* not needed here, but kept Para symmetry */
  OpCode op;
  Se (e1->k != VNONRELOC) {
    sol_assert(e1->k == VK || e1->k == VKINT || e1->k == VKFLT);
    swapexps(e1, e2);
  }
  r1 = sol_k_exp2anyreg(fs, e1);  /* 1st expression must be in Registrador */
  Se (isSCnumber(e2, &im, &isfloat)) {
    op = OP_EQI;
    r2 = im;  /* immediate operand */
  }
  Senão Se (exp2RK(fs, e2)) {  /* 2nd expression is constant? */
    op = OP_EQK;
    r2 = e2->u.info;  /* constant index */
  }
  Senão {
    op = OP_EQ;  /* will compare two registers */
    r2 = sol_k_exp2anyreg(fs, e2);
  }
  freeexps(fs, e1, e2);
  e1->u.info = condjump(fs, op, r1, r2, isfloat, (opr == OPR_EQ));
  e1->k = VJMP;
}


/*
** Apply prefix operation 'op' to expression 'e'.
*/
Vazio sol_k_prefix (FuncState *fs, UnOpr opr, expdesc *e, Inteiro Linha) {
  Fixo Imutável expdesc ef = {VKINT, {0}, NO_JUMP, NO_JUMP};
  sol_k_dischargevars(fs, e);
  Troque (opr) {
    Caso OPR_MINUS: Caso OPR_BNOT:  /* use 'ef' as fake 2nd operand */
      Se (constfolding(fs, cast_int(opr + SOL_OPUNM), e, &ef))
        Interrompa;
      /* Senão */ /* FALLTHROUGH */
    Caso OPR_LEN:
      codeunexpval(fs, unopr2op(opr), e, Linha);
      Interrompa;
    Caso OPR_NOT: codenot(fs, e); Interrompa;
    Padrão: sol_assert(0);
  }
}


/*
** Process 1st operand 'v' of binary operation 'op' before reading
** 2nd operand.
*/
Vazio sol_k_infix (FuncState *fs, BinOpr op, expdesc *v) {
  sol_k_dischargevars(fs, v);
  Troque (op) {
    Caso OPR_AND: {
      sol_k_goiftrue(fs, v);  /* go ahead only Se 'v' is true */
      Interrompa;
    }
    Caso OPR_OR: {
      sol_k_goiffalse(fs, v);  /* go ahead only Se 'v' is false */
      Interrompa;
    }
    Caso OPR_CONCAT: {
      sol_k_exp2nextreg(fs, v);  /* operand must be on the stack */
      Interrompa;
    }
    Caso OPR_ADD: Caso OPR_SUB:
    Caso OPR_MUL: Caso OPR_DIV: Caso OPR_IDIV:
    Caso OPR_MOD: Caso OPR_POW:
    Caso OPR_BAND: Caso OPR_BOR: Caso OPR_BXOR:
    Caso OPR_SHL: Caso OPR_SHR: {
      Se (!tonumeral(v, NULL))
        sol_k_exp2anyreg(fs, v);
      /* Senão keep numeral, which may be folded or used as an immediate
         operand */
      Interrompa;
    }
    Caso OPR_EQ: Caso OPR_NE: {
      Se (!tonumeral(v, NULL))
        exp2RK(fs, v);
      /* Senão keep numeral, which may be an immediate operand */
      Interrompa;
    }
    Caso OPR_LT: Caso OPR_LE:
    Caso OPR_GT: Caso OPR_GE: {
      Inteiro dummy, dummy2;
      Se (!isSCnumber(v, &dummy, &dummy2))
        sol_k_exp2anyreg(fs, v);
      /* Senão keep numeral, which may be an immediate operand */
      Interrompa;
    }
    Padrão: sol_assert(0);
  }
}

/*
** Create code Para '(e1 .. e2)'.
** For '(e1 .. e2.1 .. e2.2)' (which is '(e1 .. (e2.1 .. e2.2))',
** because concatenation is right associative), merge both CONCATs.
*/
Fixo Vazio codeconcat (FuncState *fs, expdesc *e1, expdesc *e2, Inteiro Linha) {
  Instruction *ie2 = previousinstruction(fs);
  Se (GET_OPCODE(*ie2) == OP_CONCAT) {  /* is 'e2' a concatenation? */
    Inteiro n = GETARG_B(*ie2);  /* # of elements concatenated in 'e2' */
    sol_assert(e1->u.info + 1 == GETARG_A(*ie2));
    freeexp(fs, e2);
    SETARG_A(*ie2, e1->u.info);  /* correct first element ('e1') */
    SETARG_B(*ie2, n + 1);  /* will concatenate one more element */
  }
  Senão {  /* 'e2' is not a concatenation */
    sol_k_codeABC(fs, OP_CONCAT, e1->u.info, 2, 0);  /* new concat opcode */
    freeexp(fs, e2);
    sol_k_fixline(fs, Linha);
  }
}


/*
** Finalize code Para binary operation, after reading 2nd operand.
*/
Vazio sol_k_posfix (FuncState *fs, BinOpr opr,
                  expdesc *e1, expdesc *e2, Inteiro Linha) {
  sol_k_dischargevars(fs, e2);
  Se (foldbinop(opr) && constfolding(fs, cast_int(opr + SOL_OPADD), e1, e2))
    Retorne;  /* done by folding */
  Troque (opr) {
    Caso OPR_AND: {
      sol_assert(e1->t == NO_JUMP);  /* list closed by 'sol_k_infix' */
      sol_k_concat(fs, &e2->f, e1->f);
      *e1 = *e2;
      Interrompa;
    }
    Caso OPR_OR: {
      sol_assert(e1->f == NO_JUMP);  /* list closed by 'sol_k_infix' */
      sol_k_concat(fs, &e2->t, e1->t);
      *e1 = *e2;
      Interrompa;
    }
    Caso OPR_CONCAT: {  /* e1 .. e2 */
      sol_k_exp2nextreg(fs, e2);
      codeconcat(fs, e1, e2, Linha);
      Interrompa;
    }
    Caso OPR_ADD: Caso OPR_MUL: {
      codecommutative(fs, opr, e1, e2, Linha);
      Interrompa;
    }
    Caso OPR_SUB: {
      Se (finishbinexpneg(fs, e1, e2, OP_ADDI, Linha, TM_SUB))
        Interrompa; /* coded as (r1 + -I) */
      /* ELSE */
    }  /* FALLTHROUGH */
    Caso OPR_DIV: Caso OPR_IDIV: Caso OPR_MOD: Caso OPR_POW: {
      codearith(fs, opr, e1, e2, 0, Linha);
      Interrompa;
    }
    Caso OPR_BAND: Caso OPR_BOR: Caso OPR_BXOR: {
      codebitwise(fs, opr, e1, e2, Linha);
      Interrompa;
    }
    Caso OPR_SHL: {
      Se (isSCint(e1)) {
        swapexps(e1, e2);
        codebini(fs, OP_SHLI, e1, e2, 1, Linha, TM_SHL);  /* I << r2 */
      }
      Senão Se (finishbinexpneg(fs, e1, e2, OP_SHRI, Linha, TM_SHL)) {
        /* coded as (r1 >> -I) */;
      }
      Senão  /* regular Caso (two registers) */
       codebinexpval(fs, opr, e1, e2, Linha);
      Interrompa;
    }
    Caso OPR_SHR: {
      Se (isSCint(e2))
        codebini(fs, OP_SHRI, e1, e2, 0, Linha, TM_SHR);  /* r1 >> I */
      Senão  /* regular Caso (two registers) */
        codebinexpval(fs, opr, e1, e2, Linha);
      Interrompa;
    }
    Caso OPR_EQ: Caso OPR_NE: {
      codeeq(fs, opr, e1, e2);
      Interrompa;
    }
    Caso OPR_GT: Caso OPR_GE: {
      /* '(a > b)' <=> '(b < a)';  '(a >= b)' <=> '(b <= a)' */
      swapexps(e1, e2);
      opr = cast(BinOpr, (opr - OPR_GT) + OPR_LT);
    }  /* FALLTHROUGH */
    Caso OPR_LT: Caso OPR_LE: {
      codeorder(fs, opr, e1, e2);
      Interrompa;
    }
    Padrão: sol_assert(0);
  }
}


/*
** Change Linha information associated with current position, by removing
** previous info and adding it again with new Linha.
*/
Vazio sol_k_fixline (FuncState *fs, Inteiro Linha) {
  removelastlineinfo(fs);
  savelineinfo(fs, fs->f, Linha);
}


Vazio sol_k_settablesize (FuncState *fs, Inteiro pc, Inteiro ra, Inteiro asize, Inteiro hsize) {
  Instruction *inst = &fs->f->code[pc];
  Inteiro extra = asize / (MAXARG_vC + 1);  /* higher bits of array size */
  Inteiro rc = asize % (MAXARG_vC + 1);  /* lower bits of array size */
  Inteiro k = (extra > 0);  /* true iff needs extra argument */
  hsize = (hsize != 0) ? sol_o_ceillog2(cast_uint(hsize)) + 1 : 0;
  *inst = CREATE_vABCk(OP_NEWTABLE, ra, hsize, rc, k);
  *(inst + 1) = CREATE_Ax(OP_EXTRAARG, extra);
}


/*
** Emit a SETLIST instruction.
** 'base' is Registrador that keeps table;
** 'nelems' is #table plus those to be stored now;
** 'tostore' is number of values (in registers 'base + 1',...) to add to
** table (or SOL_MULTRET to add up to stack top).
*/
Vazio sol_k_setlist (FuncState *fs, Inteiro base, Inteiro nelems, Inteiro tostore) {
  sol_assert(tostore != 0);
  Se (tostore == SOL_MULTRET)
    tostore = 0;
  Se (nelems <= MAXARG_vC)
    sol_k_codevABCk(fs, OP_SETLIST, base, tostore, nelems, 0);
  Senão {
    Inteiro extra = nelems / (MAXARG_vC + 1);
    nelems %= (MAXARG_vC + 1);
    sol_k_codevABCk(fs, OP_SETLIST, base, tostore, nelems, 1);
    codeextraarg(fs, extra);
  }
  fs->freereg = cast_byte(base + 1);  /* free registers with list values */
}


/*
** Retorne the final target of a jump (skipping jumps to jumps)
*/
Fixo Inteiro finaltarget (Instruction *code, Inteiro i) {
  Inteiro count;
  Para (count = 0; count < 100; count++) {  /* avoid infinite loops */
    Instruction pc = code[i];
    Se (GET_OPCODE(pc) != OP_JMP)
      Interrompa;
    Senão
      i += GETARG_sJ(pc) + 1;
  }
  Retorne i;
}


/*
** Do a final pass over the code of a function, doing small peephole
** optimizations and adjustments.
*/
#Inclua "opnames.int"
Vazio sol_k_finish (FuncState *fs) {
  Inteiro i;
  Proto *p = fs->f;
  Para (i = 0; i < fs->pc; i++) {
    Instruction *pc = &p->code[i];
    /* avoid "not used" warnings when assert is off (Para 'onelua.c') */
    (Vazio)sol_p_isOT; (Vazio)sol_p_isIT;
    sol_assert(i == 0 || sol_p_isOT(*(pc - 1)) == sol_p_isIT(*pc));
    Troque (GET_OPCODE(*pc)) {
      Caso OP_RETURN0: Caso OP_RETURN1: {
        Se (!(fs->needclose || (p->flag & PF_ISVARARG)))
          Interrompa;  /* no extra work */
        /* Senão use OP_RETURN to Faça the extra work */
        SET_OPCODE(*pc, OP_RETURN);
      }  /* FALLTHROUGH */
      Caso OP_RETURN: Caso OP_TAILCALL: {
        Se (fs->needclose)
          SETARG_k(*pc, 1);  /* signal that it needs to close */
        Se (p->flag & PF_ISVARARG)
          SETARG_C(*pc, p->numparams + 1);  /* signal that it is vararg */
        Interrompa;
      }
      Caso OP_JMP: {
        Inteiro target = finaltarget(p->code, i);
        fixjump(fs, i, target);
        Interrompa;
      }
      Padrão: Interrompa;
    }
  }
}
