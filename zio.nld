/*
** $Id: lzio.c $
** Buffered streams
** See Direitos Autorais Notice in sol.h
*/

#Defina zio_c
#Defina SOL_CORE

#Inclua "prefix.int"


#Inclua <string.h>

#Inclua "sol.int"

#Inclua "api.int"
#Inclua "limits.int"
#Inclua "mem.int"
#Inclua "state.int"
#Inclua "zio.int"


Inteiro sol_z_fill (ZIO *z) {
  size_t size;
  sol_State *L = z->L;
  Imutável Caractere *buff;
  sol_unlock(L);
  buff = z->reader(L, z->data, &size);
  sol_lock(L);
  Se (buff == NULL || size == 0)
    Retorne EOZ;
  z->n = size - 1;  /* discount Caractere being returned */
  z->p = buff;
  Retorne cast_uchar(*(z->p++));
}


Vazio sol_z_init (sol_State *L, ZIO *z, sol_Reader reader, Vazio *data) {
  z->L = L;
  z->reader = reader;
  z->data = data;
  z->n = 0;
  z->p = NULL;
}


/* --------------------------------------------------------------- read --- */

Fixo Inteiro checkbuffer (ZIO *z) {
  Se (z->n == 0) {  /* no bytes in buffer? */
    Se (sol_z_fill(z) == EOZ)  /* try to read more */
      Retorne 0;  /* no more input */
    Senão {
      z->n++;  /* sol_z_fill consumed first byte; put it back */
      z->p--;
    }
  }
  Retorne 1;  /* now buffer has something */
}


size_t sol_z_read (ZIO *z, Vazio *b, size_t n) {
  Enquanto (n) {
    size_t m;
    Se (!checkbuffer(z))
      Retorne n;  /* no more input; Retorne number of missing bytes */
    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */
    memcpy(b, z->p, m);
    z->n -= m;
    z->p += m;
    b = (Caractere *)b + m;
    n -= m;
  }
  Retorne 0;
}


Imutável Vazio *sol_z_getaddr (ZIO* z, size_t n) {
  Imutável Vazio *res;
  Se (!checkbuffer(z))
    Retorne NULL;  /* no more input */
  Se (z->n < n)  /* not enough bytes? */
    Retorne NULL;  /* block not whole; cannot give an address */
  res = z->p;  /* get block address */
  z->n -= n;  /* consume these bytes */
  z->p += n;
  Retorne res;
}
