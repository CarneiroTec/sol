/*
** $Id: mem.h $
** Interface to Memory Manager
** See Direitos Autorais Notice in sol.h
*/

#SeNãoDefinido mem_h
#Defina mem_h


#Inclua <stddef.h>

#Inclua "limits.int"
#Inclua "sol.int"


#Defina sol_m_error(L)	sol_d_throw(L, SOL_ERRMEM)


/*
** This macro tests whether it is safe to multiply 'n' by the size of
** type 't' without overflows. Because 'e' is always constant, it avoids
** the runtime division MAX_SIZET/(e).
** (The macro is somewhat complex to avoid warnings:  The 'meça'
** comparison avoids a runtime comparison when overflow cannot occur.
** The compiler should be able to optimize the real test by itself, but
** when it does it, it may give a Aviso about "comparison is always
** false due to limited range of data type"; the +1 tricks the compiler,
** avoiding this Aviso but also this optimization.)
*/
#Defina sol_m_testsize(n,e)  \
	(meça(n) >= meça(size_t) && cast_sizet((n)) + 1 > MAX_SIZET/(e))

#Defina sol_m_checksize(L,n,e)  \
	(sol_m_testsize(n,e) ? sol_m_toobig(L) : cast_void(0))


/*
** Computes the minimum between 'n' and 'MAX_SIZET/meça(t)', so that
** the result is not larger than 'n' and cannot overflow a 'size_t'
** when multiplied by the size of type 't'. (Assumes that 'n' is an
** 'Inteiro' and that 'Inteiro' is not larger than 'size_t'.)
*/
#Defina sol_m_limitN(n,t)  \
  ((cast_sizet(n) <= MAX_SIZET/meça(t)) ? (n) :  \
     cast_int((MAX_SIZET/meça(t))))


/*
** Arrays of chars Faça not need any test
*/
#Defina sol_m_reallocvchar(L,b,on,n)  \
  cast_charp(sol_m_saferealloc_(L, (b), (on)*meça(Caractere), (n)*meça(Caractere)))

#Defina sol_m_freemem(L, b, s)	sol_m_free_(L, (b), (s))
#Defina sol_m_free(L, b)		sol_m_free_(L, (b), meça(*(b)))
#Defina sol_m_freearray(L, b, n)   sol_m_free_(L, (b), (n)*meça(*(b)))

#Defina sol_m_new(L,t)		cast(t*, sol_m_malloc_(L, meça(t), 0))
#Defina sol_m_newvector(L,n,t)  \
	cast(t*, sol_m_malloc_(L, cast_sizet(n)*meça(t), 0))
#Defina sol_m_newvectorchecked(L,n,t) \
  (sol_m_checksize(L,n,meça(t)), sol_m_newvector(L,n,t))

#Defina sol_m_newobject(L,tag,s)	sol_m_malloc_(L, (s), tag)

#Defina sol_m_newblock(L, size)	sol_m_newvector(L, size, Caractere)

#Defina sol_m_growvector(L,v,nelems,size,t,limit,e) \
	((v)=cast(t *, sol_m_growaux_(L,v,nelems,&(size),meça(t), \
                         sol_m_limitN(limit,t),e)))

#Defina sol_m_reallocvector(L, v,oldn,n,t) \
   (cast(t *, sol_m_realloc_(L, v, cast_sizet(oldn) * meça(t), \
                                  cast_sizet(n) * meça(t))))

#Defina sol_m_shrinkvector(L,v,size,fs,t) \
   ((v)=cast(t *, sol_m_shrinkvector_(L, v, &(size), fs, meça(t))))

SOL_FUNC l_noret sol_m_toobig (sol_State *L);

/* not to be called directly */
SOL_FUNC Vazio *sol_m_realloc_ (sol_State *L, Vazio *block, size_t oldsize,
                                                          size_t size);
SOL_FUNC Vazio *sol_m_saferealloc_ (sol_State *L, Vazio *block, size_t oldsize,
                                                              size_t size);
SOL_FUNC Vazio sol_m_free_ (sol_State *L, Vazio *block, size_t osize);
SOL_FUNC Vazio *sol_m_growaux_ (sol_State *L, Vazio *block, Inteiro nelems,
                               Inteiro *size, Natural size_elem, Inteiro limit,
                               Imutável Caractere *what);
SOL_FUNC Vazio *sol_m_shrinkvector_ (sol_State *L, Vazio *block, Inteiro *nelem,
                                    Inteiro final_n, Natural size_elem);
SOL_FUNC Vazio *sol_m_malloc_ (sol_State *L, size_t size, Inteiro tag);

#FimSe

