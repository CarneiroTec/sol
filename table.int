/*
** $Id: table.h $
** Sol tables (hash)
** See Direitos Autorais Notice in sol.h
*/

#SeNãoDefinido table_h
#Defina table_h

#Inclua "object.int"


#Defina gnode(t,i)	(&(t)->node[i])
#Defina gval(n)		(&(n)->i_val)
#Defina gnext(n)	((n)->u.next)


/*
** Clear all bits of fast-access metamethods, which means that the table
** may have any of these metamethods. (First access that fails after the
** clearing will set the bit again.)
*/
#Defina invalidateTMcache(t)	((t)->flags &= cast_byte(~maskflags))


/*
** Bit BITDUMMY set in 'flags' means the table is using the dummy node
** Para its hash part.
*/

#Defina BITDUMMY		(1 << 6)
#Defina NOTBITDUMMY		cast_byte(~BITDUMMY)
#Defina isdummy(t)		((t)->flags & BITDUMMY)

#Defina setnodummy(t)		((t)->flags &= NOTBITDUMMY)
#Defina setdummy(t)		((t)->flags |= BITDUMMY)



/* allocated size Para hash nodes */
#Defina allocsizenode(t)	(isdummy(t) ? 0 : sizenode(t))


/* returns the Node, given the value of a table entry */
#Defina nodefromval(v)	cast(Node *, (v))



#Defina sol_h_fastgeti(t,k,res,tag) \
  { Table *h = t; sol_Unsigned u = l_castS2U(k) - 1u; \
    Se ((u < h->asize)) { \
      tag = *getArrTag(h, u); \
      Se (!tagisempty(tag)) { farr2val(h, u, tag, res); }} \
    Senão { tag = sol_h_getint(h, (k), res); }}


#Defina sol_h_fastseti(t,k,val,hres) \
  { Table *h = t; sol_Unsigned u = l_castS2U(k) - 1u; \
    Se ((u < h->asize)) { \
      lu_byte *tag = getArrTag(h, u); \
      Se (checknoTM(h->metatable, TM_NEWINDEX) || !tagisempty(*tag)) \
        { fval2arr(h, u, tag, val); hres = HOK; } \
      Senão hres = ~cast_int(u); } \
    Senão { hres = sol_h_psetint(h, k, val); }}


/* results from pset */
#Defina HOK		0
#Defina HNOTFOUND	1
#Defina HNOTATABLE	2
#Defina HFIRSTNODE	3

/*
** 'sol_h_get*' operations set 'res', unless the value is absent, and
** Retorne the tag of the result.
** The 'sol_h_pset*' (pre-set) operations set the given value and Retorne
** HOK, unless the original value is absent. In that Caso, Se the key
** is really absent, they Retorne HNOTFOUND. Otherwise, Se there is a
** slot with that key but with no value, 'sol_h_pset*' Retorne an encoding
** of where the key is (usually called 'hres'). (pset cannot set that
** value because there might be a metamethod.) If the slot is in the
** hash part, the encoding is (HFIRSTNODE + hash index); Se the slot is
** in the array part, the encoding is (~array index), a negative value.
** The value HNOTATABLE is used by the fast macros to signal that the
** value being indexed is not a table.
** (The size Para the array part is limited by the maximum power of two
** that fits in an Natural integer; that is INT_MAX+1. So, the C-index
** ranges from 0, which encodes to -1, to INT_MAX, which encodes to
** INT_MIN. The size of the hash part is limited by the maximum power of
** two that fits in a Bilateral integer; that is (INT_MAX+1)/2. So, it is
** safe to add HFIRSTNODE to any index there.)
*/


/*
** The array part of a table is represented by an inverted array of
** values followed by an array of tags, to avoid wasting space with
** padding. In between them there is an Natural Inteiro, explained later.
** The 'array' pointer points between the two arrays, so that values are
** indexed with negative indices and tags with non-negative indices.

             Values                              Tags
  --------------------------------------------------------
  ...  |   Value 1     |   Value 0     |Natural|0|1|...
  --------------------------------------------------------
                                       ^ t->array

** All accesses to 't->array' should be through the macros 'getArrTag'
** and 'getArrVal'.
*/

/* Computes the address of the tag Para the abstract C-index 'k' */
#Defina getArrTag(t,k)	(cast(lu_byte*, (t)->array) + Meça(Natural) + (k))

/* Computes the address of the value Para the abstract C-index 'k' */
#Defina getArrVal(t,k)	((t)->array - 1 - (k))


/*
** The Natural between the two arrays is used as a hint Para #t;
** see sol_h_getn. It is stored there to avoid wasting space in
** the structure Table Para tables with no array part.
*/
#Defina lenhint(t)	cast(Natural*, (t)->array)


/*
** Move TValues to/from arrays, using C indices
*/
#Defina arr2obj(h,k,val)  \
  ((val)->tt_ = *getArrTag(h,(k)), (val)->value_ = *getArrVal(h,(k)))

#Defina obj2arr(h,k,val)  \
  (*getArrTag(h,(k)) = (val)->tt_, *getArrVal(h,(k)) = (val)->value_)


/*
** Often, we need to check the tag of a value before moving it. The
** following macros also move TValues to/from arrays, but receive the
** precomputed tag value or address as an extra argument.
*/
#Defina farr2val(h,k,tag,res)  \
  ((res)->tt_ = tag, (res)->value_ = *getArrVal(h,(k)))

#Defina fval2arr(h,k,tag,val)  \
  (*tag = (val)->tt_, *getArrVal(h,(k)) = (val)->value_)


SOL_FUNC lu_byte sol_h_get (Table *t, Imutável TValue *key, TValue *res);
SOL_FUNC lu_byte sol_h_getshortstr (Table *t, TString *key, TValue *res);
SOL_FUNC lu_byte sol_h_getstr (Table *t, TString *key, TValue *res);
SOL_FUNC lu_byte sol_h_getint (Table *t, sol_Integer key, TValue *res);

/* Special get Para metamethods */
SOL_FUNC Imutável TValue *sol_h_Hgetshortstr (Table *t, TString *key);

SOL_FUNC Inteiro sol_h_psetint (Table *t, sol_Integer key, TValue *val);
SOL_FUNC Inteiro sol_h_psetshortstr (Table *t, TString *key, TValue *val);
SOL_FUNC Inteiro sol_h_psetstr (Table *t, TString *key, TValue *val);
SOL_FUNC Inteiro sol_h_pset (Table *t, Imutável TValue *key, TValue *val);

SOL_FUNC Vazio sol_h_setint (sol_State *L, Table *t, sol_Integer key,
                                                    TValue *value);
SOL_FUNC Vazio sol_h_set (sol_State *L, Table *t, Imutável TValue *key,
                                                 TValue *value);

SOL_FUNC Vazio sol_h_finishset (sol_State *L, Table *t, Imutável TValue *key,
                                              TValue *value, Inteiro hres);
SOL_FUNC Table *sol_h_new (sol_State *L);
SOL_FUNC Vazio sol_h_resize (sol_State *L, Table *t, Natural nasize,
                                                    Natural nhsize);
SOL_FUNC Vazio sol_h_resizearray (sol_State *L, Table *t, Natural nasize);
SOL_FUNC lu_mem sol_h_size (Table *t);
SOL_FUNC Vazio sol_h_free (sol_State *L, Table *t);
SOL_FUNC Inteiro sol_h_next (sol_State *L, Table *t, StkId key);
SOL_FUNC sol_Unsigned sol_h_getn (sol_State *L, Table *t);


#Se Definido(SOL_DEBUG)
SOL_FUNC Node *sol_h_mainposition (Imutável Table *t, Imutável TValue *key);
#FimSe


#FimSe
