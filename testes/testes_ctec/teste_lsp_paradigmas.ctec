/*
** teste_lsp_paradigmas.ctec - Testes dos 4 paradigmas Sol
** 
** Baseado em docs/pages/paradigma-*.php
** 
** 1. IMPERATIVO: variáveis, loops, execute/rótulos
** 2. PROCEDURAL: funções nomeadas, parâmetros, retorno
** 3. FUNCIONAL: funções anônimas, closures, alta ordem
** 4. OO: tabelas, metamétodos, ego/:
*/

#Defina teste_paradigmas_c
#Defina SOL_LIB

#Inclua "prefix.int"
#Inclua <stdio.h>
#Inclua <stdlib.h>
#Inclua <string.h>
#Inclua "sol.int"
#Inclua "auxlib.int"
#Inclua "solib.int"
#Inclua "lsp.int"

#Defina TESTE_OK 0
#Defina TESTE_FALHA 1

Fixo Caractere ultimo_erro[512] = "";

Fixo Vazio registra_erro(Imutável Caractere *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vsnprintf(ultimo_erro, 512, fmt, args);
    va_end(args);
}

Fixo Vazio imprime(Imutável Caractere *paradigma, Imutável Caractere *teste, Inteiro ok) {
    printf("[%s][%s] %s%s\n", paradigma, teste, ok ? "OK" : "FALHA", ok ? "" : ultimo_erro);
    fflush(stdout);
}

/* Função auxiliar: analisa código e verifica variáveis */
Fixo Inteiro verifica_variaveis(Imutável Caractere *codigo, Inteiro expect_count, Imutável Caractere *expect_name) {
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    LSPDocument *doc = lsp_add_document(lsp, "file:///teste.sol", codigo);
    Se (!doc) { lsp_shutdown(lsp); sol_close(L); registra_erro(": doc NULL"); Retorne TESTE_FALHA; }
    
    lsp_analyze_document(lsp, doc);
    
    Inteiro resultado = TESTE_OK;
    
    Se (expect_count >= 0 && doc->variableCount != expect_count) {
        registra_erro(": esperava %d vars, tem %d", expect_count, doc->variableCount);
        resultado = TESTE_FALHA;
    }
    
    Se (expect_name && resultado == TESTE_OK) {
        Inteiro achou = 0;
        Para (Inteiro i = 0; i < doc->variableCount; i++) {
            Se (strcmp(doc->variables[i].name, expect_name) == 0) { achou = 1; Interrompa; }
        }
        Se (!achou) { registra_erro(": não encontrou '%s'", expect_name); resultado = TESTE_FALHA; }
    }
    
    lsp_shutdown(lsp);
    sol_close(L);
    Retorne resultado;
}

/* Função auxiliar: verifica se variável tem campos */
Fixo Inteiro verifica_campos(Imutável Caractere *codigo, Imutável Caractere *var_name, Imutável Caractere *field_name) {
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    LSPDocument *doc = lsp_add_document(lsp, "file:///teste.sol", codigo);
    Se (!doc) { lsp_shutdown(lsp); sol_close(L); registra_erro(": doc NULL"); Retorne TESTE_FALHA; }
    
    lsp_analyze_document(lsp, doc);
    
    Inteiro resultado = TESTE_FALHA;
    registra_erro(": var '%s' não encontrada", var_name);
    
    Para (Inteiro i = 0; i < doc->variableCount; i++) {
        Se (strcmp(doc->variables[i].name, var_name) == 0) {
            Se (!field_name) { resultado = TESTE_OK; Interrompa; }
            Para (Inteiro j = 0; j < doc->variables[i].fieldCount; j++) {
                Se (strcmp(doc->variables[i].fields[j].name, field_name) == 0) {
                    resultado = TESTE_OK;
                    Interrompa;
                }
            }
            Se (resultado == TESTE_FALHA) {
                registra_erro(": campo '%s' não encontrado em '%s'", field_name, var_name);
            }
            Interrompa;
        }
    }
    
    lsp_shutdown(lsp);
    sol_close(L);
    Retorne resultado;
}

/* Função auxiliar: só verifica se não crashou */
Fixo Inteiro nao_crashou(Imutável Caractere *codigo) {
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    LSPDocument *doc = lsp_add_document(lsp, "file:///teste.sol", codigo);
    Se (doc) lsp_analyze_document(lsp, doc);
    lsp_shutdown(lsp);
    sol_close(L);
    Retorne TESTE_OK;
}

/* ============================================================
** PARADIGMA IMPERATIVO
** - Variáveis mutáveis
** - Loops (para, enquanto, repita)
** - execute/rótulos (goto/labels)
** ============================================================ */

Inteiro teste_imperativo_variaveis() {
    /* local contador = 0; contador = contador + 1 */
    Retorne verifica_variaveis(
        "local contador = 0\n"
        "contador = contador + 1\n"
        "contador = contador + 1\n",
        1, "contador");
}

Inteiro teste_imperativo_loops() {
    /* para i = 1, 5 faça soma = soma + i fim */
    Retorne verifica_variaveis(
        "local soma = 0\n"
        "para i = 1, 5 faça\n"
        "    soma = soma + i\n"
        "fim\n",
        -1, "soma");
}

Inteiro teste_imperativo_execute() {
    /* ::rotulo:: execute ::rotulo:: */
    Retorne nao_crashou(
        "local x = 0\n"
        "::inicio::\n"
        "x = x + 1\n"
        "se x < 5 então\n"
        "    execute ::inicio::\n"
        "fim\n"
        "::fim::\n");
}

Inteiro teste_imperativo_enquanto() {
    Retorne nao_crashou(
        "local i = 0\n"
        "enquanto i < 10 faça\n"
        "    i = i + 1\n"
        "fim\n");
}

/* ============================================================
** PARADIGMA PROCEDURAL
** - Funções nomeadas
** - Parâmetros
** - Retorno simples e múltiplo
** ============================================================ */

Inteiro teste_procedural_funcao_simples() {
    /* função soma(a, b) retorne a + b fim */
    /* Espera: soma + parâmetros a, b = 3 variáveis */
    Retorne verifica_variaveis(
        "função soma(a, b)\n"
        "    retorne a + b\n"
        "fim\n",
        3, "soma");
}

Inteiro teste_procedural_funcao_local() {
    /* local função nome() fim */
    /* Espera: valide + parâmetro x = 2 variáveis */
    Retorne verifica_variaveis(
        "local função valide(x)\n"
        "    retorne x > 0\n"
        "fim\n",
        2, "valide");
}

Inteiro teste_procedural_retorno_multiplo() {
    /* retorne a, b, c */
    Retorne nao_crashou(
        "função divide(a, b)\n"
        "    se b == 0 então\n"
        "        retorne nulo, \"divisão por zero\"\n"
        "    fim\n"
        "    retorne a / b, nulo\n"
        "fim\n"
        "local resultado, erro = divide(10, 2)\n");
}

Inteiro teste_procedural_chamada_aninhada() {
    Retorne nao_crashou(
        "função f(x) retorne x + 1 fim\n"
        "função g(x) retorne x * 2 fim\n"
        "local resultado = f(g(5))\n");
}

/* ============================================================
** PARADIGMA FUNCIONAL
** - Funções anônimas (lambda)
** - Funções como valores
** - Closures
** - Alta ordem (map, filter, reduce)
** ============================================================ */

Inteiro teste_funcional_anonima() {
    /* local dobro = função(x) retorne x * 2 fim */
    Retorne verifica_variaveis(
        "local dobro = função(x) retorne x * 2 fim\n",
        1, "dobro");
}

Inteiro teste_funcional_alta_ordem() {
    /* função map(lista, f) ... f(valor) ... fim */
    Retorne nao_crashou(
        "função map(lista, f)\n"
        "    local resultado = {}\n"
        "    para i, valor em obtenha_pares_indexados(lista) faça\n"
        "        tabela.insira(resultado, f(valor))\n"
        "    fim\n"
        "    retorne resultado\n"
        "fim\n"
        "local quadrados = map({1, 2, 3}, função(x) retorne x ^ 2 fim)\n");
}

Inteiro teste_funcional_closure() {
    /* função externa que retorna função interna */
    Retorne nao_crashou(
        "função some(a)\n"
        "    retorne função(b)\n"
        "        retorne a + b\n"
        "    fim\n"
        "fim\n"
        "local some_5 = some(5)\n"
        "local resultado = some_5(3)\n");
}

Inteiro teste_funcional_composicao() {
    /* função componha(f, g) retorne função(x) retorne f(g(x)) fim fim */
    Retorne nao_crashou(
        "função componha(f, g)\n"
        "    retorne função(x)\n"
        "        retorne f(g(x))\n"
        "    fim\n"
        "fim\n"
        "local dobro = função(x) retorne x * 2 fim\n"
        "local inc = função(x) retorne x + 1 fim\n"
        "local f = componha(inc, dobro)\n");
}

/* ============================================================
** PARADIGMA ORIENTADO A OBJETOS
** - Tabelas como classes
** - __índice para herança
** - : para métodos (ego implícito)
** - __chame para construtores
** ============================================================ */

Inteiro teste_oo_classe_simples() {
    /* local Pessoa = {} Pessoa.__índice = Pessoa */
    Retorne verifica_campos(
        "local Pessoa = {}\n"
        "Pessoa.__índice = Pessoa\n"
        "função Pessoa.apresente(ego)\n"
        "    exiba(ego.nome)\n"
        "fim\n",
        "Pessoa", "__índice");
}

Inteiro teste_oo_metodo() {
    /* função Classe.metodo(ego) fim */
    Retorne verifica_campos(
        "local Animal = {}\n"
        "Animal.__índice = Animal\n"
        "função Animal.fale(ego)\n"
        "    exiba(ego.nome .. \" faz som\")\n"
        "fim\n"
        "função Animal.coma(ego)\n"
        "    exiba(ego.nome .. \" come\")\n"
        "fim\n",
        "Animal", "fale");
}

Inteiro teste_oo_construtor() {
    /* __chame para criar instâncias */
    Retorne nao_crashou(
        "local Pessoa = {}\n"
        "Pessoa.__índice = Pessoa\n"
        "defina_metatabela(Pessoa, {\n"
        "    __chame = função(classe, nome, idade)\n"
        "        local ego = defina_metatabela({}, classe)\n"
        "        ego.nome = nome\n"
        "        ego.idade = idade\n"
        "        retorne ego\n"
        "    fim\n"
        "})\n"
        "local p = Pessoa(\"Ana\", 25)\n");
}

Inteiro teste_oo_heranca() {
    /* Classe filha com __índice apontando para pai */
    Retorne nao_crashou(
        "local Animal = {}\n"
        "Animal.__índice = Animal\n"
        "função Animal.fale(ego) exiba(\"som\") fim\n"
        "\n"
        "local Cachorro = defina_metatabela({}, {__índice = Animal})\n"
        "Cachorro.__índice = Cachorro\n"
        "função Cachorro.fale(ego) exiba(\"au au\") fim\n"
        "função Cachorro.busque(ego) exiba(\"buscando\") fim\n");
}

/* ============================================================
** Função Principal
** ============================================================ */

Inteiro Início() {
    printf("\n=== TESTES LSP: PARADIGMAS SOL ===\n\n"); fflush(stdout);
    
    Inteiro total = 0, passou = 0;
    
    #Defina EXECUTA(paradigma, nome, func) \
        total++; \
        Se (func() == TESTE_OK) { passou++; imprime(paradigma, nome, 1); } \
        Senão { imprime(paradigma, nome, 0); }
    
    printf("--- IMPERATIVO ---\n"); fflush(stdout);
    EXECUTA("IMPERATIVO", "variaveis mutaveis", teste_imperativo_variaveis);
    EXECUTA("IMPERATIVO", "loops para", teste_imperativo_loops);
    EXECUTA("IMPERATIVO", "execute/rotulos", teste_imperativo_execute);
    EXECUTA("IMPERATIVO", "enquanto", teste_imperativo_enquanto);
    
    printf("\n--- PROCEDURAL ---\n"); fflush(stdout);
    EXECUTA("PROCEDURAL", "funcao simples", teste_procedural_funcao_simples);
    EXECUTA("PROCEDURAL", "funcao local", teste_procedural_funcao_local);
    EXECUTA("PROCEDURAL", "retorno multiplo", teste_procedural_retorno_multiplo);
    EXECUTA("PROCEDURAL", "chamada aninhada", teste_procedural_chamada_aninhada);
    
    printf("\n--- FUNCIONAL ---\n"); fflush(stdout);
    EXECUTA("FUNCIONAL", "funcao anonima", teste_funcional_anonima);
    EXECUTA("FUNCIONAL", "alta ordem", teste_funcional_alta_ordem);
    EXECUTA("FUNCIONAL", "closure", teste_funcional_closure);
    EXECUTA("FUNCIONAL", "composicao", teste_funcional_composicao);
    
    printf("\n--- ORIENTADO A OBJETOS ---\n"); fflush(stdout);
    EXECUTA("OO", "classe simples", teste_oo_classe_simples);
    EXECUTA("OO", "metodos", teste_oo_metodo);
    EXECUTA("OO", "construtor __chame", teste_oo_construtor);
    EXECUTA("OO", "heranca", teste_oo_heranca);
    
    printf("\n=== RESULTADO: %d/%d testes passaram ===\n", passou, total); fflush(stdout);
    
    Retorne (passou == total) ? 0 : 1;
}
