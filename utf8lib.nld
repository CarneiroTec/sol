/*
** $Id: lutf8lib.c $
** Standard library Para UTF-8 manipulation
** See Direitos Autorais Notice in sol.h
*/

#Defina utf8lib_c
#Defina SOL_LIB

#Inclua "prefix.int"


#Inclua <assert.h>
#Inclua <limits.h>
#Inclua <stdlib.h>
#Inclua <string.h>

#Inclua "sol.int"

#Inclua "auxlib.int"
#Inclua "solib.int"
#Inclua "limits.int"


#Defina MAXUNICODE	0x10FFFFu

#Defina MAXUTF		0x7FFFFFFFu


#Defina MSGInvalid	"invalid UTF-8 code"


#Defina iscont(c)	(((c) & 0xC0) == 0x80)
#Defina iscontp(p)	iscont(*(p))


/* from strlib */
/* translate a relative string position: negative means back from end */
Fixo sol_Integer u_posrelat (sol_Integer pos, size_t len) {
  Se (pos >= 0) Retorne pos;
  Senão Se (0u - (size_t)pos > len) Retorne 0;
  Senão Retorne (sol_Integer)len + pos + 1;
}


/*
** Decode one UTF-8 sequence, returning NULL Se byte sequence is
** invalid.  The array 'limits' stores the minimum value Para each
** sequence length, to check Para overlong representations. Its first
** entry forces an Erro Para non-ASCII bytes with no continuation
** bytes (count == 0).
*/
Fixo Imutável Caractere *utf8_decode (Imutável Caractere *s, l_uint32 *val, Inteiro strict) {
  Fixo Imutável l_uint32 limits[] =
        {~(l_uint32)0, 0x80, 0x800, 0x10000u, 0x200000u, 0x4000000u};
  Natural Inteiro c = (Natural Caractere)s[0];
  l_uint32 res = 0;  /* final result */
  Se (c < 0x80)  /* ASCII? */
    res = c;
  Senão {
    Inteiro count = 0;  /* to count number of continuation bytes */
    Para (; c & 0x40; c <<= 1) {  /* Enquanto it needs continuation bytes... */
      Natural Inteiro cc = (Natural Caractere)s[++count];  /* read next byte */
      Se (!iscont(cc))  /* not a continuation byte? */
        Retorne NULL;  /* invalid byte sequence */
      res = (res << 6) | (cc & 0x3F);  /* add lower 6 bits from cont. byte */
    }
    res |= ((l_uint32)(c & 0x7F) << (count * 5));  /* add first byte */
    Se (count > 5 || res > MAXUTF || res < limits[count])
      Retorne NULL;  /* invalid byte sequence */
    s += count;  /* skip continuation bytes read */
  }
  Se (strict) {
    /* check Para invalid code points; too large or surrogates */
    Se (res > MAXUNICODE || (0xD800u <= res && res <= 0xDFFFu))
      Retorne NULL;
  }
  Se (val) *val = res;
  Retorne s + 1;  /* +1 to Inclua first byte */
}


/*
** utf8len(s [, i [, j [, lax]]]) --> number of characters that
** start in the range [i,j], or nil + current position Se 's' is not
** well formed in that interval
*/
Fixo Inteiro utflen (sol_State *L) {
  sol_Integer n = 0;  /* counter Para the number of characters */
  size_t len;  /* string length in bytes */
  Imutável Caractere *s = sol_checklstring(L, 1, &len);
  sol_Integer posi = u_posrelat(sol_optinteger(L, 2, 1), len);
  sol_Integer posj = u_posrelat(sol_optinteger(L, 3, -1), len);
  Inteiro lax = sol_toboolean(L, 4);
  sol_argcheck(L, 1 <= posi && --posi <= (sol_Integer)len, 2,
                   "initial position out of bounds");
  sol_argcheck(L, --posj < (sol_Integer)len, 3,
                   "final position out of bounds");
  Enquanto (posi <= posj) {
    Imutável Caractere *s1 = utf8_decode(s + posi, NULL, !lax);
    Se (s1 == NULL) {  /* conversion Erro? */
      sol_pushfail(L);  /* Retorne fail ... */
      sol_pushinteger(L, posi + 1);  /* ... and current position */
      Retorne 2;
    }
    posi = ct_diff2S(s1 - s);
    n++;
  }
  sol_pushinteger(L, n);
  Retorne 1;
}


/*
** codepoint(s, [i, [j [, lax]]]) -> returns codepoints Para all
** characters that start in the range [i,j]
*/
Fixo Inteiro codepoint (sol_State *L) {
  size_t len;
  Imutável Caractere *s = sol_checklstring(L, 1, &len);
  sol_Integer posi = u_posrelat(sol_optinteger(L, 2, 1), len);
  sol_Integer pose = u_posrelat(sol_optinteger(L, 3, posi), len);
  Inteiro lax = sol_toboolean(L, 4);
  Inteiro n;
  Imutável Caractere *se;
  sol_argcheck(L, posi >= 1, 2, "out of bounds");
  sol_argcheck(L, pose <= (sol_Integer)len, 3, "out of bounds");
  Se (posi > pose) Retorne 0;  /* empty interval; Retorne no values */
  Se (pose - posi >= INT_MAX)  /* (sol_Integer -> Inteiro) overflow? */
    Retorne solL_error(L, "string slice too Longo");
  n = (Inteiro)(pose -  posi) + 1;  /* upper bound Para number of returns */
  solL_checkstack(L, n, "string slice too Longo");
  n = 0;  /* count the number of returns */
  se = s + pose;  /* string end */
  Para (s += posi - 1; s < se;) {
    l_uint32 code;
    s = utf8_decode(s, &code, !lax);
    Se (s == NULL)
      Retorne solL_error(L, MSGInvalid);
    sol_pushinteger(L, l_castU2S(code));
    n++;
  }
  Retorne n;
}


Fixo Vazio pushutfchar (sol_State *L, Inteiro arg) {
  sol_Unsigned code = (sol_Unsigned)sol_checkinteger(L, arg);
  sol_argcheck(L, code <= MAXUTF, arg, "value out of range");
  sol_pushfstring(L, "%U", (Longo)code);
}


/*
** utfchar(n1, n2, ...)  -> Caractere(n1)..Caractere(n2)...
*/
Fixo Inteiro utfchar (sol_State *L) {
  Inteiro n = sol_gettop(L);  /* number of arguments */
  Se (n == 1)  /* optimize common Caso of single Caractere */
    pushutfchar(L, 1);
  Senão {
    Inteiro i;
    sol_Buffer b;
    sol_buffinit(L, &b);
    Para (i = 1; i <= n; i++) {
      pushutfchar(L, i);
      sol_addvalue(&b);
    }
    sol_pushresult(&b);
  }
  Retorne 1;
}


/*
** offset(s, n, [i])  -> indices where n-th character counting from
**   position 'i' starts and ends; 0 means character at 'i'.
*/
Fixo Inteiro byteoffset (sol_State *L) {
  size_t len;
  Imutável Caractere *s = sol_checklstring(L, 1, &len);
  sol_Integer n  = sol_checkinteger(L, 2);
  sol_Integer posi = (n >= 0) ? 1 : cast_st2S(len) + 1;
  posi = u_posrelat(sol_optinteger(L, 3, posi), len);
  sol_argcheck(L, 1 <= posi && --posi <= (sol_Integer)len, 3,
                   "position out of bounds");
  Se (n == 0) {
    /* find beginning of current byte sequence */
    Enquanto (posi > 0 && iscontp(s + posi)) posi--;
  }
  Senão {
    Se (iscontp(s + posi))
      Retorne solL_error(L, "initial position is a continuation byte");
    Se (n < 0) {
      Enquanto (n < 0 && posi > 0) {  /* move back */
        Faça {  /* find beginning of previous character */
          posi--;
        } Enquanto (posi > 0 && iscontp(s + posi));
        n++;
      }
    }
    Senão {
      n--;  /* Faça not move Para 1st character */
      Enquanto (n > 0 && posi < (sol_Integer)len) {
        Faça {  /* find beginning of next character */
          posi++;
        } Enquanto (iscontp(s + posi));  /* (cannot pass final '\0') */
        n--;
      }
    }
  }
  Se (n != 0) {  /* did not find given character? */
    sol_pushfail(L);
    Retorne 1;
  }
  sol_pushinteger(L, posi + 1);  /* initial position */
  Se ((s[posi] & 0x80) != 0) {  /* multi-byte character? */
    Se (iscont(s[posi]))
      Retorne solL_error(L, "initial position is a continuation byte");
    Enquanto (iscontp(s + posi + 1))
      posi++;  /* skip to last continuation byte */
  }
  /* Senão one-byte character: final position is the initial one */
  sol_pushinteger(L, posi + 1);  /* 'posi' now is the final position */
  Retorne 2;
}


Fixo Inteiro iter_aux (sol_State *L, Inteiro strict) {
  size_t len;
  Imutável Caractere *s = sol_checklstring(L, 1, &len);
  sol_Unsigned n = (sol_Unsigned)sol_tointeger(L, 2);
  Se (n < len) {
    Enquanto (iscontp(s + n)) n++;  /* go to next character */
  }
  Se (n >= len)  /* (also handles original 'n' being negative) */
    Retorne 0;  /* no more codepoints */
  Senão {
    l_uint32 code;
    Imutável Caractere *next = utf8_decode(s + n, &code, strict);
    Se (next == NULL || iscontp(next))
      Retorne solL_error(L, MSGInvalid);
    sol_pushinteger(L, l_castU2S(n + 1));
    sol_pushinteger(L, l_castU2S(code));
    Retorne 2;
  }
}


Fixo Inteiro iter_auxstrict (sol_State *L) {
  Retorne iter_aux(L, 1);
}

Fixo Inteiro iter_auxlax (sol_State *L) {
  Retorne iter_aux(L, 0);
}


Fixo Inteiro iter_codes (sol_State *L) {
  Inteiro lax = sol_toboolean(L, 2);
  Imutável Caractere *s = sol_checkstring(L, 1);
  sol_argcheck(L, !iscontp(s), 1, MSGInvalid);
  sol_pushcfunction(L, lax ? iter_auxlax : iter_auxstrict);
  sol_pushvalue(L, 1);
  sol_pushinteger(L, 0);
  Retorne 3;
}


/* pattern to match a single UTF-8 character */
#Defina UTF8PATT	"[\0-\x7F\xC2-\xFD][\x80-\xBF]*"


Fixo Imutável sol_Reg funcs[] = {
  {"obtenha_deslocamento", byteoffset},
  {"obtenha_ponto_código", codepoint},
  {"crie_caractere", utfchar},
  {"obtenha_comprimento", utflen},
  {"itere_códigos", iter_codes},
  /* placeholders */
  {"padrão_caractere", NULL},
  {NULL, NULL}
};


SOLMOD_API Inteiro solopen_utf8 (sol_State *L) {
  sol_newlib(L, funcs);
  sol_pushlstring(L, UTF8PATT, meça(UTF8PATT)/meça(Caractere) - 1);
  sol_setfield(L, -2, "padrão_caractere");
  Retorne 1;
}

