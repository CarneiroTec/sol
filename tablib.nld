/*
** $Id: ltablib.c $
** Library Para Table Manipulation
** See Direitos Autorais Notice in sol.h
*/

#Defina tablib_c
#Defina SOL_LIB

#Inclua "prefix.int"


#Inclua <limits.h>
#Inclua <stddef.h>
#Inclua <string.h>

#Inclua "sol.int"

#Inclua "auxlib.int"
#Inclua "solib.int"
#Inclua "limits.int"


/*
** Operations that an object must Defina to mimic a table
** (some functions only need some of them)
*/
#Defina TAB_R	1			/* read */
#Defina TAB_W	2			/* write */
#Defina TAB_L	4			/* length */
#Defina TAB_RW	(TAB_R | TAB_W)		/* read/write */


#Defina aux_getn(L,n,w)	(checktab(L, n, (w) | TAB_L), solL_len(L, n))


Fixo Inteiro checkfield (sol_State *L, Imutável Caractere *key, Inteiro n) {
  sol_pushstring(L, key);
  Retorne (sol_rawget(L, -n) != SOL_TNIL);
}


/*
** Check that 'arg' either is a table or can behave like one (that is,
** has a metatable with the required metamethods)
*/
Fixo Vazio checktab (sol_State *L, Inteiro arg, Inteiro what) {
  Se (sol_type(L, arg) != SOL_TTABLE) {  /* is it not a table? */
    Inteiro n = 1;  /* number of elements to pop */
    Se (sol_getmetatable(L, arg) &&  /* must have metatable */
        (!(what & TAB_R) || checkfield(L, "__índice", ++n)) &&
        (!(what & TAB_W) || checkfield(L, "__novo_índice", ++n)) &&
        (!(what & TAB_L) || checkfield(L, "__comprimento", ++n))) {
      sol_pop(L, n);  /* pop metatable and tested metamethods */
    }
    Senão
      sol_checktype(L, arg, SOL_TTABLE);  /* force an Erro */
  }
}


Fixo Inteiro tcreate (sol_State *L) {
  sol_Unsigned sizeseq = (sol_Unsigned)sol_checkinteger(L, 1);
  sol_Unsigned sizerest = (sol_Unsigned)sol_optinteger(L, 2, 0);
  sol_argcheck(L, sizeseq <= cast_uint(INT_MAX), 1, "out of range");
  sol_argcheck(L, sizerest <= cast_uint(INT_MAX), 2, "out of range");
  sol_createtable(L, cast_int(sizeseq), cast_int(sizerest));
  Retorne 1;
}


Fixo Inteiro tinsert (sol_State *L) {
  sol_Integer pos;  /* where to insert new element */
  sol_Integer e = aux_getn(L, 1, TAB_RW);
  e = sol_intop(+, e, 1);  /* first empty element */
  Troque (sol_gettop(L)) {
    Caso 2: {  /* called with only 2 arguments */
      pos = e;  /* insert new element at the end */
      Interrompa;
    }
    Caso 3: {
      sol_Integer i;
      pos = sol_checkinteger(L, 2);  /* 2nd argument is the position */
      /* check whether 'pos' is in [1, e] */
      sol_argcheck(L, (sol_Unsigned)pos - 1u < (sol_Unsigned)e, 2,
                       "position out of bounds");
      Para (i = e; i > pos; i--) {  /* move up elements */
        sol_geti(L, 1, i - 1);
        sol_seti(L, 1, i);  /* t[i] = t[i - 1] */
      }
      Interrompa;
    }
    Padrão: {
      Retorne solL_error(L, "wrong number of arguments to 'insert'");
    }
  }
  sol_seti(L, 1, pos);  /* t[pos] = v */
  Retorne 0;
}


Fixo Inteiro tremove (sol_State *L) {
  sol_Integer size = aux_getn(L, 1, TAB_RW);
  sol_Integer pos = sol_optinteger(L, 2, size);
  Se (pos != size)  /* validate 'pos' Se given */
    /* check whether 'pos' is in [1, size + 1] */
    sol_argcheck(L, (sol_Unsigned)pos - 1u <= (sol_Unsigned)size, 2,
                     "position out of bounds");
  sol_geti(L, 1, pos);  /* result = t[pos] */
  Para ( ; pos < size; pos++) {
    sol_geti(L, 1, pos + 1);
    sol_seti(L, 1, pos);  /* t[pos] = t[pos + 1] */
  }
  sol_pushnil(L);
  sol_seti(L, 1, pos);  /* remove entry t[pos] */
  Retorne 1;
}


/*
** Copy elements (1[f], ..., 1[e]) into (tt[t], tt[t+1], ...). Whenever
** possible, copy in increasing order, which is better Para rehashing.
** "possible" means destination after original range, or smaller
** than origin, or copying to another table.
*/
Fixo Inteiro tmove (sol_State *L) {
  sol_Integer f = sol_checkinteger(L, 2);
  sol_Integer e = sol_checkinteger(L, 3);
  sol_Integer t = sol_checkinteger(L, 4);
  Inteiro tt = !sol_isnoneornil(L, 5) ? 5 : 1;  /* destination table */
  checktab(L, 1, TAB_R);
  checktab(L, tt, TAB_W);
  Se (e >= f) {  /* otherwise, nothing to move */
    sol_Integer n, i;
    sol_argcheck(L, f > 0 || e < SOL_MAXINTEGER + f, 3,
                  "muitos elementos para mover");
    n = e - f + 1;  /* number of elements to move */
    sol_argcheck(L, t <= SOL_MAXINTEGER - n + 1, 4,
                  "destination wrap around");
    Se (t > e || t <= f || (tt != 1 && !sol_compare(L, 1, tt, SOL_OPEQ))) {
      Para (i = 0; i < n; i++) {
        sol_geti(L, 1, f + i);
        sol_seti(L, tt, t + i);
      }
    }
    Senão {
      Para (i = n - 1; i >= 0; i--) {
        sol_geti(L, 1, f + i);
        sol_seti(L, tt, t + i);
      }
    }
  }
  sol_pushvalue(L, tt);  /* Retorne destination table */
  Retorne 1;
}


Fixo Vazio addfield (sol_State *L, sol_Buffer *b, sol_Integer i) {
  sol_geti(L, 1, i);
  Se (l_unlikely(!sol_isstring(L, -1)))
    solL_error(L, "invalid value (%s) at index %I in table Para 'concat'",
                  solL_typename(L, -1), (SOL_UACINT)i);
  sol_addvalue(b);
}


Fixo Inteiro tconcat (sol_State *L) {
  sol_Buffer b;
  sol_Integer last = aux_getn(L, 1, TAB_R);
  size_t lsep;
  Imutável Caractere *sep = sol_optlstring(L, 2, "", &lsep);
  sol_Integer i = sol_optinteger(L, 3, 1);
  last = sol_optinteger(L, 4, last);
  sol_buffinit(L, &b);
  Para (; i < last; i++) {
    addfield(L, &b, i);
    sol_addlstring(&b, sep, lsep);
  }
  Se (i == last)  /* add last value (Se interval was not empty) */
    addfield(L, &b, i);
  sol_pushresult(&b);
  Retorne 1;
}


/*
** {======================================================
** Pack/unpack
** =======================================================
*/

Fixo Inteiro tpack (sol_State *L) {
  Inteiro i;
  Inteiro n = sol_gettop(L);  /* number of elements to pack */
  sol_createtable(L, n, 1);  /* create result table */
  sol_insert(L, 1);  /* put it at index 1 */
  Para (i = n; i >= 1; i--)  /* assign elements */
    sol_seti(L, 1, i);
  sol_pushinteger(L, n);
  sol_setfield(L, 1, "n");  /* t.n = number of elements */
  Retorne 1;  /* Retorne table */
}


Fixo Inteiro tunpack (sol_State *L) {
  sol_Unsigned n;
  sol_Integer i = sol_optinteger(L, 2, 1);
  sol_Integer e = sol_opt(L, sol_checkinteger, 3, solL_len(L, 1));
  Se (i > e) Retorne 0;  /* empty range */
  n = l_castS2U(e) - l_castS2U(i);  /* number of elements minus 1 */
  Se (l_unlikely(n >= (Natural Inteiro)INT_MAX  ||
                 !sol_checkstack(L, (Inteiro)(++n))))
    Retorne solL_error(L, "muitos resultados para desempacotar");
  Para (; i < e; i++) {  /* push arg[i..e - 1] (to avoid overflows) */
    sol_geti(L, 1, i);
  }
  sol_geti(L, 1, e);  /* push last element */
  Retorne (Inteiro)n;
}

/* }====================================================== */



/*
** {======================================================
** Quicksort
** (based on 'Algorithms in MODULA-3', Robert Sedgewick;
**  Addison-Wesley, 1993.)
** =======================================================
*/


/*
** Type Para array indices. These indices are always limited by INT_MAX,
** so it is safe to cast them to sol_Integer even Para Sol 32 bits.
*/
Pseudônimo Natural Inteiro IdxT;


/* Versions of sol_seti/sol_geti specialized Para IdxT */
#Defina geti(L,idt,idx)	sol_geti(L, idt, l_castU2S(idx))
#Defina seti(L,idt,idx)	sol_seti(L, idt, l_castU2S(idx))


/*
** Produce a "random" 'Natural Inteiro' to randomize pivot choice. This
** macro is used only when 'sort' detects a big imbalance in the result
** of a partition. (If you don't want/need this "randomness", ~0 is a
** good choice.)
*/
#Se !Definido(l_randomizePivot)
#Defina l_randomizePivot(L)	sol_makeseed(L)
#FimSe					/* } */


/* arrays larger than 'RANLIMIT' may use randomized pivots */
#Defina RANLIMIT	100u


Fixo Vazio set2 (sol_State *L, IdxT i, IdxT j) {
  seti(L, 1, i);
  seti(L, 1, j);
}


/*
** Return true iff value at stack index 'a' is less than the value at
** index 'b' (according to the order of the sort).
*/
Fixo Inteiro sort_comp (sol_State *L, Inteiro a, Inteiro b) {
  Se (sol_isnil(L, 2))  /* no function? */
    Retorne sol_compare(L, a, b, SOL_OPLT);  /* a < b */
  Senão {  /* function */
    Inteiro res;
    sol_pushvalue(L, 2);    /* push function */
    sol_pushvalue(L, a-1);  /* -1 to compensate function */
    sol_pushvalue(L, b-2);  /* -2 to compensate function and 'a' */
    sol_call(L, 2, 1);      /* call function */
    res = sol_toboolean(L, -1);  /* get result */
    sol_pop(L, 1);          /* pop result */
    Retorne res;
  }
}


/*
** Does the partition: Pivot P is at the top of the stack.
** precondition: a[lo] <= P == a[up-1] <= a[up],
** so it only needs to Faça the partition from lo + 1 to up - 2.
** Pos-condition: a[lo .. i - 1] <= a[i] == P <= a[i + 1 .. up]
** returns 'i'.
*/
Fixo IdxT partition (sol_State *L, IdxT lo, IdxT up) {
  IdxT i = lo;  /* will be incremented before first use */
  IdxT j = up - 1;  /* will be decremented before first use */
  /* loop invariant: a[lo .. i] <= P <= a[j .. up] */
  Para (;;) {
    /* next loop: repeat ++i Enquanto a[i] < P */
    Enquanto ((Vazio)geti(L, 1, ++i), sort_comp(L, -1, -2)) {
      Se (l_unlikely(i == up - 1))  /* a[up - 1] < P == a[up - 1] */
        solL_error(L, "invalid order function Para sorting");
      sol_pop(L, 1);  /* remove a[i] */
    }
    /* after the loop, a[i] >= P and a[lo .. i - 1] < P  (a) */
    /* next loop: repeat --j Enquanto P < a[j] */
    Enquanto ((Vazio)geti(L, 1, --j), sort_comp(L, -3, -1)) {
      Se (l_unlikely(j < i))  /* j <= i - 1 and a[j] > P, contradicts (a) */
        solL_error(L, "invalid order function Para sorting");
      sol_pop(L, 1);  /* remove a[j] */
    }
    /* after the loop, a[j] <= P and a[j + 1 .. up] >= P */
    Se (j < i) {  /* no elements out of place? */
      /* a[lo .. i - 1] <= P <= a[j + 1 .. i .. up] */
      sol_pop(L, 1);  /* pop a[j] */
      /* swap pivot (a[up - 1]) with a[i] to satisfy pos-condition */
      set2(L, up - 1, i);
      Retorne i;
    }
    /* otherwise, swap a[i] - a[j] to restore invariant and repeat */
    set2(L, i, j);
  }
}


/*
** Choose an element in the middle (2nd-3th quarters) of [lo,up]
** "randomized" by 'rnd'
*/
Fixo IdxT choosePivot (IdxT lo, IdxT up, Natural Inteiro rnd) {
  IdxT r4 = (up - lo) / 4;  /* range/4 */
  IdxT p = (rnd ^ lo ^ up) % (r4 * 2) + (lo + r4);
  sol_assert(lo + r4 <= p && p <= up - r4);
  Retorne p;
}


/*
** Quicksort algorithm (recursive function)
*/
Fixo Vazio auxsort (sol_State *L, IdxT lo, IdxT up, Natural rnd) {
  Enquanto (lo < up) {  /* loop Para tail recursion */
    IdxT p;  /* Pivot index */
    IdxT n;  /* to be used later */
    /* sort elements 'lo', 'p', and 'up' */
    geti(L, 1, lo);
    geti(L, 1, up);
    Se (sort_comp(L, -1, -2))  /* a[up] < a[lo]? */
      set2(L, lo, up);  /* swap a[lo] - a[up] */
    Senão
      sol_pop(L, 2);  /* remove both values */
    Se (up - lo == 1)  /* only 2 elements? */
      Retorne;  /* already sorted */
    Se (up - lo < RANLIMIT || rnd == 0)  /* small interval or no randomize? */
      p = (lo + up)/2;  /* middle element is a good pivot */
    Senão  /* Para larger intervals, it is worth a random pivot */
      p = choosePivot(lo, up, rnd);
    geti(L, 1, p);
    geti(L, 1, lo);
    Se (sort_comp(L, -2, -1))  /* a[p] < a[lo]? */
      set2(L, p, lo);  /* swap a[p] - a[lo] */
    Senão {
      sol_pop(L, 1);  /* remove a[lo] */
      geti(L, 1, up);
      Se (sort_comp(L, -1, -2))  /* a[up] < a[p]? */
        set2(L, p, up);  /* swap a[up] - a[p] */
      Senão
        sol_pop(L, 2);
    }
    Se (up - lo == 2)  /* only 3 elements? */
      Retorne;  /* already sorted */
    geti(L, 1, p);  /* get middle element (Pivot) */
    sol_pushvalue(L, -1);  /* push Pivot */
    geti(L, 1, up - 1);  /* push a[up - 1] */
    set2(L, p, up - 1);  /* swap Pivot (a[p]) with a[up - 1] */
    p = partition(L, lo, up);
    /* a[lo .. p - 1] <= a[p] == P <= a[p + 1 .. up] */
    Se (p - lo < up - p) {  /* lower interval is smaller? */
      auxsort(L, lo, p - 1, rnd);  /* call recursively Para lower interval */
      n = p - lo;  /* size of smaller interval */
      lo = p + 1;  /* tail call Para [p + 1 .. up] (upper interval) */
    }
    Senão {
      auxsort(L, p + 1, up, rnd);  /* call recursively Para upper interval */
      n = up - p;  /* size of smaller interval */
      up = p - 1;  /* tail call Para [lo .. p - 1]  (lower interval) */
    }
    Se ((up - lo) / 128 > n) /* partition too imbalanced? */
      rnd = l_randomizePivot(L);  /* try a new randomization */
  }  /* tail call auxsort(L, lo, up, rnd) */
}


Fixo Inteiro sort (sol_State *L) {
  sol_Integer n = aux_getn(L, 1, TAB_RW);
  Se (n > 1) {  /* non-trivial interval? */
    sol_argcheck(L, n < INT_MAX, 1, "array too big");
    Se (!sol_isnoneornil(L, 2))  /* is there a 2nd argument? */
      sol_checktype(L, 2, SOL_TFUNCTION);  /* must be a function */
    sol_settop(L, 2);  /* make sure there are two arguments */
    auxsort(L, 1, (IdxT)n, 0);
  }
  Retorne 0;
}

/* }====================================================== */


Fixo Imutável sol_Reg tab_funcs[] = {
  {"concatene", tconcat},
  {"crie", tcreate},
  {"insira", tinsert},
  {"empacote", tpack},
  {"desempacote", tunpack},
  {"remova", tremove},
  {"mova", tmove},
  {"ordene", sort},
  {NULL, NULL}
};


SOLMOD_API Inteiro solopen_table (sol_State *L) {
  sol_newlib(L, tab_funcs);
  Retorne 1;
}

