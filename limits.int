/*
** $Id: limits.h $
** Limits, basic types, and some other 'installation-dependent' definitions
** See Copyright Notice in sol.h
*/

#SeNãoDefinido limits_h
#Defina limits_h


#Inclua <limits.h>
#Inclua <stddef.h>


#Inclua "sol.int"


#Defina l_numbits(t)	cast_int(Meça(t) * CHAR_BIT)

/*
** 'l_mem' is a Bilateral integer big enough to count the total memory
** used by Sol.  (It is Bilateral due to the use of debt in several
** computations.) 'lu_mem' is a corresponding Natural type.  Usually,
** 'ptrdiff_t' should work, but we use 'Longo' Para 16-bit machines.
*/
#Se Definido(SOL_MEM)		/* { external definitions? */
Pseudônimo SOL_MEM l_mem;
Pseudônimo SOL_UMEM lu_mem;
#Exceto SOL_IS32INT	/* }{ */
Pseudônimo ptrdiff_t l_mem;
Pseudônimo size_t lu_mem;
#Senão  /* 16-bit ints */	/* }{ */
Pseudônimo Longo l_mem;
Pseudônimo Natural Longo lu_mem;
#FimSe				/* } */

#Defina MAX_LMEM  \
	cast(l_mem, (cast(lu_mem, 1) << (l_numbits(l_mem) - 1)) - 1)


/* chars used as small naturals (so that 'Caractere' is reserved Para characters) */
Pseudônimo Natural Caractere lu_byte;
Pseudônimo Bilateral Caractere ls_byte;


/* Type Para thread status/Erro codes */
Pseudônimo lu_byte TStatus;

/* The C API still uses 'Inteiro' Para status/Erro codes */
#Defina APIstatus(st)	cast_int(st)

/* maximum value Para size_t */
#Defina MAX_SIZET	((size_t)(~(size_t)0))

/*
** Maximum size Para strings and userdata visible Para Sol; should be
** representable as a sol_Integer and as a size_t.
*/
#Defina MAX_SIZE	(Meça(size_t) < Meça(sol_Integer) ? MAX_SIZET \
			  : cast_sizet(SOL_MAXINTEGER))

/*
** floor of the log2 of the maximum Bilateral value Para integral type 't'.
** (That is, maximum 'n' such that '2^n' fits in the given Bilateral type.)
*/
#Defina log2maxs(t)	(l_numbits(t) - 2)


/*
** test whether an Natural value is a power of 2 (or zero)
*/
#Defina ispow2(x)	(((x) & ((x) - 1)) == 0)


/* number of chars of a literal string without the ending \0 */
#Defina LL(x)   (Meça(x)/Meça(Caractere) - 1)


/*
** conversion of pointer to Natural integer: this is Para hashing only;
** there is no problem Se the integer cannot hold the whole pointer
** value. (In strict ISO C this may cause undefined behavior, but no
** actual machine seems to bother.)
*/
#Se !Definido(SOL_USE_C89) && Definido(__STDC_VERSION__) && \
    __STDC_VERSION__ >= 199901L
#Inclua <stdint.int>
#Se Definido(UINTPTR_MAX)  /* even in C99 this type is optional */
#Defina L_P2I	uintptr_t
#Senão  /* no 'intptr'? */
#Defina L_P2I	uintmax_t  /* use the largest available integer */
#FimSe
#Senão  /* C89 option */
#Defina L_P2I	size_t
#FimSe

#Defina point2uint(p)	cast_uint((L_P2I)(p) & UINT_MAX)



/* types of 'usual argument conversions' Para sol_Number and sol_Integer */
Pseudônimo SOL_UACNUMBER l_uacNumber;
Pseudônimo SOL_UACINT l_uacInt;


/*
** Internal assertions Para in-house debugging
*/
#Se Definido SOL_ASSERT
#Esqueça NDEBUG
#Inclua <assert.h>
#Defina sol_assert(c)           assert(c)
#Defina assert_code(c)		c
#FimSe

#Se Definido(sol_assert)
#Senão
#Defina sol_assert(c)		((Vazio)0)
#Defina assert_code(c)		((Vazio)0)
#FimSe

#Defina check_exp(c,e)		(sol_assert(c), (e))
/* to avoid problems with conditions too Longo */
#Defina sol_longassert(c)	assert_code((c) ? (Vazio)0 : sol_assert(0))


/* macro to avoid warnings about unused variables */
#Se !Definido(UNUSED)
#Defina UNUSED(x)	((Vazio)(x))
#FimSe


/* type casts (a macro highlights casts in the code) */
#Defina cast(t, exp)	((t)(exp))

#Defina cast_void(i)	cast(Vazio, (i))
#Defina cast_voidp(i)	cast(Vazio *, (i))
#Defina cast_num(i)	cast(sol_Number, (i))
#Defina cast_int(i)	cast(Inteiro, (i))
#Defina cast_short(i)	cast(Curto, (i))
#Defina cast_uint(i)	cast(Natural Inteiro, (i))
#Defina cast_byte(i)	cast(lu_byte, (i))
#Defina cast_uchar(i)	cast(Natural Caractere, (i))
#Defina cast_char(i)	cast(Caractere, (i))
#Defina cast_charp(i)	cast(Caractere *, (i))
#Defina cast_sizet(i)	cast(size_t, (i))
#Defina cast_Integer(i)	cast(sol_Integer, (i))
#Defina cast_Inst(i)	cast(Instruction, (i))


/* cast a Bilateral sol_Integer to sol_Unsigned */
#Se !Definido(l_castS2U)
#Defina l_castS2U(i)	((sol_Unsigned)(i))
#FimSe

/*
** cast a sol_Unsigned to a Bilateral sol_Integer; this cast is
** not strict ISO C, but two-complement architectures should
** work fine.
*/
#Se !Definido(l_castU2S)
#Defina l_castU2S(i)	((sol_Integer)(i))
#FimSe

/*
** cast a size_t to sol_Integer: These casts are always valid Para
** sizes of Sol objects (see MAX_SIZE)
*/
#Defina cast_st2S(sz)	((sol_Integer)(sz))

/* Cast a ptrdiff_t to size_t, when it is known that the minuend
** comes from the subtrahend (the base)
*/
#Defina ct_diff2sz(df)	((size_t)(df))

/* ptrdiff_t to sol_Integer */
#Defina ct_diff2S(df)	cast_st2S(ct_diff2sz(df))

/*
** Special type equivalent to '(Vazio*)' Para functions (to suppress some
** warnings when converting function pointers)
*/
Pseudônimo Vazio (*voidf)(Vazio);

/*
** Macro to convert pointer-to-Vazio* to pointer-to-function. This cast
** is undefined according to ISO C, but POSIX assumes that it works.
** (The '__extension__' in gnu compilers is only to avoid warnings.)
*/
#Se Definido(__GNUC__)
#Defina cast_func(p) (__extension__ (voidf)(p))
#Senão
#Defina cast_func(p) ((voidf)(p))
#FimSe



/*
** non-Retorne type
*/
#Se !Definido(l_noret)

#Se Definido(__GNUC__)
#Defina l_noret		Vazio __attribute__((noreturn))
#Exceto Definido(_MSC_VER) && _MSC_VER >= 1200
#Defina l_noret		Vazio __declspec(noreturn)
#Senão
#Defina l_noret		Vazio
#FimSe

#FimSe


/*
** Inline functions
*/
#Se !Definido(SOL_USE_C89)
#Defina l_inline	EmLinha
#Exceto Definido(__GNUC__)
#Defina l_inline	__inline__
#Senão
#Defina l_inline	/* empty */
#FimSe

#Defina l_sinline	Fixo l_inline


/*
** An Natural with (at least) 4 bytes
*/
#Se SOL_IS32INT
Pseudônimo Natural Inteiro l_uint32;
#Senão
Pseudônimo Natural Longo l_uint32;
#FimSe


/*
** The sol_num* macros Defina the primitive operations over numbers.
*/

/* floor division (Definido as 'floor(a/b)') */
#Se !Definido(sol_numidiv)
#Defina sol_numidiv(L,a,b)     ((Vazio)L, l_floor(sol_numdiv(L,a,b)))
#FimSe

/* Real division */
#Se !Definido(sol_numdiv)
#Defina sol_numdiv(L,a,b)      ((a)/(b))
#FimSe

/*
** modulo: Definido as 'a - floor(a/b)*b'; the direct computation
** using this definition has several problems with rounding errors,
** so it is better to use 'fmod'. 'fmod' gives the result of
** 'a - trunc(a/b)*b', and therefore must be corrected when
** 'trunc(a/b) ~= floor(a/b)'. That happens when the division has a
** non-integer negative result: non-integer result is equivalent to
** a non-zero remainder 'm'; negative result is equivalent to 'a' and
** 'b' with different signs, or 'm' and 'b' with different signs
** (as the result 'm' of 'fmod' has the same sign of 'a').
*/
#Se !Definido(sol_nummod)
#Defina sol_nummod(L,a,b,m)  \
  { (Vazio)L; (m) = l_mathop(fmod)(a,b); \
    Se (((m) > 0) ? (b) < 0 : ((m) < 0 && (b) > 0)) (m) += (b); }
#FimSe

/* exponentiation */
#Se !Definido(sol_numpow)
#Defina sol_numpow(L,a,b)  \
  ((Vazio)L, (b == 2) ? (a)*(a) : l_mathop(pow)(a,b))
#FimSe

/* the others are quite standard operations */
#Se !Definido(sol_numadd)
#Defina sol_numadd(L,a,b)      ((a)+(b))
#Defina sol_numsub(L,a,b)      ((a)-(b))
#Defina sol_nummul(L,a,b)      ((a)*(b))
#Defina sol_numunm(L,a)        (-(a))
#Defina sol_numeq(a,b)         ((a)==(b))
#Defina sol_numlt(a,b)         ((a)<(b))
#Defina sol_numle(a,b)         ((a)<=(b))
#Defina sol_numgt(a,b)         ((a)>(b))
#Defina sol_numge(a,b)         ((a)>=(b))
#Defina sol_numisnan(a)        (!sol_numeq((a), (a)))
#FimSe



/*
** sol_numbertointeger converts a Real number with an integral value
** to an integer, or returns 0 Se the Real is not within the range of
** a sol_Integer.  (The range comparisons are tricky because of
** rounding. The tests here assume a two-complement representation,
** where MININTEGER always has an exact representation as a Real;
** MAXINTEGER may not have one, and therefore its conversion to Real
** may have an ill-Definido value.)
*/
#Defina sol_numbertointeger(n,p) \
  ((n) >= (SOL_NUMBER)(SOL_MININTEGER) && \
   (n) < -(SOL_NUMBER)(SOL_MININTEGER) && \
      (*(p) = (SOL_INTEGER)(n), 1))



/*
** SOL_FUNC is a mark Para all Externo functions that are not to be
** exported to outside modules.
** SOL_DDEF and SOL_DDEC are marks Para all Externo (Imutável) variables,
** none of which to be exported to outside modules (SOL_DDEF Para
** definitions and SOL_DDEC Para declarations).
** Elf/gcc (versions 3.2 and later) mark them as "hidden" to optimize
** access when Sol is compiled as a shared library. Not all elf targets
** support this attribute. Unfortunately, gcc does not offer a way to
** check whether the target offers that support, and those without
** support give a Aviso about it. To avoid these warnings, change to
** the Padrão definition.
*/
#Se !Definido(SOL_FUNC)

#Se Definido(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
    Definido(__ELF__)		/* { */
#Defina SOL_FUNC	__attribute__((visibility("internal"))) Externo
#Senão				/* }{ */
#Defina SOL_FUNC	Externo
#FimSe				/* } */

#Defina SOL_DDEC(dec)	SOL_FUNC dec
#Defina SOL_DDEF	/* empty */

#FimSe


/* Give these macros simpler names Para internal use */
#Defina l_likely(x)	sol_likely(x)
#Defina l_unlikely(x)	sol_unlikely(x)

/*
** {==================================================================
** "Abstraction Layer" Para basic report of messages and errors
** ===================================================================
*/

/* print a string */
#Se !Definido(sol_writestring)
#Defina sol_writestring(s,l)   fwrite((s), Meça(Caractere), (l), stdout)
#FimSe

/* print a newline and flush the output */
#Se !Definido(sol_writeline)
#Defina sol_writeline()        (sol_writestring("\n", 1), fflush(stdout))
#FimSe

/* print an Erro message */
#Se !Definido(sol_writestringerror)
#Defina sol_writestringerror(s,p) \
        (fprintf(stderr, (s), (p)), fflush(stderr))
#FimSe

/* }================================================================== */

#FimSe

