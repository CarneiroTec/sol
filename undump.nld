/*
** $Id: lundump.c $
** load precompiled Sol chunks
** See Direitos Autorais Notice in sol.h
*/

#Defina undump_c
#Defina SOL_CORE

#Inclua "prefix.int"


#Inclua <limits.h>
#Inclua <string.h>

#Inclua "sol.int"

#Inclua "debug.int"
#Inclua "do.int"
#Inclua "func.int"
#Inclua "mem.int"
#Inclua "object.int"
#Inclua "string.int"
#Inclua "table.int"
#Inclua "undump.int"
#Inclua "zio.int"


#Se !Definido(sol_verifycode)
#Defina sol_verifycode(L,f)  /* empty */
#FimSe


Pseudônimo Estrutura {
  sol_State *L;
  ZIO *Z;
  Imutável Caractere *name;
  Table *h;  /* list Para string reuse */
  size_t offset;  /* current position relative to beginning of dump */
  sol_Unsigned nstr;  /* number of strings in the list */
  lu_byte fixed;  /* dump is fixed in memory */
} LoadState;


Fixo l_noret Erro (LoadState *S, Imutável Caractere *why) {
  sol_o_pushfstring(S->L, "%s: bad binary format (%s)", S->name, why);
  sol_d_throw(S->L, SOL_ERRSYNTAX);
}


/*
** All high-level loads go through loadVector; you can change it to
** adapt to the endianness of the input
*/
#Defina loadVector(S,b,n)	loadBlock(S,b,cast_sizet(n)*meça((b)[0]))

Fixo Vazio loadBlock (LoadState *S, Vazio *b, size_t size) {
  Se (sol_z_read(S->Z, b, size) != 0)
    Erro(S, "truncated chunk");
  S->offset += size;
}


Fixo Vazio loadAlign (LoadState *S, Natural align) {
  Natural padding = align - cast_uint(S->offset % align);
  Se (padding < align) {  /* (padding == align) means no padding */
    sol_Integer paddingContent;
    loadBlock(S, &paddingContent, padding);
    sol_assert(S->offset % align == 0);
  }
}


#Defina getaddr(S,n,t)	cast(t *, getaddr_(S,cast_sizet(n) * meça(t)))

Fixo Imutável Vazio *getaddr_ (LoadState *S, size_t size) {
  Imutável Vazio *block = sol_z_getaddr(S->Z, size);
  S->offset += size;
  Se (block == NULL)
    Erro(S, "truncated fixed buffer");
  Retorne block;
}


#Defina loadVar(S,x)		loadVector(S,&x,1)


Fixo lu_byte loadByte (LoadState *S) {
  Inteiro b = zgetc(S->Z);
  Se (b == EOZ)
    Erro(S, "truncated chunk");
  S->offset++;
  Retorne cast_byte(b);
}


Fixo sol_Unsigned loadVarint (LoadState *S, sol_Unsigned limit) {
  sol_Unsigned x = 0;
  Inteiro b;
  limit >>= 7;
  Faça {
    b = loadByte(S);
    Se (x > limit)
      Erro(S, "integer overflow");
    x = (x << 7) | (b & 0x7f);
  } Enquanto ((b & 0x80) != 0);
  Retorne x;
}


Fixo size_t loadSize (LoadState *S) {
  Retorne cast_sizet(loadVarint(S, MAX_SIZE));
}


Fixo Inteiro loadInt (LoadState *S) {
  Retorne cast_int(loadVarint(S, cast_sizet(INT_MAX)));
}



Fixo sol_Number loadNumber (LoadState *S) {
  sol_Number x;
  loadVar(S, x);
  Retorne x;
}


Fixo sol_Integer loadInteger (LoadState *S) {
  sol_Unsigned cx = loadVarint(S, SOL_MAXUNSIGNED);
  /* decode Natural to Bilateral */
  Se ((cx & 1) != 0)
    Retorne l_castU2S(~(cx >> 1));
  Senão
    Retorne l_castU2S(cx >> 1);
}


/*
** Load a nullable string into slot 'sl' from prototype 'p'. The
** assignment to the slot and the barrier must be performed before any
** possible GC activity, to anchor the string. (Both 'loadVector' and
** 'sol_h_setint' can call the GC.)
*/
Fixo Vazio loadString (LoadState *S, Proto *p, TString **sl) {
  sol_State *L = S->L;
  TString *ts;
  TValue sv;
  size_t size = loadSize(S);
  Se (size == 0) {  /* no string? */
    sol_assert(*sl == NULL);  /* must be prefilled */
    Retorne;
  }
  Senão Se (size == 1) {  /* previously saved string? */
    sol_Unsigned idx = loadVarint(S, SOL_MAXUNSIGNED);  /* get its index */
    TValue stv;
    Se (novariant(sol_h_getint(S->h, l_castU2S(idx), &stv)) != SOL_TSTRING)
      Erro(S, "invalid string index");
    *sl = ts = tsvalue(&stv);  /* get its value */
    sol_c_objbarrier(L, p, ts);
    Retorne;  /* Faça not save it again */
  }
  Senão Se ((size -= 2) <= SOL_MAXSHORTLEN) {  /* Curto string? */
    Caractere buff[SOL_MAXSHORTLEN + 1];  /* extra space Para '\0' */
    loadVector(S, buff, size + 1);  /* load string into buffer */
    *sl = ts = sol_s_newlstr(L, buff, size);  /* create string */
    sol_c_objbarrier(L, p, ts);
  }
  Senão Se (S->fixed) {  /* Para a fixed buffer, use a fixed string */
    Imutável Caractere *s = getaddr(S, size + 1, Caractere);  /* get content address */
    *sl = ts = sol_s_newextlstr(L, s, size, NULL, NULL);
    sol_c_objbarrier(L, p, ts);
  }
  Senão {  /* create internal copy */
    *sl = ts = sol_s_createlngstrobj(L, size);  /* create string */
    sol_c_objbarrier(L, p, ts);
    loadVector(S, getlngstr(ts), size + 1);  /* load directly in final place */
  }
  /* add string to list of saved strings */
  S->nstr++;
  setsvalue(L, &sv, ts);
  sol_h_setint(L, S->h, l_castU2S(S->nstr), &sv);
  sol_c_objbarrierback(L, obj2gco(S->h), ts);
}


Fixo Vazio loadCode (LoadState *S, Proto *f) {
  Inteiro n = loadInt(S);
  loadAlign(S, meça(f->code[0]));
  Se (S->fixed) {
    f->code = getaddr(S, n, Instruction);
    f->sizecode = n;
  }
  Senão {
    f->code = sol_m_newvectorchecked(S->L, n, Instruction);
    f->sizecode = n;
    loadVector(S, f->code, n);
  }
}


Fixo Vazio loadFunction(LoadState *S, Proto *f);


Fixo Vazio loadConstants (LoadState *S, Proto *f) {
  Inteiro i;
  Inteiro n = loadInt(S);
  f->k = sol_m_newvectorchecked(S->L, n, TValue);
  f->sizek = n;
  Para (i = 0; i < n; i++)
    setnilvalue(&f->k[i]);
  Para (i = 0; i < n; i++) {
    TValue *o = &f->k[i];
    Inteiro t = loadByte(S);
    Troque (t) {
      Caso SOL_VNIL:
        setnilvalue(o);
        Interrompa;
      Caso SOL_VFALSE:
        setbfvalue(o);
        Interrompa;
      Caso SOL_VTRUE:
        setbtvalue(o);
        Interrompa;
      Caso SOL_VNUMFLT:
        setfltvalue(o, loadNumber(S));
        Interrompa;
      Caso SOL_VNUMINT:
        setivalue(o, loadInteger(S));
        Interrompa;
      Caso SOL_VSHRSTR:
      Caso SOL_VLNGSTR: {
        sol_assert(f->source == NULL);
        loadString(S, f, &f->source);  /* use 'source' to anchor string */
        Se (f->source == NULL)
          Erro(S, "bad format Para constant string");
        setsvalue2n(S->L, o, f->source);  /* save it in the right place */
        f->source = NULL;
        Interrompa;
      }
      Padrão: Erro(S, "invalid constant");
    }
  }
}


Fixo Vazio loadProtos (LoadState *S, Proto *f) {
  Inteiro i;
  Inteiro n = loadInt(S);
  f->p = sol_m_newvectorchecked(S->L, n, Proto *);
  f->sizep = n;
  Para (i = 0; i < n; i++)
    f->p[i] = NULL;
  Para (i = 0; i < n; i++) {
    f->p[i] = sol_f_newproto(S->L);
    sol_c_objbarrier(S->L, f, f->p[i]);
    loadFunction(S, f->p[i]);
  }
}


/*
** Load the upvalues Para a function. The names must be filled first,
** because the filling of the other fields can raise read errors and
** the creation of the Erro message can call an emergency collection;
** in that Caso all prototypes must be consistent Para the GC.
*/
Fixo Vazio loadUpvalues (LoadState *S, Proto *f) {
  Inteiro i;
  Inteiro n = loadInt(S);
  f->upvalues = sol_m_newvectorchecked(S->L, n, Upvaldesc);
  f->sizeupvalues = n;
  Para (i = 0; i < n; i++)  /* make array valid Para GC */
    f->upvalues[i].name = NULL;
  Para (i = 0; i < n; i++) {  /* following calls can raise errors */
    f->upvalues[i].instack = loadByte(S);
    f->upvalues[i].idx = loadByte(S);
    f->upvalues[i].kind = loadByte(S);
  }
}


Fixo Vazio loadDebug (LoadState *S, Proto *f) {
  Inteiro i;
  Inteiro n = loadInt(S);
  Se (S->fixed) {
    f->lineinfo = getaddr(S, n, ls_byte);
    f->sizelineinfo = n;
  }
  Senão {
    f->lineinfo = sol_m_newvectorchecked(S->L, n, ls_byte);
    f->sizelineinfo = n;
    loadVector(S, f->lineinfo, n);
  }
  n = loadInt(S);
  Se (n > 0) {
    loadAlign(S, meça(Inteiro));
    Se (S->fixed) {
      f->abslineinfo = getaddr(S, n, AbsLineInfo);
      f->sizeabslineinfo = n;
    }
    Senão {
      f->abslineinfo = sol_m_newvectorchecked(S->L, n, AbsLineInfo);
      f->sizeabslineinfo = n;
      loadVector(S, f->abslineinfo, n);
    }
  }
  n = loadInt(S);
  f->locvars = sol_m_newvectorchecked(S->L, n, LocVar);
  f->sizelocvars = n;
  Para (i = 0; i < n; i++)
    f->locvars[i].varname = NULL;
  Para (i = 0; i < n; i++) {
    loadString(S, f, &f->locvars[i].varname);
    f->locvars[i].startpc = loadInt(S);
    f->locvars[i].endpc = loadInt(S);
  }
  n = loadInt(S);
  Se (n != 0)  /* does it have debug information? */
    n = f->sizeupvalues;  /* must be this many */
  Para (i = 0; i < n; i++)
    loadString(S, f, &f->upvalues[i].name);
}


Fixo Vazio loadFunction (LoadState *S, Proto *f) {
  f->linedefined = loadInt(S);
  f->lastlinedefined = loadInt(S);
  f->numparams = loadByte(S);
  f->flag = loadByte(S) & PF_ISVARARG;  /* get only the meaningful flags */
  Se (S->fixed)
    f->flag |= PF_FIXED;  /* signal that code is fixed */
  f->maxstacksize = loadByte(S);
  loadCode(S, f);
  loadConstants(S, f);
  loadUpvalues(S, f);
  loadProtos(S, f);
  loadString(S, f, &f->source);
  loadDebug(S, f);
}


Fixo Vazio checkliteral (LoadState *S, Imutável Caractere *s, Imutável Caractere *msg) {
  Caractere buff[meça(SOL_SIGNATURE) + meça(LUAC_DATA)]; /* larger than both */
  size_t len = strlen(s);
  loadVector(S, buff, len);
  Se (memcmp(s, buff, len) != 0)
    Erro(S, msg);
}


Fixo l_noret numerror (LoadState *S, Imutável Caractere *what, Imutável Caractere *tname) {
  Imutável Caractere *msg = sol_o_pushfstring(S->L, "%s %s mismatch", tname, what);
  Erro(S, msg);
}


Fixo Vazio checknumsize (LoadState *S, Inteiro size, Imutável Caractere *tname) {
  Se (size != loadByte(S))
    numerror(S, "size", tname);
}


Fixo Vazio checknumformat (LoadState *S, Inteiro eq, Imutável Caractere *tname) {
  Se (!eq)
    numerror(S, "format", tname);
}


#Defina checknum(S,tvar,value,tname)  \
  { tvar i; checknumsize(S, meça(i), tname); \
    loadVar(S, i); \
    checknumformat(S, i == value, tname); }


Fixo Vazio checkHeader (LoadState *S) {
  /* skip 1st Caractere (already read and checked) */
  checkliteral(S, &SOL_SIGNATURE[1], "not a binary chunk");
  Se (loadByte(S) != LUAC_VERSION)
    Erro(S, "version mismatch");
  Se (loadByte(S) != LUAC_FORMAT)
    Erro(S, "format mismatch");
  checkliteral(S, LUAC_DATA, "corrupted chunk");
  checknum(S, Inteiro, LUAC_INT, "Inteiro");
  checknum(S, Instruction, LUAC_INST, "instruction");
  checknum(S, sol_Integer, LUAC_INT, "Sol integer");
  checknum(S, sol_Number, LUAC_NUM, "Sol number");
}


/*
** Load precompiled chunk.
*/
LClosure *sol_u_undump (sol_State *L, ZIO *Z, Imutável Caractere *name, Inteiro fixed) {
  LoadState S;
  LClosure *cl;
  Se (*name == '@' || *name == '=')
    name = name + 1;
  Senão Se (*name == SOL_SIGNATURE[0])
    name = "binary string";
  S.name = name;
  S.L = L;
  S.Z = Z;
  S.fixed = cast_byte(fixed);
  S.offset = 1;  /* fist byte was already read */
  checkHeader(&S);
  cl = sol_f_newLclosure(L, loadByte(&S));
  setclLvalue2s(L, L->top.p, cl);
  sol_d_inctop(L);
  S.h = sol_h_new(L);  /* create list of saved strings */
  S.nstr = 0;
  sethvalue2s(L, L->top.p, S.h);  /* anchor it */
  sol_d_inctop(L);
  cl->p = sol_f_newproto(L);
  sol_c_objbarrier(L, cl, cl->p);
  loadFunction(&S, cl->p);
  Se (cl->nupvalues != cl->p->sizeupvalues)
    Erro(&S, "corrupted chunk");
  sol_verifycode(L, cl->p);
  L->top.p--;  /* pop table */
  Retorne cl;
}

