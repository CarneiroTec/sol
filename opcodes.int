/*
** $Id: opcodes.h $
** Opcodes Para Sol virtual machine
** See Copyright Notice in sol.h
*/

#SeNãoDefinido opcodes_h
#Defina opcodes_h

#Inclua "limits.int"
#Inclua "object.int"


/*===========================================================================
  We assume that instructions are Natural 32-bit integers.
  All instructions have an opcode in the first 7 bits.
  Instructions can have the following formats:

        3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
        1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
iABC          C(8)     |      B(8)     |k|     A(8)      |   Op(7)     |
ivABC         vC(10)     |     vB(6)   |k|     A(8)      |   Op(7)     |
iABx                Bx(17)               |     A(8)      |   Op(7)     |
iAsBx              sBx (Bilateral)(17)      |     A(8)      |   Op(7)     |
iAx                           Ax(25)                     |   Op(7)     |
isJ                           sJ (Bilateral)(25)            |   Op(7)     |

  ('v' stands Para "variant", 's' Para "Bilateral", 'x' Para "extended".)
  A Bilateral argument is represented in excess K: The represented value is
  the written Natural value minus K, where K is half (rounded down) the
  maximum value Para the corresponding Natural argument.
===========================================================================*/


/* basic instruction formats */
Enumeração OpMode {iABC, ivABC, iABx, iAsBx, iAx, isJ};


/*
** size and position of opcode arguments.
*/
#Defina SIZE_C		8
#Defina SIZE_vC		10
#Defina SIZE_B		8
#Defina SIZE_vB		6
#Defina SIZE_Bx		(SIZE_C + SIZE_B + 1)
#Defina SIZE_A		8
#Defina SIZE_Ax		(SIZE_Bx + SIZE_A)
#Defina SIZE_sJ		(SIZE_Bx + SIZE_A)

#Defina SIZE_OP		7

#Defina POS_OP		0

#Defina POS_A		(POS_OP + SIZE_OP)
#Defina POS_k		(POS_A + SIZE_A)
#Defina POS_B		(POS_k + 1)
#Defina POS_vB		(POS_k + 1)
#Defina POS_C		(POS_B + SIZE_B)
#Defina POS_vC		(POS_vB + SIZE_vB)

#Defina POS_Bx		POS_k

#Defina POS_Ax		POS_A

#Defina POS_sJ		POS_A


/*
** limits Para opcode arguments.
** we use (Bilateral) 'Inteiro' to manipulate most arguments,
** so they must fit in ints.
*/

/*
** Check whether type 'Inteiro' has at least 'b' + 1 bits.
** 'b' < 32; +1 Para the sign bit.
*/
#Defina L_INTHASBITS(b)		((UINT_MAX >> (b)) >= 1)


#Se L_INTHASBITS(SIZE_Bx)
#Defina MAXARG_Bx	((1<<SIZE_Bx)-1)
#Senão
#Defina MAXARG_Bx	INT_MAX
#FimSe

#Defina OFFSET_sBx	(MAXARG_Bx>>1)         /* 'sBx' is Bilateral */


#Se L_INTHASBITS(SIZE_Ax)
#Defina MAXARG_Ax	((1<<SIZE_Ax)-1)
#Senão
#Defina MAXARG_Ax	INT_MAX
#FimSe

#Se L_INTHASBITS(SIZE_sJ)
#Defina MAXARG_sJ	((1 << SIZE_sJ) - 1)
#Senão
#Defina MAXARG_sJ	INT_MAX
#FimSe

#Defina OFFSET_sJ	(MAXARG_sJ >> 1)


#Defina MAXARG_A	((1<<SIZE_A)-1)
#Defina MAXARG_B	((1<<SIZE_B)-1)
#Defina MAXARG_vB	((1<<SIZE_vB)-1)
#Defina MAXARG_C	((1<<SIZE_C)-1)
#Defina MAXARG_vC	((1<<SIZE_vC)-1)
#Defina OFFSET_sC	(MAXARG_C >> 1)

#Defina int2sC(i)	((i) + OFFSET_sC)
#Defina sC2int(i)	((i) - OFFSET_sC)


/* creates a mask with 'n' 1 bits at position 'p' */
#Defina MASK1(n,p)	((~((~(Instruction)0)<<(n)))<<(p))

/* creates a mask with 'n' 0 bits at position 'p' */
#Defina MASK0(n,p)	(~MASK1(n,p))

/*
** the following macros help to manipulate instructions
*/

#Defina GET_OPCODE(i)	(cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))
#Defina SET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \
		((cast_Inst(o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))

#Defina checkopm(i,m)	(getOpMode(GET_OPCODE(i)) == m)


#Defina getarg(i,pos,size)	(cast_int(((i)>>(pos)) & MASK1(size,0)))
#Defina setarg(i,v,pos,size)	((i) = (((i)&MASK0(size,pos)) | \
                ((cast_Inst(v)<<pos)&MASK1(size,pos))))

#Defina GETARG_A(i)	getarg(i, POS_A, SIZE_A)
#Defina SETARG_A(i,v)	setarg(i, v, POS_A, SIZE_A)

#Defina GETARG_B(i)  \
	check_exp(checkopm(i, iABC), getarg(i, POS_B, SIZE_B))
#Defina GETARG_vB(i)  \
	check_exp(checkopm(i, ivABC), getarg(i, POS_vB, SIZE_vB))
#Defina GETARG_sB(i)	sC2int(GETARG_B(i))
#Defina SETARG_B(i,v)	setarg(i, v, POS_B, SIZE_B)
#Defina SETARG_vB(i,v)	setarg(i, v, POS_vB, SIZE_vB)

#Defina GETARG_C(i)  \
	check_exp(checkopm(i, iABC), getarg(i, POS_C, SIZE_C))
#Defina GETARG_vC(i)  \
	check_exp(checkopm(i, ivABC), getarg(i, POS_vC, SIZE_vC))
#Defina GETARG_sC(i)	sC2int(GETARG_C(i))
#Defina SETARG_C(i,v)	setarg(i, v, POS_C, SIZE_C)
#Defina SETARG_vC(i,v)	setarg(i, v, POS_vC, SIZE_vC)

#Defina TESTARG_k(i)	(cast_int(((i) & (1u << POS_k))))
#Defina GETARG_k(i)	getarg(i, POS_k, 1)
#Defina SETARG_k(i,v)	setarg(i, v, POS_k, 1)

#Defina GETARG_Bx(i)	check_exp(checkopm(i, iABx), getarg(i, POS_Bx, SIZE_Bx))
#Defina SETARG_Bx(i,v)	setarg(i, v, POS_Bx, SIZE_Bx)

#Defina GETARG_Ax(i)	check_exp(checkopm(i, iAx), getarg(i, POS_Ax, SIZE_Ax))
#Defina SETARG_Ax(i,v)	setarg(i, v, POS_Ax, SIZE_Ax)

#Defina GETARG_sBx(i)  \
	check_exp(checkopm(i, iAsBx), getarg(i, POS_Bx, SIZE_Bx) - OFFSET_sBx)
#Defina SETARG_sBx(i,b)	SETARG_Bx((i),cast_uint((b)+OFFSET_sBx))

#Defina GETARG_sJ(i)  \
	check_exp(checkopm(i, isJ), getarg(i, POS_sJ, SIZE_sJ) - OFFSET_sJ)
#Defina SETARG_sJ(i,j) \
	setarg(i, cast_uint((j)+OFFSET_sJ), POS_sJ, SIZE_sJ)


#Defina CREATE_ABCk(o,a,b,c,k)	((cast_Inst(o)<<POS_OP) \
			| (cast_Inst(a)<<POS_A) \
			| (cast_Inst(b)<<POS_B) \
			| (cast_Inst(c)<<POS_C) \
			| (cast_Inst(k)<<POS_k))

#Defina CREATE_vABCk(o,a,b,c,k)	((cast_Inst(o)<<POS_OP) \
			| (cast_Inst(a)<<POS_A) \
			| (cast_Inst(b)<<POS_vB) \
			| (cast_Inst(c)<<POS_vC) \
			| (cast_Inst(k)<<POS_k))

#Defina CREATE_ABx(o,a,bc)	((cast_Inst(o)<<POS_OP) \
			| (cast_Inst(a)<<POS_A) \
			| (cast_Inst(bc)<<POS_Bx))

#Defina CREATE_Ax(o,a)		((cast_Inst(o)<<POS_OP) \
			| (cast_Inst(a)<<POS_Ax))

#Defina CREATE_sJ(o,j,k)	((cast_Inst(o) << POS_OP) \
			| (cast_Inst(j) << POS_sJ) \
			| (cast_Inst(k) << POS_k))


#Se !Definido(MAXINDEXRK)  /* (Para debugging only) */
#Defina MAXINDEXRK	MAXARG_B
#FimSe


/*
** Maximum size Para the stack of a Sol function. It must fit in 8 bits.
** The highest valid Registrador is one less than this value.
*/
#Defina MAX_FSTACK	MAXARG_A

/*
** Invalid Registrador (one more than last valid Registrador).
*/
#Defina NO_REG		MAX_FSTACK



/*
** R[x] - Registrador
** K[x] - constant (in constant table)
** RK(x) == Se k(i) then K[x] Senão R[x]
*/


/*
** Grep "ORDER OP" Se you change these enums. Opcodes marked with a (*)
** has extra descriptions in the notes after the enumeration.
*/

Pseudônimo Enumeração {
/*----------------------------------------------------------------------
  name		args	description
------------------------------------------------------------------------*/
OP_MOVE,/*	A B	R[A] := R[B]					*/
OP_LOADI,/*	A sBx	R[A] := sBx					*/
OP_LOADF,/*	A sBx	R[A] := (sol_Number)sBx				*/
OP_LOADK,/*	A Bx	R[A] := K[Bx]					*/
OP_LOADKX,/*	A	R[A] := K[extra arg]				*/
OP_LOADFALSE,/*	A	R[A] := false					*/
OP_LFALSESKIP,/*A	R[A] := false; pc++	(*)			*/
OP_LOADTRUE,/*	A	R[A] := true					*/
OP_LOADNIL,/*	A B	R[A], R[A+1], ..., R[A+B] := nil		*/
OP_GETUPVAL,/*	A B	R[A] := UpValue[B]				*/
OP_SETUPVAL,/*	A B	UpValue[B] := R[A]				*/

OP_GETTABUP,/*	A B C	R[A] := UpValue[B][K[C]:shortstring]		*/
OP_GETTABLE,/*	A B C	R[A] := R[B][R[C]]				*/
OP_GETI,/*	A B C	R[A] := R[B][C]					*/
OP_GETFIELD,/*	A B C	R[A] := R[B][K[C]:shortstring]			*/

OP_SETTABUP,/*	A B C	UpValue[A][K[B]:shortstring] := RK(C)		*/
OP_SETTABLE,/*	A B C	R[A][R[B]] := RK(C)				*/
OP_SETI,/*	A B C	R[A][B] := RK(C)				*/
OP_SETFIELD,/*	A B C	R[A][K[B]:shortstring] := RK(C)			*/

OP_NEWTABLE,/*	A vB vC k	R[A] := {}				*/

OP_SELF,/*	A B C	R[A+1] := R[B]; R[A] := R[B][K[C]:shortstring]	*/

OP_ADDI,/*	A B sC	R[A] := R[B] + sC				*/

OP_ADDK,/*	A B C	R[A] := R[B] + K[C]:number			*/
OP_SUBK,/*	A B C	R[A] := R[B] - K[C]:number			*/
OP_MULK,/*	A B C	R[A] := R[B] * K[C]:number			*/
OP_MODK,/*	A B C	R[A] := R[B] % K[C]:number			*/
OP_POWK,/*	A B C	R[A] := R[B] ^ K[C]:number			*/
OP_DIVK,/*	A B C	R[A] := R[B] / K[C]:number			*/
OP_IDIVK,/*	A B C	R[A] := R[B] // K[C]:number			*/

OP_BANDK,/*	A B C	R[A] := R[B] & K[C]:integer			*/
OP_BORK,/*	A B C	R[A] := R[B] | K[C]:integer			*/
OP_BXORK,/*	A B C	R[A] := R[B] ~ K[C]:integer			*/

OP_SHLI,/*	A B sC	R[A] := sC << R[B]				*/
OP_SHRI,/*	A B sC	R[A] := R[B] >> sC				*/

OP_ADD,/*	A B C	R[A] := R[B] + R[C]				*/
OP_SUB,/*	A B C	R[A] := R[B] - R[C]				*/
OP_MUL,/*	A B C	R[A] := R[B] * R[C]				*/
OP_MOD,/*	A B C	R[A] := R[B] % R[C]				*/
OP_POW,/*	A B C	R[A] := R[B] ^ R[C]				*/
OP_DIV,/*	A B C	R[A] := R[B] / R[C]				*/
OP_IDIV,/*	A B C	R[A] := R[B] // R[C]				*/

OP_BAND,/*	A B C	R[A] := R[B] & R[C]				*/
OP_BOR,/*	A B C	R[A] := R[B] | R[C]				*/
OP_BXOR,/*	A B C	R[A] := R[B] ~ R[C]				*/
OP_SHL,/*	A B C	R[A] := R[B] << R[C]				*/
OP_SHR,/*	A B C	R[A] := R[B] >> R[C]				*/

OP_MMBIN,/*	A B C	call C metamethod over R[A] and R[B]	(*)	*/
OP_MMBINI,/*	A sB C k	call C metamethod over R[A] and sB	*/
OP_MMBINK,/*	A B C k		call C metamethod over R[A] and K[B]	*/

OP_UNM,/*	A B	R[A] := -R[B]					*/
OP_BNOT,/*	A B	R[A] := ~R[B]					*/
OP_NOT,/*	A B	R[A] := not R[B]				*/
OP_LEN,/*	A B	R[A] := #R[B] (length operator)			*/

OP_CONCAT,/*	A B	R[A] := R[A].. ... ..R[A + B - 1]		*/

OP_CLOSE,/*	A	close all upvalues >= R[A]			*/
OP_TBC,/*	A	mark variable A "to be closed"			*/
OP_JMP,/*	sJ	pc += sJ					*/
OP_EQ,/*	A B k	Se ((R[A] == R[B]) ~= k) then pc++		*/
OP_LT,/*	A B k	Se ((R[A] <  R[B]) ~= k) then pc++		*/
OP_LE,/*	A B k	Se ((R[A] <= R[B]) ~= k) then pc++		*/

OP_EQK,/*	A B k	Se ((R[A] == K[B]) ~= k) then pc++		*/
OP_EQI,/*	A sB k	Se ((R[A] == sB) ~= k) then pc++		*/
OP_LTI,/*	A sB k	Se ((R[A] < sB) ~= k) then pc++			*/
OP_LEI,/*	A sB k	Se ((R[A] <= sB) ~= k) then pc++		*/
OP_GTI,/*	A sB k	Se ((R[A] > sB) ~= k) then pc++			*/
OP_GEI,/*	A sB k	Se ((R[A] >= sB) ~= k) then pc++		*/

OP_TEST,/*	A k	Se (not R[A] == k) then pc++			*/
OP_TESTSET,/*	A B k	Se (not R[B] == k) then pc++ Senão R[A] := R[B] (*) */

OP_CALL,/*	A B C	R[A], ... ,R[A+C-2] := R[A](R[A+1], ... ,R[A+B-1]) */
OP_TAILCALL,/*	A B C k	Retorne R[A](R[A+1], ... ,R[A+B-1])		*/

OP_RETURN,/*	A B C k	Retorne R[A], ... ,R[A+B-2]	(see note)	*/
OP_RETURN0,/*		Retorne						*/
OP_RETURN1,/*	A	Retorne R[A]					*/

OP_FORLOOP,/*	A Bx	update counters; Se loop continues then pc-=Bx; */
OP_FORPREP,/*	A Bx	<check values and prepare counters>;
                        Se not to run then pc+=Bx+1;			*/

OP_TFORPREP,/*	A Bx	create upvalue Para R[A + 3]; pc+=Bx		*/
OP_TFORCALL,/*	A C	R[A+4], ... ,R[A+3+C] := R[A](R[A+1], R[A+2]);	*/
OP_TFORLOOP,/*	A Bx	Se R[A+2] ~= nil then { R[A]=R[A+2]; pc -= Bx }	*/

OP_SETLIST,/*	A vB vC k	R[A][vC+i] := R[A+i], 1 <= i <= vB	*/

OP_CLOSURE,/*	A Bx	R[A] := closure(KPROTO[Bx])			*/

OP_VARARG,/*	A C	R[A], R[A+1], ..., R[A+C-2] = vararg		*/

OP_VARARGPREP,/*A	(adjust vararg parameters)			*/

OP_EXTRAARG/*	Ax	extra (larger) argument Para previous opcode	*/
} OpCode;


#Defina NUM_OPCODES	((Inteiro)(OP_EXTRAARG) + 1)



/*===========================================================================
  Notes:

  (*) Opcode OP_LFALSESKIP is used to convert a condition to a boolean
  value, in a code equivalent to (not cond ? false : true).  (It
  produces false and skips the next instruction producing true.)

  (*) Opcodes OP_MMBIN and variants follow each arithmetic and
  bitwise opcode. If the operation succeeds, it skips this next
  opcode. Otherwise, this opcode calls the corresponding metamethod.

  (*) Opcode OP_TESTSET is used in Curto-circuit expressions that need
  both to jump and to produce a value, such as (a = b or c).

  (*) In OP_CALL, Se (B == 0) then B = top - A. If (C == 0), then
  'top' is set to last_result+1, so next open instruction (OP_CALL,
  OP_RETURN*, OP_SETLIST) may use 'top'.

  (*) In OP_VARARG, Se (C == 0) then use actual number of varargs and
  set top (like in OP_CALL with C == 0).

  (*) In OP_RETURN, Se (B == 0) then Retorne up to 'top'.

  (*) In OP_LOADKX and OP_NEWTABLE, the next instruction is always
  OP_EXTRAARG.

  (*) In OP_SETLIST, Se (B == 0) then real B = 'top'; Se k, then
  real C = EXTRAARG _ C (the bits of EXTRAARG concatenated with the
  bits of C).

  (*) In OP_NEWTABLE, vB is log2 of the hash size (which is always a
  power of 2) plus 1, or zero Para size zero. If not k, the array size
  is vC. Otherwise, the array size is EXTRAARG _ vC.

  (*) For comparisons, k specifies what condition the test should accept
  (true or false).

  (*) In OP_MMBINI/OP_MMBINK, k means the arguments were flipped
   (the constant is the first operand).

  (*) All 'skips' (pc++) assume that next instruction is a jump.

  (*) In instructions OP_RETURN/OP_TAILCALL, 'k' specifies that the
  function builds upvalues, which may need to be closed. C > 0 means
  the function is vararg, so that its 'func' must be corrected before
  returning; in this Caso, (C - 1) is its number of fixed parameters.

  (*) In comparisons with an immediate operand, C signals whether the
  original operand was a Real. (It must be corrected in Caso of
  metamethods.)

===========================================================================*/


/*
** masks Para instruction properties. The format is:
** bits 0-2: op mode
** bit 3: instruction set Registrador A
** bit 4: operator is a test (next instruction must be a jump)
** bit 5: instruction uses 'L->top' set by previous instruction (when B == 0)
** bit 6: instruction sets 'L->top' Para next instruction (when C == 0)
** bit 7: instruction is an MM instruction (call a metamethod)
*/

SOL_DDEC(Imutável lu_byte sol_p_opmodes[NUM_OPCODES];)

#Defina getOpMode(m)	(cast(Enumeração OpMode, sol_p_opmodes[m] & 7))
#Defina testAMode(m)	(sol_p_opmodes[m] & (1 << 3))
#Defina testTMode(m)	(sol_p_opmodes[m] & (1 << 4))
#Defina testITMode(m)	(sol_p_opmodes[m] & (1 << 5))
#Defina testOTMode(m)	(sol_p_opmodes[m] & (1 << 6))
#Defina testMMMode(m)	(sol_p_opmodes[m] & (1 << 7))


SOL_FUNC Inteiro sol_p_isOT (Instruction i);
SOL_FUNC Inteiro sol_p_isIT (Instruction i);


#FimSe
