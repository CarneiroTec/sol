/*
** $Id: lgc.c $
** Garbage Collector
** See Direitos Autorais Notice in sol.h
*/

#Defina gc_c
#Defina SOL_CORE

#Inclua "prefix.int"

#Inclua <string.h>


#Inclua "sol.int"

#Inclua "debug.int"
#Inclua "do.int"
#Inclua "func.int"
#Inclua "gc.int"
#Inclua "mem.int"
#Inclua "object.int"
#Inclua "state.int"
#Inclua "string.int"
#Inclua "table.int"
#Inclua "tm.int"


/*
** Maximum number of elements to sweep in each single step.
** (Large enough to dissipate fixed overheads but small enough
** to allow small steps Para the collector.)
*/
#Defina GCSWEEPMAX	20


/*
** Cost (in work units) of running one finalizer.
*/
#Defina CWUFIN	10


/* mask with all color bits */
#Defina maskcolors	(bitmask(BLACKBIT) | WHITEBITS)

/* mask with all GC bits */
#Defina maskgcbits      (maskcolors | AGEBITS)


/* macro to erase all color bits then set only the current white bit */
#Defina makewhite(g,x)	\
  (x->marked = cast_byte((x->marked & ~maskcolors) | sol_c_white(g)))

/* make an object gray (neither white nor black) */
#Defina set2gray(x)	resetbits(x->marked, maskcolors)


/* make an object black (coming from any color) */
#Defina set2black(x)  \
  (x->marked = cast_byte((x->marked & ~WHITEBITS) | bitmask(BLACKBIT)))


#Defina valiswhite(x)   (iscollectable(x) && iswhite(gcvalue(x)))

#Defina keyiswhite(n)   (keyiscollectable(n) && iswhite(gckey(n)))


/*
** Protected access to objects in values
*/
#Defina gcvalueN(o)     (iscollectable(o) ? gcvalue(o) : NULL)


/*
** Access to collectable objects in array part of tables
*/
#Defina gcvalarr(t,i)  \
	((*getArrTag(t,i) & BIT_ISCOLLECTABLE) ? getArrVal(t,i)->gc : NULL)


#Defina markvalue(g,o) { checkliveness(mainthread(g),o); \
  Se (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }

#Defina markkey(g, n)	{ Se keyiswhite(n) reallymarkobject(g,gckey(n)); }

#Defina markobject(g,t)	{ Se (iswhite(t)) reallymarkobject(g, obj2gco(t)); }

/*
** mark an object that can be NULL (either because it is really optional,
** or it was stripped as debug info, or inside an uncompleted structure)
*/
#Defina markobjectN(g,t)	{ Se (t) markobject(g,t); }


Fixo Vazio reallymarkobject (global_State *g, GCObject *o);
Fixo Vazio atomic (sol_State *L);
Fixo Vazio entersweep (sol_State *L);


/*
** {======================================================
** Generic functions
** =======================================================
*/


/*
** one after last element in a hash array
*/
#Defina gnodelast(h)	gnode(h, cast_sizet(sizenode(h)))


Fixo l_mem objsize (GCObject *o) {
  lu_mem res;
  Troque (o->tt) {
    Caso SOL_VTABLE: {
      res = sol_h_size(gco2t(o));
      Interrompa;
    }
    Caso SOL_VLCL: {
      LClosure *cl = gco2lcl(o);
      res = sizeLclosure(cl->nupvalues);
      Interrompa;
    }
    Caso SOL_VCCL: {
      CClosure *cl = gco2ccl(o);
      res = sizeCclosure(cl->nupvalues);
      Interrompa;
    }
    Caso SOL_VUSERDATA: {
      Udata *u = gco2u(o);
      res = sizeudata(u->nuvalue, u->len);
      Interrompa;
    }
    Caso SOL_VPROTO: {
      res = sol_f_protosize(gco2p(o));
      Interrompa;
    }
    Caso SOL_VTHREAD: {
      res = sol_e_threadsize(gco2th(o));
      Interrompa;
    }
    Caso SOL_VSHRSTR: {
      TString *ts = gco2ts(o);
      res = sizestrshr(cast_uint(ts->shrlen));
      Interrompa;
    }
    Caso SOL_VLNGSTR: {
      TString *ts = gco2ts(o);
      res = sol_s_sizelngstr(ts->u.lnglen, ts->shrlen);
      Interrompa;
    }
    Caso SOL_VUPVAL: {
      res = Meça(UpVal);
      Interrompa;
    }
    Padrão: res = 0; sol_assert(0);
  }
  Retorne cast(l_mem, res);
}


Fixo GCObject **getgclist (GCObject *o) {
  Troque (o->tt) {
    Caso SOL_VTABLE: Retorne &gco2t(o)->gclist;
    Caso SOL_VLCL: Retorne &gco2lcl(o)->gclist;
    Caso SOL_VCCL: Retorne &gco2ccl(o)->gclist;
    Caso SOL_VTHREAD: Retorne &gco2th(o)->gclist;
    Caso SOL_VPROTO: Retorne &gco2p(o)->gclist;
    Caso SOL_VUSERDATA: {
      Udata *u = gco2u(o);
      sol_assert(u->nuvalue > 0);
      Retorne &u->gclist;
    }
    Padrão: sol_assert(0); Retorne 0;
  }
}


/*
** Link a collectable object 'o' with a known type into the list 'p'.
** (Must be a macro to access the 'gclist' field in different types.)
*/
#Defina linkgclist(o,p)	linkgclist_(obj2gco(o), &(o)->gclist, &(p))

Fixo Vazio linkgclist_ (GCObject *o, GCObject **pnext, GCObject **list) {
  sol_assert(!isgray(o));  /* cannot be in a gray list */
  *pnext = *list;
  *list = o;
  set2gray(o);  /* now it is */
}


/*
** Link a generic collectable object 'o' into the list 'p'.
*/
#Defina linkobjgclist(o,p) linkgclist_(obj2gco(o), getgclist(o), &(p))



/*
** Clear keys Para empty entries in tables. If entry is empty, mark its
** entry as dead. This allows the collection of the key, but keeps its
** entry in the table: its removal could Interrompa a chain and could Interrompa
** a table traversal.  Other places never manipulate dead keys, because
** its associated empty value is enough to signal that the entry is
** logically empty.
*/
Fixo Vazio clearkey (Node *n) {
  sol_assert(isempty(gval(n)));
  Se (keyiscollectable(n))
    setdeadkey(n);  /* unused key; remove it */
}


/*
** tells whether a key or value can be cleared from a weak
** table. Non-collectable objects are never removed from weak
** tables. Strings behave as 'values', so are never removed too. Para
** other objects: Se really collected, cannot keep them; Para objects
** being finalized, keep them in keys, but not in values
*/
Fixo Inteiro iscleared (global_State *g, Imutável GCObject *o) {
  Se (o == NULL) Retorne 0;  /* non-collectable value */
  Senão Se (novariant(o->tt) == SOL_TSTRING) {
    markobject(g, o);  /* strings are 'values', so are never weak */
    Retorne 0;
  }
  Senão Retorne iswhite(o);
}


/*
** Barrier that moves collector forward, that is, marks the white object
** 'v' being pointed by the black object 'o'.  In the generational
** mode, 'v' must also become old, Se 'o' is old; however, it cannot
** be changed directly to OLD, because it may still point to non-old
** objects. So, it is marked as OLD0. In the next cycle it will become
** OLD1, and in the next it will finally become OLD (regular old). By
** then, any object it points to will also be old.  If called in the
** incremental sweep phase, it clears the black object to white (sweep
** it) to avoid other barrier calls Para this same object. (That cannot
** be done is generational mode, as its sweep does not distinguish
** white from dead.)
*/
Vazio sol_c_barrier_ (sol_State *L, GCObject *o, GCObject *v) {
  global_State *g = G(L);
  sol_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
  Se (keepinvariant(g)) {  /* must keep invariant? */
    reallymarkobject(g, v);  /* restore invariant */
    Se (isold(o)) {
      sol_assert(!isold(v));  /* white object could not be old */
      setage(v, G_OLD0);  /* restore generational invariant */
    }
  }
  Senão {  /* sweep phase */
    sol_assert(issweepphase(g));
    Se (g->gckind != KGC_GENMINOR)  /* incremental mode? */
      makewhite(g, o);  /* mark 'o' as white to avoid other barriers */
  }
}


/*
** barrier that moves collector backward, that is, mark the black object
** pointing to a white object as gray again.
*/
Vazio sol_c_barrierback_ (sol_State *L, GCObject *o) {
  global_State *g = G(L);
  sol_assert(isblack(o) && !isdead(g, o));
  sol_assert((g->gckind != KGC_GENMINOR)
          || (isold(o) && getage(o) != G_TOUCHED1));
  Se (getage(o) == G_TOUCHED2)  /* already in gray list? */
    set2gray(o);  /* make it gray to become touched1 */
  Senão  /* link it in 'grayagain' and paint it gray */
    linkobjgclist(o, g->grayagain);
  Se (isold(o))  /* generational mode? */
    setage(o, G_TOUCHED1);  /* touched in current cycle */
}


Vazio sol_c_fix (sol_State *L, GCObject *o) {
  global_State *g = G(L);
  sol_assert(g->allgc == o);  /* object must be 1st in 'allgc' list! */
  set2gray(o);  /* they will be gray forever */
  setage(o, G_OLD);  /* and old forever */
  g->allgc = o->next;  /* remove object from 'allgc' list */
  o->next = g->fixedgc;  /* link it to 'fixedgc' list */
  g->fixedgc = o;
}


/*
** create a new collectable object (with given type, size, and offset)
** and link it to 'allgc' list.
*/
GCObject *sol_c_newobjdt (sol_State *L, lu_byte tt, size_t sz, size_t offset) {
  global_State *g = G(L);
  Caractere *p = cast_charp(sol_m_newobject(L, novariant(tt), sz));
  GCObject *o = cast(GCObject *, p + offset);
  o->marked = sol_c_white(g);
  o->tt = tt;
  o->next = g->allgc;
  g->allgc = o;
  Retorne o;
}


/*
** create a new collectable object with no offset.
*/
GCObject *sol_c_newobj (sol_State *L, lu_byte tt, size_t sz) {
  Retorne sol_c_newobjdt(L, tt, sz, 0);
}

/* }====================================================== */



/*
** {======================================================
** Mark functions
** =======================================================
*/


/*
** Mark an object.  Userdata with no user values, strings, and closed
** upvalues are visited and turned black here.  Open upvalues are
** already indirectly linked through their respective threads in the
** 'twups' list, so they don't go to the gray list; nevertheless, they
** are kept gray to avoid barriers, as their values will be revisited
** by the thread or by 'remarkupvals'.  Other objects are added to the
** gray list to be visited (and turned black) later.  Both userdata and
** upvalues can call this function recursively, but this recursion goes
** Para at most two levels: An upvalue cannot refer to another upvalue
** (only closures can), and a userdata's metatable must be a table.
*/
Fixo Vazio reallymarkobject (global_State *g, GCObject *o) {
  g->GCmarked += objsize(o);
  Troque (o->tt) {
    Caso SOL_VSHRSTR:
    Caso SOL_VLNGSTR: {
      set2black(o);  /* nothing to visit */
      Interrompa;
    }
    Caso SOL_VUPVAL: {
      UpVal *uv = gco2upv(o);
      Se (upisopen(uv))
        set2gray(uv);  /* open upvalues are kept gray */
      Senão
        set2black(uv);  /* closed upvalues are visited here */
      markvalue(g, uv->v.p);  /* mark its content */
      Interrompa;
    }
    Caso SOL_VUSERDATA: {
      Udata *u = gco2u(o);
      Se (u->nuvalue == 0) {  /* no user values? */
        markobjectN(g, u->metatable);  /* mark its metatable */
        set2black(u);  /* nothing Senão to mark */
        Interrompa;
      }
      /* Senão... */
    }  /* FALLTHROUGH */
    Caso SOL_VLCL: Caso SOL_VCCL: Caso SOL_VTABLE:
    Caso SOL_VTHREAD: Caso SOL_VPROTO: {
      linkobjgclist(o, g->gray);  /* to be visited later */
      Interrompa;
    }
    Padrão: sol_assert(0); Interrompa;
  }
}


/*
** mark metamethods Para basic types
*/
Fixo Vazio markmt (global_State *g) {
  Inteiro i;
  Para (i=0; i < SOL_NUMTYPES; i++)
    markobjectN(g, g->mt[i]);
}


/*
** mark all objects in list of being-finalized
*/
Fixo Vazio markbeingfnz (global_State *g) {
  GCObject *o;
  Para (o = g->tobefnz; o != NULL; o = o->next)
    markobject(g, o);
}


/*
** For each non-marked thread, simulates a barrier between each open
** upvalue and its value. (If the thread is collected, the value will be
** assigned to the upvalue, but then it can be too late Para the barrier
** to act. The "barrier" does not need to check colors: A non-marked
** thread must be young; upvalues cannot be older than their threads; so
** any visited upvalue must be young too.) Also removes the thread from
** the list, as it was already visited. Removes also threads with no
** upvalues, as they have nothing to be checked. (If the thread gets an
** upvalue later, it will be linked in the list again.)
*/
Fixo Vazio remarkupvals (global_State *g) {
  sol_State *thread;
  sol_State **p = &g->twups;
  Enquanto ((thread = *p) != NULL) {
    Se (!iswhite(thread) && thread->openupval != NULL)
      p = &thread->twups;  /* keep marked thread with upvalues in the list */
    Senão {  /* thread is not marked or without upvalues */
      UpVal *uv;
      sol_assert(!isold(thread) || thread->openupval == NULL);
      *p = thread->twups;  /* remove thread from the list */
      thread->twups = thread;  /* mark that it is out of list */
      Para (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {
        sol_assert(getage(uv) <= getage(thread));
        Se (!iswhite(uv)) {  /* upvalue already visited? */
          sol_assert(upisopen(uv) && isgray(uv));
          markvalue(g, uv->v.p);  /* mark its value */
        }
      }
    }
  }
}


Fixo Vazio cleargraylists (global_State *g) {
  g->gray = g->grayagain = NULL;
  g->weak = g->allweak = g->ephemeron = NULL;
}


/*
** mark root set and reset all gray lists, to start a new collection.
** 'GCmarked' is initialized to count the total number of live bytes
** during a cycle.
*/
Fixo Vazio restartcollection (global_State *g) {
  cleargraylists(g);
  g->GCmarked = 0;
  markobject(g, mainthread(g));
  markvalue(g, &g->l_registry);
  markmt(g);
  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */
}

/* }====================================================== */


/*
** {======================================================
** Traverse functions
** =======================================================
*/


/*
** Check whether object 'o' should be kept in the 'grayagain' list Para
** post-processing by 'correctgraylist'. (It could put all old objects
** in the list and leave all the work to 'correctgraylist', but it is
** more efficient to avoid adding elements that will be removed.) Only
** TOUCHED1 objects need to be in the list. TOUCHED2 doesn't need to go
** back to a gray list, but then it must become OLD. (That is what
** 'correctgraylist' does when it finds a TOUCHED2 object.)
** This function is a no-op in incremental mode, as objects cannot be
** marked as touched in that mode.
*/
Fixo Vazio genlink (global_State *g, GCObject *o) {
  sol_assert(isblack(o));
  Se (getage(o) == G_TOUCHED1) {  /* touched in this cycle? */
    linkobjgclist(o, g->grayagain);  /* link it back in 'grayagain' */
  }  /* everything Senão Faça not need to be linked back */
  Senão Se (getage(o) == G_TOUCHED2)
    setage(o, G_OLD);  /* advance age */
}


/*
** Traverse a table with weak values and link it to proper list. During
** propagate phase, keep it in 'grayagain' list, to be revisited in the
** atomic phase. In the atomic phase, Se table has any white value,
** put it in 'weak' list, to be cleared; otherwise, call 'genlink'
** to check table age in generational mode.
*/
Fixo Vazio traverseweakvalue (global_State *g, Table *h) {
  Node *n, *limit = gnodelast(h);
  /* Se there is array part, assume it may have white values (it is not
     worth traversing it now just to check) */
  Inteiro hasclears = (h->asize > 0);
  Para (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
    Se (isempty(gval(n)))  /* entry is empty? */
      clearkey(n);  /* clear its key */
    Senão {
      sol_assert(!keyisnil(n));
      markkey(g, n);
      Se (!hasclears && iscleared(g, gcvalueN(gval(n))))  /* a white value? */
        hasclears = 1;  /* table will have to be cleared */
    }
  }
  Se (g->gcstate == GCSpropagate)
    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */
  Senão Se (hasclears)
      linkgclist(h, g->weak);  /* has to be cleared later */
  Senão
    genlink(g, obj2gco(h));
}


/*
** Traverse the array part of a table.
*/
Fixo Inteiro traversearray (global_State *g, Table *h) {
  Natural asize = h->asize;
  Inteiro marked = 0;  /* true Se some object is marked in this traversal */
  Natural i;
  Para (i = 0; i < asize; i++) {
    GCObject *o = gcvalarr(h, i);
    Se (o != NULL && iswhite(o)) {
      marked = 1;
      reallymarkobject(g, o);
    }
  }
  Retorne marked;
}


/*
** Traverse an ephemeron table and link it to proper list. Returns true
** iff any object was marked during this traversal (which implies that
** convergence has to Continue). During propagation phase, keep table
** in 'grayagain' list, to be visited again in the atomic phase. In
** the atomic phase, Se table has any white->white entry, it has to
** be revisited during ephemeron convergence (as that key may turn
** black). Otherwise, Se it has any white key, table has to be cleared
** (in the atomic phase). In generational mode, some tables
** must be kept in some gray list Para post-processing; this is done
** by 'genlink'.
*/
Fixo Inteiro traverseephemeron (global_State *g, Table *h, Inteiro inv) {
  Inteiro hasclears = 0;  /* true Se table has white keys */
  Inteiro hasww = 0;  /* true Se table has entry "white-key -> white-value" */
  Natural Inteiro i;
  Natural Inteiro nsize = sizenode(h);
  Inteiro marked = traversearray(g, h);  /* traverse array part */
  /* traverse hash part; Se 'inv', traverse descending
     (see 'convergeephemerons') */
  Para (i = 0; i < nsize; i++) {
    Node *n = inv ? gnode(h, nsize - 1 - i) : gnode(h, i);
    Se (isempty(gval(n)))  /* entry is empty? */
      clearkey(n);  /* clear its key */
    Senão Se (iscleared(g, gckeyN(n))) {  /* key is not marked (yet)? */
      hasclears = 1;  /* table must be cleared */
      Se (valiswhite(gval(n)))  /* value not marked yet? */
        hasww = 1;  /* white-white entry */
    }
    Senão Se (valiswhite(gval(n))) {  /* value not marked yet? */
      marked = 1;
      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */
    }
  }
  /* link table into proper list */
  Se (g->gcstate == GCSpropagate)
    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */
  Senão Se (hasww)  /* table has white->white entries? */
    linkgclist(h, g->ephemeron);  /* have to propagate again */
  Senão Se (hasclears)  /* table has white keys? */
    linkgclist(h, g->allweak);  /* may have to clean white keys */
  Senão
    genlink(g, obj2gco(h));  /* check whether collector still needs to see it */
  Retorne marked;
}


Fixo Vazio traversestrongtable (global_State *g, Table *h) {
  Node *n, *limit = gnodelast(h);
  traversearray(g, h);
  Para (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
    Se (isempty(gval(n)))  /* entry is empty? */
      clearkey(n);  /* clear its key */
    Senão {
      sol_assert(!keyisnil(n));
      markkey(g, n);
      markvalue(g, gval(n));
    }
  }
  genlink(g, obj2gco(h));
}


/*
** (result & 1) iff weak values; (result & 2) iff weak keys.
*/
Fixo Inteiro getmode (global_State *g, Table *h) {
  Imutável TValue *mode = gfasttm(g, h->metatable, TM_MODE);
  Se (mode == NULL || !ttisshrstring(mode))
    Retorne 0;  /* ignore non-(Curto)string modes */
  Senão {
    Imutável Caractere *smode = getshrstr(tsvalue(mode));
    Imutável Caractere *weakkey = strchr(smode, 'k');
    Imutável Caractere *weakvalue = strchr(smode, 'v');
    Retorne ((weakkey != NULL) << 1) | (weakvalue != NULL);
  }
}


Fixo l_mem traversetable (global_State *g, Table *h) {
  markobjectN(g, h->metatable);
  Troque (getmode(g, h)) {
    Caso 0:  /* not weak */
      traversestrongtable(g, h);
      Interrompa;
    Caso 1:  /* weak values */
      traverseweakvalue(g, h);
      Interrompa;
    Caso 2:  /* weak keys */
      traverseephemeron(g, h, 0);
      Interrompa;
    Caso 3:  /* all weak; nothing to traverse */
      Se (g->gcstate == GCSpropagate)
        linkgclist(h, g->grayagain);  /* must visit again its metatable */
      Senão
        linkgclist(h, g->allweak);  /* must clear collected entries */
      Interrompa;
  }
  Retorne cast(l_mem, 1 + 2*sizenode(h) + h->asize);
}


Fixo l_mem traverseudata (global_State *g, Udata *u) {
  Inteiro i;
  markobjectN(g, u->metatable);  /* mark its metatable */
  Para (i = 0; i < u->nuvalue; i++)
    markvalue(g, &u->uv[i].uv);
  genlink(g, obj2gco(u));
  Retorne 1 + u->nuvalue;
}


/*
** Traverse a prototype. (While a prototype is being build, its
** arrays can be larger than needed; the extra slots are filled with
** NULL, so the use of 'markobjectN')
*/
Fixo l_mem traverseproto (global_State *g, Proto *f) {
  Inteiro i;
  markobjectN(g, f->source);
  Para (i = 0; i < f->sizek; i++)  /* mark literals */
    markvalue(g, &f->k[i]);
  Para (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */
    markobjectN(g, f->upvalues[i].name);
  Para (i = 0; i < f->sizep; i++)  /* mark nested protos */
    markobjectN(g, f->p[i]);
  Para (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */
    markobjectN(g, f->locvars[i].varname);
  Retorne 1 + f->sizek + f->sizeupvalues + f->sizep + f->sizelocvars;
}


Fixo l_mem traverseCclosure (global_State *g, CClosure *cl) {
  Inteiro i;
  Para (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
    markvalue(g, &cl->upvalue[i]);
  Retorne 1 + cl->nupvalues;
}

/*
** Traverse a Sol closure, marking its prototype and its upvalues.
** (Both can be NULL Enquanto closure is being created.)
*/
Fixo l_mem traverseLclosure (global_State *g, LClosure *cl) {
  Inteiro i;
  markobjectN(g, cl->p);  /* mark its prototype */
  Para (i = 0; i < cl->nupvalues; i++) {  /* visit its upvalues */
    UpVal *uv = cl->upvals[i];
    markobjectN(g, uv);  /* mark upvalue */
  }
  Retorne 1 + cl->nupvalues;
}


/*
** Traverse a thread, marking the elements in the stack up to its top
** and cleaning the rest of the stack in the final traversal. That
** ensures that the entire stack have valid (non-dead) objects.
** Threads have no barriers. In gen. mode, old threads must be visited
** at every cycle, because they might point to young objects.  In inc.
** mode, the thread can still be modified before the end of the cycle,
** and therefore it must be visited again in the atomic phase. To ensure
** these visits, threads must Retorne to a gray list Se they are not new
** (which can only happen in generational mode) or Se the traverse is in
** the propagate phase (which can only happen in incremental mode).
*/
Fixo l_mem traversethread (global_State *g, sol_State *th) {
  UpVal *uv;
  StkId o = th->stack.p;
  Se (isold(th) || g->gcstate == GCSpropagate)
    linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */
  Se (o == NULL)
    Retorne 0;  /* stack not completely built yet */
  sol_assert(g->gcstate == GCSatomic ||
             th->openupval == NULL || isintwups(th));
  Para (; o < th->top.p; o++)  /* mark live elements in the stack */
    markvalue(g, s2v(o));
  Para (uv = th->openupval; uv != NULL; uv = uv->u.open.next)
    markobject(g, uv);  /* open upvalues cannot be collected */
  Se (g->gcstate == GCSatomic) {  /* final traversal? */
    Se (!g->gcemergency)
      sol_d_shrinkstack(th); /* Faça not change stack in emergency cycle */
    Para (o = th->top.p; o < th->stack_last.p + EXTRA_STACK; o++)
      setnilvalue(s2v(o));  /* clear dead stack slice */
    /* 'remarkupvals' may have removed thread from 'twups' list */
    Se (!isintwups(th) && th->openupval != NULL) {
      th->twups = g->twups;  /* link it back to the list */
      g->twups = th;
    }
  }
  Retorne 1 + (th->top.p - th->stack.p);
}


/*
** traverse one gray object, turning it to black. Return an estimate
** of the number of slots traversed.
*/
Fixo l_mem propagatemark (global_State *g) {
  GCObject *o = g->gray;
  nw2black(o);
  g->gray = *getgclist(o);  /* remove from 'gray' list */
  Troque (o->tt) {
    Caso SOL_VTABLE: Retorne traversetable(g, gco2t(o));
    Caso SOL_VUSERDATA: Retorne traverseudata(g, gco2u(o));
    Caso SOL_VLCL: Retorne traverseLclosure(g, gco2lcl(o));
    Caso SOL_VCCL: Retorne traverseCclosure(g, gco2ccl(o));
    Caso SOL_VPROTO: Retorne traverseproto(g, gco2p(o));
    Caso SOL_VTHREAD: Retorne traversethread(g, gco2th(o));
    Padrão: sol_assert(0); Retorne 0;
  }
}


Fixo Vazio propagateall (global_State *g) {
  Enquanto (g->gray)
    propagatemark(g);
}


/*
** Traverse all ephemeron tables propagating marks from keys to values.
** Repeat until it converges, that is, nothing new is marked. 'dir'
** inverts the direction of the traversals, trying to speed up
** convergence on chains in the same table.
*/
Fixo Vazio convergeephemerons (global_State *g) {
  Inteiro changed;
  Inteiro dir = 0;
  Faça {
    GCObject *w;
    GCObject *next = g->ephemeron;  /* get ephemeron list */
    g->ephemeron = NULL;  /* tables may Retorne to this list when traversed */
    changed = 0;
    Enquanto ((w = next) != NULL) {  /* Para each ephemeron table */
      Table *h = gco2t(w);
      next = h->gclist;  /* list is rebuilt during loop */
      nw2black(h);  /* out of the list (Para now) */
      Se (traverseephemeron(g, h, dir)) {  /* marked some value? */
        propagateall(g);  /* propagate changes */
        changed = 1;  /* will have to revisit all ephemeron tables */
      }
    }
    dir = !dir;  /* invert direction next time */
  } Enquanto (changed);  /* repeat until no more changes */
}

/* }====================================================== */


/*
** {======================================================
** Sweep Functions
** =======================================================
*/


/*
** clear entries with unmarked keys from all weaktables in list 'l'
*/
Fixo Vazio clearbykeys (global_State *g, GCObject *l) {
  Para (; l; l = gco2t(l)->gclist) {
    Table *h = gco2t(l);
    Node *limit = gnodelast(h);
    Node *n;
    Para (n = gnode(h, 0); n < limit; n++) {
      Se (iscleared(g, gckeyN(n)))  /* unmarked key? */
        setempty(gval(n));  /* remove entry */
      Se (isempty(gval(n)))  /* is entry empty? */
        clearkey(n);  /* clear its key */
    }
  }
}


/*
** clear entries with unmarked values from all weaktables in list 'l' up
** to element 'f'
*/
Fixo Vazio clearbyvalues (global_State *g, GCObject *l, GCObject *f) {
  Para (; l != f; l = gco2t(l)->gclist) {
    Table *h = gco2t(l);
    Node *n, *limit = gnodelast(h);
    Natural Inteiro i;
    Natural Inteiro asize = h->asize;
    Para (i = 0; i < asize; i++) {
      GCObject *o = gcvalarr(h, i);
      Se (iscleared(g, o))  /* value was collected? */
        *getArrTag(h, i) = SOL_VEMPTY;  /* remove entry */
    }
    Para (n = gnode(h, 0); n < limit; n++) {
      Se (iscleared(g, gcvalueN(gval(n))))  /* unmarked value? */
        setempty(gval(n));  /* remove entry */
      Se (isempty(gval(n)))  /* is entry empty? */
        clearkey(n);  /* clear its key */
    }
  }
}


Fixo Vazio freeupval (sol_State *L, UpVal *uv) {
  Se (upisopen(uv))
    sol_f_unlinkupval(uv);
  sol_m_free(L, uv);
}


Fixo Vazio freeobj (sol_State *L, GCObject *o) {
  assert_code(l_mem newmem = gettotalbytes(G(L)) - objsize(o));
  Troque (o->tt) {
    Caso SOL_VPROTO:
      sol_f_freeproto(L, gco2p(o));
      Interrompa;
    Caso SOL_VUPVAL:
      freeupval(L, gco2upv(o));
      Interrompa;
    Caso SOL_VLCL: {
      LClosure *cl = gco2lcl(o);
      sol_m_freemem(L, cl, sizeLclosure(cl->nupvalues));
      Interrompa;
    }
    Caso SOL_VCCL: {
      CClosure *cl = gco2ccl(o);
      sol_m_freemem(L, cl, sizeCclosure(cl->nupvalues));
      Interrompa;
    }
    Caso SOL_VTABLE:
      sol_h_free(L, gco2t(o));
      Interrompa;
    Caso SOL_VTHREAD:
      sol_e_freethread(L, gco2th(o));
      Interrompa;
    Caso SOL_VUSERDATA: {
      Udata *u = gco2u(o);
      sol_m_freemem(L, o, sizeudata(u->nuvalue, u->len));
      Interrompa;
    }
    Caso SOL_VSHRSTR: {
      TString *ts = gco2ts(o);
      sol_s_remove(L, ts);  /* remove it from hash table */
      sol_m_freemem(L, ts, sizestrshr(cast_uint(ts->shrlen)));
      Interrompa;
    }
    Caso SOL_VLNGSTR: {
      TString *ts = gco2ts(o);
      Se (ts->shrlen == LSTRMEM)  /* must free external string? */
        (*ts->falloc)(ts->ud, ts->contents, ts->u.lnglen + 1, 0);
      sol_m_freemem(L, ts, sol_s_sizelngstr(ts->u.lnglen, ts->shrlen));
      Interrompa;
    }
    Padrão: sol_assert(0);
  }
  sol_assert(gettotalbytes(G(L)) == newmem);
}


/*
** sweep at most 'countin' elements from a list of GCObjects erasing dead
** objects, where a dead object is one marked with the old (non current)
** white; change all non-dead objects back to white (and new), preparing
** Para next collection cycle. Return where to Continue the traversal or
** NULL Se list is finished.
*/
Fixo GCObject **sweeplist (sol_State *L, GCObject **p, l_mem countin) {
  global_State *g = G(L);
  Inteiro ow = otherwhite(g);
  Inteiro white = sol_c_white(g);  /* current white */
  Enquanto (*p != NULL && countin-- > 0) {
    GCObject *curr = *p;
    Inteiro marked = curr->marked;
    Se (isdeadm(ow, marked)) {  /* is 'curr' dead? */
      *p = curr->next;  /* remove 'curr' from list */
      freeobj(L, curr);  /* erase 'curr' */
    }
    Senão {  /* change mark to 'white' and age to 'new' */
      curr->marked = cast_byte((marked & ~maskgcbits) | white | G_NEW);
      p = &curr->next;  /* go to next element */
    }
  }
  Retorne (*p == NULL) ? NULL : p;
}


/*
** sweep a list until a live object (or end of list)
*/
Fixo GCObject **sweeptolive (sol_State *L, GCObject **p) {
  GCObject **old = p;
  Faça {
    p = sweeplist(L, p, 1);
  } Enquanto (p == old);
  Retorne p;
}

/* }====================================================== */


/*
** {======================================================
** Finalization
** =======================================================
*/

/*
** If possible, shrink string table.
*/
Fixo Vazio checkSizes (sol_State *L, global_State *g) {
  Se (!g->gcemergency) {
    Se (g->strt.nuse < g->strt.size / 4)  /* string table too big? */
      sol_s_resize(L, g->strt.size / 2);
  }
}


/*
** Get the next udata to be finalized from the 'tobefnz' list, and
** link it back into the 'allgc' list.
*/
Fixo GCObject *udata2finalize (global_State *g) {
  GCObject *o = g->tobefnz;  /* get first element */
  sol_assert(tofinalize(o));
  g->tobefnz = o->next;  /* remove it from 'tobefnz' list */
  o->next = g->allgc;  /* Retorne it to 'allgc' list */
  g->allgc = o;
  resetbit(o->marked, FINALIZEDBIT);  /* object is "normal" again */
  Se (issweepphase(g))
    makewhite(g, o);  /* "sweep" object */
  Senão Se (getage(o) == G_OLD1)
    g->firstold1 = o;  /* it is the first OLD1 object in the list */
  Retorne o;
}


Fixo Vazio dothecall (sol_State *L, Vazio *ud) {
  UNUSED(ud);
  sol_d_callnoyield(L, L->top.p - 2, 0);
}


Fixo Vazio GCTM (sol_State *L) {
  global_State *g = G(L);
  Imutável TValue *tm;
  TValue v;
  sol_assert(!g->gcemergency);
  setgcovalue(L, &v, udata2finalize(g));
  tm = sol_t_gettmbyobj(L, &v, TM_GC);
  Se (!notm(tm)) {  /* is there a finalizer? */
    TStatus status;
    lu_byte oldah = L->allowhook;
    lu_byte oldgcstp  = g->gcstp;
    g->gcstp |= GCSTPGC;  /* avoid GC steps */
    L->allowhook = 0;  /* stop debug hooks during GC metamethod */
    setobj2s(L, L->top.p++, tm);  /* push finalizer... */
    setobj2s(L, L->top.p++, &v);  /* ... and its argument */
    L->ci->callstatus |= CIST_FIN;  /* will run a finalizer */
    status = sol_d_pcall(L, dothecall, NULL, savestack(L, L->top.p - 2), 0);
    L->ci->callstatus &= ~CIST_FIN;  /* not running a finalizer anymore */
    L->allowhook = oldah;  /* restore hooks */
    g->gcstp = oldgcstp;  /* restore state */
    Se (l_unlikely(status != SOL_OK)) {  /* Erro Enquanto running __gc? */
      sol_e_warnerror(L, "__coletor_lixo");
      L->top.p--;  /* pops Erro object */
    }
  }
}


/*
** call all pending finalizers
*/
Fixo Vazio callallpendingfinalizers (sol_State *L) {
  global_State *g = G(L);
  Enquanto (g->tobefnz)
    GCTM(L);
}


/*
** find last 'next' field in list 'p' list (to add elements in its end)
*/
Fixo GCObject **findlast (GCObject **p) {
  Enquanto (*p != NULL)
    p = &(*p)->next;
  Retorne p;
}


/*
** Move all unreachable objects (or 'all' objects) that need
** finalization from list 'finobj' to list 'tobefnz' (to be finalized).
** (Note that objects after 'finobjold1' cannot be white, so they
** don't need to be traversed. In incremental mode, 'finobjold1' is NULL,
** so the whole list is traversed.)
*/
Fixo Vazio separatetobefnz (global_State *g, Inteiro all) {
  GCObject *curr;
  GCObject **p = &g->finobj;
  GCObject **lastnext = findlast(&g->tobefnz);
  Enquanto ((curr = *p) != g->finobjold1) {  /* traverse all finalizable objects */
    sol_assert(tofinalize(curr));
    Se (!(iswhite(curr) || all))  /* not being collected? */
      p = &curr->next;  /* don't bother with it */
    Senão {
      Se (curr == g->finobjsur)  /* removing 'finobjsur'? */
        g->finobjsur = curr->next;  /* correct it */
      *p = curr->next;  /* remove 'curr' from 'finobj' list */
      curr->next = *lastnext;  /* link at the end of 'tobefnz' list */
      *lastnext = curr;
      lastnext = &curr->next;
    }
  }
}


/*
** If pointer 'p' points to 'o', move it to the next element.
*/
Fixo Vazio checkpointer (GCObject **p, GCObject *o) {
  Se (o == *p)
    *p = o->next;
}


/*
** Correct pointers to objects inside 'allgc' list when
** object 'o' is being removed from the list.
*/
Fixo Vazio correctpointers (global_State *g, GCObject *o) {
  checkpointer(&g->survival, o);
  checkpointer(&g->old1, o);
  checkpointer(&g->reallyold, o);
  checkpointer(&g->firstold1, o);
}


/*
** Se object 'o' has a finalizer, remove it from 'allgc' list (must
** search the list to find it) and link it in 'finobj' list.
*/
Vazio sol_c_checkfinalizer (sol_State *L, GCObject *o, Table *mt) {
  global_State *g = G(L);
  Se (tofinalize(o) ||                 /* obj. is already marked... */
      gfasttm(g, mt, TM_GC) == NULL ||    /* or has no finalizer... */
      (g->gcstp & GCSTPCLS))                   /* or closing state? */
    Retorne;  /* nothing to be done */
  Senão {  /* move 'o' to 'finobj' list */
    GCObject **p;
    Se (issweepphase(g)) {
      makewhite(g, o);  /* "sweep" object 'o' */
      Se (g->sweepgc == &o->next)  /* should not remove 'sweepgc' object */
        g->sweepgc = sweeptolive(L, g->sweepgc);  /* change 'sweepgc' */
    }
    Senão
      correctpointers(g, o);
    /* search Para pointer pointing to 'o' */
    Para (p = &g->allgc; *p != o; p = &(*p)->next) { /* empty */ }
    *p = o->next;  /* remove 'o' from 'allgc' list */
    o->next = g->finobj;  /* link it in 'finobj' list */
    g->finobj = o;
    l_setbit(o->marked, FINALIZEDBIT);  /* mark it as such */
  }
}

/* }====================================================== */


/*
** {======================================================
** Generational Collector
** =======================================================
*/

/*
** Fields 'GCmarked' and 'GCmajorminor' are used to control the pace and
** the mode of the collector. They play several roles, depending on the
** mode of the collector:
** * KGC_INC:
**     GCmarked: number of marked bytes during a cycle.
**     GCmajorminor: not used.
** * KGC_GENMINOR
**     GCmarked: number of bytes that became old since last major collection.
**     GCmajorminor: number of bytes marked in last major collection.
** * KGC_GENMAJOR
**     GCmarked: number of bytes that became old since last major collection.
**     GCmajorminor: number of bytes marked in last major collection.
*/


/*
** Set the "time" to wait before starting a new incremental cycle;
** cycle will start when number of bytes in use hits the threshold of
** approximately (marked * pause / 100).
*/
Fixo Vazio setpause (global_State *g) {
  l_mem threshold = applygcparam(g, PAUSE, g->GCmarked);
  l_mem debt = threshold - gettotalbytes(g);
  Se (debt < 0) debt = 0;
  sol_e_setdebt(g, debt);
}


/*
** Sweep a list of objects to enter generational mode.  Deletes dead
** objects and turns the non dead to old. All non-dead threads---which
** are now old---must be in a gray list. Everything Senão is not in a
** gray list. Open upvalues are also kept gray.
*/
Fixo Vazio sweep2old (sol_State *L, GCObject **p) {
  GCObject *curr;
  global_State *g = G(L);
  Enquanto ((curr = *p) != NULL) {
    Se (iswhite(curr)) {  /* is 'curr' dead? */
      sol_assert(isdead(g, curr));
      *p = curr->next;  /* remove 'curr' from list */
      freeobj(L, curr);  /* erase 'curr' */
    }
    Senão {  /* all surviving objects become old */
      setage(curr, G_OLD);
      Se (curr->tt == SOL_VTHREAD) {  /* threads must be watched */
        sol_State *th = gco2th(curr);
        linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */
      }
      Senão Se (curr->tt == SOL_VUPVAL && upisopen(gco2upv(curr)))
        set2gray(curr);  /* open upvalues are always gray */
      Senão  /* everything Senão is black */
        nw2black(curr);
      p = &curr->next;  /* go to next element */
    }
  }
}


/*
** Sweep Para generational mode. Delete dead objects. (Because the
** collection is not incremental, there are no "new white" objects
** during the sweep. So, any white object must be dead.) For
** non-dead objects, advance their ages and clear the color of
** new objects. (Old objects keep their colors.)
** The ages of G_TOUCHED1 and G_TOUCHED2 objects cannot be advanced
** here, because these old-generation objects are usually not swept
** here.  They will all be advanced in 'correctgraylist'. That function
** will also remove objects turned white here from any gray list.
*/
Fixo GCObject **sweepgen (sol_State *L, global_State *g, GCObject **p,
                            GCObject *limit, GCObject **pfirstold1,
                            l_mem *paddedold) {
  Fixo Imutável lu_byte nextage[] = {
    G_SURVIVAL,  /* from G_NEW */
    G_OLD1,      /* from G_SURVIVAL */
    G_OLD1,      /* from G_OLD0 */
    G_OLD,       /* from G_OLD1 */
    G_OLD,       /* from G_OLD (Faça not change) */
    G_TOUCHED1,  /* from G_TOUCHED1 (Faça not change) */
    G_TOUCHED2   /* from G_TOUCHED2 (Faça not change) */
  };
  l_mem addedold = 0;
  Inteiro white = sol_c_white(g);
  GCObject *curr;
  Enquanto ((curr = *p) != limit) {
    Se (iswhite(curr)) {  /* is 'curr' dead? */
      sol_assert(!isold(curr) && isdead(g, curr));
      *p = curr->next;  /* remove 'curr' from list */
      freeobj(L, curr);  /* erase 'curr' */
    }
    Senão {  /* correct mark and age */
      Inteiro age = getage(curr);
      Se (age == G_NEW) {  /* new objects go back to white */
        Inteiro marked = curr->marked & ~maskgcbits;  /* erase GC bits */
        curr->marked = cast_byte(marked | G_SURVIVAL | white);
      }
      Senão {  /* all other objects will be old, and so keep their color */
        sol_assert(age != G_OLD1);  /* advanced in 'markold' */
        setage(curr, nextage[age]);
        Se (getage(curr) == G_OLD1) {
          addedold += objsize(curr);  /* bytes becoming old */
          Se (*pfirstold1 == NULL)
            *pfirstold1 = curr;  /* first OLD1 object in the list */
        }
      }
      p = &curr->next;  /* go to next element */
    }
  }
  *paddedold += addedold;
  Retorne p;
}


/*
** Correct a list of gray objects. Return a pointer to the last element
** left on the list, so that we can link another list to the end of
** this one.
** Because this correction is done after sweeping, young objects might
** be turned white and still be in the list. They are only removed.
** 'TOUCHED1' objects are advanced to 'TOUCHED2' and remain on the list;
** Non-white threads also remain on the list. 'TOUCHED2' objects and
** anything Senão become regular old, are marked black, and are removed
** from the list.
*/
Fixo GCObject **correctgraylist (GCObject **p) {
  GCObject *curr;
  Enquanto ((curr = *p) != NULL) {
    GCObject **next = getgclist(curr);
    Se (iswhite(curr))
      Execute remove;  /* remove all white objects */
    Senão Se (getage(curr) == G_TOUCHED1) {  /* touched in this cycle? */
      sol_assert(isgray(curr));
      nw2black(curr);  /* make it black, Para next barrier */
      setage(curr, G_TOUCHED2);
      Execute remain;  /* keep it in the list and go to next element */
    }
    Senão Se (curr->tt == SOL_VTHREAD) {
      sol_assert(isgray(curr));
      Execute remain;  /* keep non-white threads on the list */
    }
    Senão {  /* everything Senão is removed */
      sol_assert(isold(curr));  /* young objects should be white here */
      Se (getage(curr) == G_TOUCHED2)  /* advance from TOUCHED2... */
        setage(curr, G_OLD);  /* ... to OLD */
      nw2black(curr);  /* make object black (to be removed) */
      Execute remove;
    }
    remove: *p = *next; Continue;
    remain: p = next; Continue;
  }
  Retorne p;
}


/*
** Correct all gray lists, coalescing them into 'grayagain'.
*/
Fixo Vazio correctgraylists (global_State *g) {
  GCObject **list = correctgraylist(&g->grayagain);
  *list = g->weak; g->weak = NULL;
  list = correctgraylist(list);
  *list = g->allweak; g->allweak = NULL;
  list = correctgraylist(list);
  *list = g->ephemeron; g->ephemeron = NULL;
  correctgraylist(list);
}


/*
** Mark black 'OLD1' objects when starting a new young collection.
** Gray objects are already in some gray list, and so will be visited in
** the atomic step.
*/
Fixo Vazio markold (global_State *g, GCObject *from, GCObject *to) {
  GCObject *p;
  Para (p = from; p != to; p = p->next) {
    Se (getage(p) == G_OLD1) {
      sol_assert(!iswhite(p));
      setage(p, G_OLD);  /* now they are old */
      Se (isblack(p))
        reallymarkobject(g, p);
    }
  }
}


/*
** Finish a young-generation collection.
*/
Fixo Vazio finishgencycle (sol_State *L, global_State *g) {
  correctgraylists(g);
  checkSizes(L, g);
  g->gcstate = GCSpropagate;  /* skip restart */
  Se (!g->gcemergency)
    callallpendingfinalizers(L);
}


/*
** Shifts from a minor collection to major collections. It starts in
** the "sweep all" state to clear all objects, which are mostly black
** in generational mode.
*/
Fixo Vazio minor2inc (sol_State *L, global_State *g, lu_byte kind) {
  g->GCmajorminor = g->GCmarked;  /* number of live bytes */
  g->gckind = kind;
  g->reallyold = g->old1 = g->survival = NULL;
  g->finobjrold = g->finobjold1 = g->finobjsur = NULL;
  entersweep(L);  /* Continue as an incremental cycle */
  /* set a debt equal to the step size */
  sol_e_setdebt(g, applygcparam(g, STEPSIZE, 100));
}


/*
** Decide whether to shift to major mode. It shifts Se the accumulated
** number of added old bytes (counted in 'GCmarked') is larger than
** 'minormajor'% of the number of lived bytes after the last major
** collection. (This number is kept in 'GCmajorminor'.)
*/
Fixo Inteiro checkminormajor (global_State *g) {
  l_mem limit = applygcparam(g, MINORMAJOR, g->GCmajorminor);
  Se (limit == 0)
    Retorne 0;  /* special Caso: 'minormajor' 0 stops major collections */
  Retorne (g->GCmarked >= limit);
}

/*
** Does a young collection. First, mark 'OLD1' objects. Then does the
** atomic step. Then, check whether to Continue in minor mode. If so,
** sweep all lists and advance pointers. Finally, finish the collection.
*/
Fixo Vazio youngcollection (sol_State *L, global_State *g) {
  l_mem addedold1 = 0;
  l_mem marked = g->GCmarked;  /* preserve 'g->GCmarked' */
  GCObject **psurvival;  /* to point to first non-dead survival object */
  GCObject *dummy;  /* dummy out parameter to 'sweepgen' */
  sol_assert(g->gcstate == GCSpropagate);
  Se (g->firstold1) {  /* are there regular OLD1 objects? */
    markold(g, g->firstold1, g->reallyold);  /* mark them */
    g->firstold1 = NULL;  /* no more OLD1 objects (Para now) */
  }
  markold(g, g->finobj, g->finobjrold);
  markold(g, g->tobefnz, NULL);

  atomic(L);  /* will lose 'g->marked' */

  /* sweep nursery and get a pointer to its last live element */
  g->gcstate = GCSswpallgc;
  psurvival = sweepgen(L, g, &g->allgc, g->survival, &g->firstold1, &addedold1);
  /* sweep 'survival' */
  sweepgen(L, g, psurvival, g->old1, &g->firstold1, &addedold1);
  g->reallyold = g->old1;
  g->old1 = *psurvival;  /* 'survival' survivals are old now */
  g->survival = g->allgc;  /* all news are survivals */

  /* repeat Para 'finobj' lists */
  dummy = NULL;  /* no 'firstold1' optimization Para 'finobj' lists */
  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur, &dummy, &addedold1);
  /* sweep 'survival' */
  sweepgen(L, g, psurvival, g->finobjold1, &dummy, &addedold1);
  g->finobjrold = g->finobjold1;
  g->finobjold1 = *psurvival;  /* 'survival' survivals are old now */
  g->finobjsur = g->finobj;  /* all news are survivals */

  sweepgen(L, g, &g->tobefnz, NULL, &dummy, &addedold1);

  /* keep total number of added old1 bytes */
  g->GCmarked = marked + addedold1;

  /* decide whether to shift to major mode */
  Se (checkminormajor(g)) {
    minor2inc(L, g, KGC_GENMAJOR);  /* go to major mode */
    g->GCmarked = 0;  /* avoid pause in first major cycle (see 'setpause') */
  }
  Senão
    finishgencycle(L, g);  /* still in minor mode; finish it */
}


/*
** Clears all gray lists, sweeps objects, and prepare sublists to enter
** generational mode. The sweeps remove dead objects and turn all
** surviving objects to old. Threads go back to 'grayagain'; everything
** Senão is turned black (not in any gray list).
*/
Fixo Vazio atomic2gen (sol_State *L, global_State *g) {
  cleargraylists(g);
  /* sweep all elements making them old */
  g->gcstate = GCSswpallgc;
  sweep2old(L, &g->allgc);
  /* everything alive now is old */
  g->reallyold = g->old1 = g->survival = g->allgc;
  g->firstold1 = NULL;  /* there are no OLD1 objects anywhere */

  /* repeat Para 'finobj' lists */
  sweep2old(L, &g->finobj);
  g->finobjrold = g->finobjold1 = g->finobjsur = g->finobj;

  sweep2old(L, &g->tobefnz);

  g->gckind = KGC_GENMINOR;
  g->GCmajorminor = g->GCmarked;  /* "base" Para number of bytes */
  g->GCmarked = 0;  /* to count the number of added old1 bytes */
  finishgencycle(L, g);
}


/*
** Set debt Para the next minor collection, which will happen when
** total number of bytes grows 'genminormul'% in relation to
** the base, GCmajorminor, which is the number of bytes being used
** after the last major collection.
*/
Fixo Vazio setminordebt (global_State *g) {
  sol_e_setdebt(g, applygcparam(g, MINORMUL, g->GCmajorminor));
}


/*
** Enter generational mode. Must go until the end of an atomic cycle
** to ensure that all objects are correctly marked and weak tables
** are cleared. Then, turn all objects into old and finishes the
** collection.
*/
Fixo Vazio entergen (sol_State *L, global_State *g) {
  sol_c_runtilstate(L, GCSpause, 1);  /* prepare to start a new cycle */
  sol_c_runtilstate(L, GCSpropagate, 1);  /* start new cycle */
  atomic(L);  /* propagates all and then Faça the atomic stuff */
  atomic2gen(L, g);
  setminordebt(g);  /* set debt assuming next cycle will be minor */
}


/*
** Change collector mode to 'newmode'.
*/
Vazio sol_c_changemode (sol_State *L, Inteiro newmode) {
  global_State *g = G(L);
  Se (g->gckind == KGC_GENMAJOR)  /* doing major collections? */
    g->gckind = KGC_INC;  /* already incremental but in name */
  Se (newmode != g->gckind) {  /* does it need to change? */
    Se (newmode == KGC_INC)  /* entering incremental mode? */
      minor2inc(L, g, KGC_INC);  /* entering incremental mode */
    Senão {
      sol_assert(newmode == KGC_GENMINOR);
      entergen(L, g);
    }
  }
}


/*
** Does a full collection in generational mode.
*/
Fixo Vazio fullgen (sol_State *L, global_State *g) {
  minor2inc(L, g, KGC_INC);
  entergen(L, g);
}


/*
** After an atomic incremental step from a major collection,
** check whether collector could Retorne to minor collections.
** It checks whether the number of bytes 'tobecollected'
** is greater than 'majorminor'% of the number of bytes added
** since the last collection ('addedbytes').
*/
Fixo Inteiro checkmajorminor (sol_State *L, global_State *g) {
  Se (g->gckind == KGC_GENMAJOR) {  /* generational mode? */
    l_mem numbytes = gettotalbytes(g);
    l_mem addedbytes = numbytes - g->GCmajorminor;
    l_mem limit = applygcparam(g, MAJORMINOR, addedbytes);
    l_mem tobecollected = numbytes - g->GCmarked;
    Se (tobecollected > limit) {
      atomic2gen(L, g);  /* Retorne to generational mode */
      setminordebt(g);
      Retorne 1;  /* exit incremental collection */
    }
  }
  g->GCmajorminor = g->GCmarked;  /* prepare Para next collection */
  Retorne 0;  /* stay doing incremental collections */
}

/* }====================================================== */


/*
** {======================================================
** GC control
** =======================================================
*/


/*
** Enter first sweep phase.
** The call to 'sweeptolive' makes the pointer point to an object
** inside the list (instead of to the header), so that the real sweep Faça
** not need to skip objects created between "now" and the start of the
** real sweep.
*/
Fixo Vazio entersweep (sol_State *L) {
  global_State *g = G(L);
  g->gcstate = GCSswpallgc;
  sol_assert(g->sweepgc == NULL);
  g->sweepgc = sweeptolive(L, &g->allgc);
}


/*
** Delete all objects in list 'p' until (but not including) object
** 'limit'.
*/
Fixo Vazio deletelist (sol_State *L, GCObject *p, GCObject *limit) {
  Enquanto (p != limit) {
    GCObject *next = p->next;
    freeobj(L, p);
    p = next;
  }
}


/*
** Call all finalizers of the objects in the given Sol state, and
** then free all objects, except Para the main thread.
*/
Vazio sol_c_freeallobjects (sol_State *L) {
  global_State *g = G(L);
  g->gcstp = GCSTPCLS;  /* no extra finalizers after here */
  sol_c_changemode(L, KGC_INC);
  separatetobefnz(g, 1);  /* separate all objects with finalizers */
  sol_assert(g->finobj == NULL);
  callallpendingfinalizers(L);
  deletelist(L, g->allgc, obj2gco(mainthread(g)));
  sol_assert(g->finobj == NULL);  /* no new finalizers */
  deletelist(L, g->fixedgc, NULL);  /* collect fixed objects */
  sol_assert(g->strt.nuse == 0);
}


Fixo Vazio atomic (sol_State *L) {
  global_State *g = G(L);
  GCObject *origweak, *origall;
  GCObject *grayagain = g->grayagain;  /* save original list */
  g->grayagain = NULL;
  sol_assert(g->ephemeron == NULL && g->weak == NULL);
  sol_assert(!iswhite(mainthread(g)));
  g->gcstate = GCSatomic;
  markobject(g, L);  /* mark running thread */
  /* registry and global metatables may be changed by API */
  markvalue(g, &g->l_registry);
  markmt(g);  /* mark global metatables */
  propagateall(g);  /* empties 'gray' list */
  /* remark occasional upvalues of (maybe) dead threads */
  remarkupvals(g);
  propagateall(g);  /* propagate changes */
  g->gray = grayagain;
  propagateall(g);  /* traverse 'grayagain' list */
  convergeephemerons(g);
  /* at this point, all strongly accessible objects are marked. */
  /* Clear values from weak tables, before checking finalizers */
  clearbyvalues(g, g->weak, NULL);
  clearbyvalues(g, g->allweak, NULL);
  origweak = g->weak; origall = g->allweak;
  separatetobefnz(g, 0);  /* separate objects to be finalized */
  markbeingfnz(g);  /* mark objects that will be finalized */
  propagateall(g);  /* remark, to propagate 'resurrection' */
  convergeephemerons(g);
  /* at this point, all resurrected objects are marked. */
  /* remove dead objects from weak tables */
  clearbykeys(g, g->ephemeron);  /* clear keys from all ephemeron */
  clearbykeys(g, g->allweak);  /* clear keys from all 'allweak' */
  /* clear values from resurrected weak tables */
  clearbyvalues(g, g->weak, origweak);
  clearbyvalues(g, g->allweak, origall);
  sol_s_clearcache(g);
  g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */
  sol_assert(g->gray == NULL);
}


/*
** Do a sweep step. The normal Caso (not fast) sweeps at most GCSWEEPMAX
** elements. The fast Caso sweeps the whole list.
*/
Fixo Vazio sweepstep (sol_State *L, global_State *g,
                       lu_byte nextstate, GCObject **nextlist, Inteiro fast) {
  Se (g->sweepgc)
    g->sweepgc = sweeplist(L, g->sweepgc, fast ? MAX_LMEM : GCSWEEPMAX);
  Senão {  /* enter next state */
    g->gcstate = nextstate;
    g->sweepgc = nextlist;
  }
}


/*
** Performs one incremental "step" in an incremental garbage collection.
** For indivisible work, a step goes to the next state. When marking
** (propagating), a step traverses one object. When sweeping, a step
** sweeps GCSWEEPMAX objects, to avoid a big overhead Para sweeping
** objects one by one. (Sweeping is inexpensive, no matter the
** object.) When 'fast' is true, 'singlestep' tries to finish a state
** "as fast as possible". In particular, it skips the propagation
** phase and leaves all objects to be traversed by the atomic phase:
** That avoids traversing twice some objects, such as threads and
** weak tables.
*/

#Defina step2pause	-3  /* finished collection; entered pause state */
#Defina atomicstep	-2  /* atomic step */
#Defina step2minor	-1  /* moved to minor collections */


Fixo l_mem singlestep (sol_State *L, Inteiro fast) {
  global_State *g = G(L);
  l_mem stepresult;
  sol_assert(!g->gcstopem);  /* collector is not reentrant */
  g->gcstopem = 1;  /* no emergency collections Enquanto collecting */
  Troque (g->gcstate) {
    Caso GCSpause: {
      restartcollection(g);
      g->gcstate = GCSpropagate;
      stepresult = 1;
      Interrompa;
    }
    Caso GCSpropagate: {
      Se (fast || g->gray == NULL) {
        g->gcstate = GCSenteratomic;  /* finish propagate phase */
        stepresult = 1;
      }
      Senão
        stepresult = propagatemark(g);  /* traverse one gray object */
      Interrompa;
    }
    Caso GCSenteratomic: {
      atomic(L);
      Se (checkmajorminor(L, g))
        stepresult = step2minor;
      Senão {
        entersweep(L);
        stepresult = atomicstep;
      }
      Interrompa;
    }
    Caso GCSswpallgc: {  /* sweep "regular" objects */
      sweepstep(L, g, GCSswpfinobj, &g->finobj, fast);
      stepresult = GCSWEEPMAX;
      Interrompa;
    }
    Caso GCSswpfinobj: {  /* sweep objects with finalizers */
      sweepstep(L, g, GCSswptobefnz, &g->tobefnz, fast);
      stepresult = GCSWEEPMAX;
      Interrompa;
    }
    Caso GCSswptobefnz: {  /* sweep objects to be finalized */
      sweepstep(L, g, GCSswpend, NULL, fast);
      stepresult = GCSWEEPMAX;
      Interrompa;
    }
    Caso GCSswpend: {  /* finish sweeps */
      checkSizes(L, g);
      g->gcstate = GCScallfin;
      stepresult = GCSWEEPMAX;
      Interrompa;
    }
    Caso GCScallfin: {  /* call finalizers */
      Se (g->tobefnz && !g->gcemergency) {
        g->gcstopem = 0;  /* ok collections during finalizers */
        GCTM(L);  /* call one finalizer */
        stepresult = CWUFIN;
      }
      Senão {  /* emergency mode or no more finalizers */
        g->gcstate = GCSpause;  /* finish collection */
        stepresult = step2pause;
      }
      Interrompa;
    }
    Padrão: sol_assert(0); Retorne 0;
  }
  g->gcstopem = 0;
  Retorne stepresult;
}


/*
** Advances the garbage collector until it reaches the given state.
** (The option 'fast' is only Para testing; in normal code, 'fast'
** here is always true.)
*/
Vazio sol_c_runtilstate (sol_State *L, Inteiro state, Inteiro fast) {
  global_State *g = G(L);
  sol_assert(g->gckind == KGC_INC);
  Enquanto (state != g->gcstate)
    singlestep(L, fast);
}



/*
** Performs a basic incremental step. The step size is
** converted from bytes to "units of work"; then the function loops
** running single steps until adding that many units of work or
** finishing a cycle (pause state). Finally, it sets the debt that
** controls when next step will be performed.
*/
Fixo Vazio incstep (sol_State *L, global_State *g) {
  l_mem stepsize = applygcparam(g, STEPSIZE, 100);
  l_mem work2do = applygcparam(g, STEPMUL, stepsize / cast_int(Meça(Vazio*)));
  l_mem stres;
  Inteiro fast = (work2do == 0);  /* special Caso: Faça a full collection */
  Faça {  /* repeat until enough work */
    stres = singlestep(L, fast);  /* perform one single step */
    Se (stres == step2minor)  /* returned to minor collections? */
      Retorne;  /* nothing Senão to be done here */
    Senão Se (stres == step2pause || (stres == atomicstep && !fast))
      Interrompa;  /* end of cycle or atomic */
    Senão
      work2do -= stres;
  } Enquanto (fast || work2do > 0);
  Se (g->gcstate == GCSpause)
    setpause(g);  /* pause until next cycle */
  Senão
    sol_e_setdebt(g, stepsize);
}


#Se !Definido(sol_tracegc)
#Defina sol_tracegc(L,f)		((Vazio)0)
#FimSe

/*
** Performs a basic GC step Se collector is running. (If collector was
** stopped by the user, set a reasonable debt to avoid it being called
** at every single check.)
*/
Vazio sol_c_step (sol_State *L) {
  global_State *g = G(L);
  sol_assert(!g->gcemergency);
  Se (!gcrunning(g)) {  /* not running? */
    Se (g->gcstp & GCSTPUSR)  /* stopped by the user? */
      sol_e_setdebt(g, 20000);
  }
  Senão {
    sol_tracegc(L, 1);  /* Para internal debugging */
    Troque (g->gckind) {
      Caso KGC_INC: Caso KGC_GENMAJOR:
        incstep(L, g);
        Interrompa;
      Caso KGC_GENMINOR:
        youngcollection(L, g);
        setminordebt(g);
        Interrompa;
    }
    sol_tracegc(L, 0);  /* Para internal debugging */
  }
}


/*
** Perform a full collection in incremental mode.
** Before running the collection, check 'keepinvariant'; Se it is true,
** there may be some objects marked as black, so the collector has
** to sweep all objects to turn them back to white (as white has not
** changed, nothing will be collected).
*/
Fixo Vazio fullinc (sol_State *L, global_State *g) {
  Se (keepinvariant(g))  /* black objects? */
    entersweep(L); /* sweep everything to turn them back to white */
  /* finish any pending sweep phase to start a new cycle */
  sol_c_runtilstate(L, GCSpause, 1);
  sol_c_runtilstate(L, GCScallfin, 1);  /* run up to finalizers */
  sol_c_runtilstate(L, GCSpause, 1);  /* finish collection */
  setpause(g);
}


/*
** Performs a full GC cycle; Se 'isemergency', set a flag to avoid
** some operations which could change the interpreter state in some
** unexpected ways (running finalizers and shrinking some structures).
*/
Vazio sol_c_fullgc (sol_State *L, Inteiro isemergency) {
  global_State *g = G(L);
  sol_assert(!g->gcemergency);
  g->gcemergency = cast_byte(isemergency);  /* set flag */
  Troque (g->gckind) {
    Caso KGC_GENMINOR: fullgen(L, g); Interrompa;
    Caso KGC_INC: fullinc(L, g); Interrompa;
    Caso KGC_GENMAJOR:
      g->gckind = KGC_INC;
      fullinc(L, g);
      g->gckind = KGC_GENMAJOR;
      Interrompa;
  }
  g->gcemergency = 0;
}

/* }====================================================== */


