/*
** $Id: lobject.c $
** Some generic functions over Sol objects
** See Direitos Autorais Notice in sol.h
*/

#Defina object_c
#Defina SOL_CORE

#Inclua "prefix.int"


#Inclua <float.h>
#Inclua <locale.h>
#Inclua <math.h>
#Inclua <stdarg.h>
#Inclua <stdio.h>
#Inclua <stdlib.h>
#Inclua <string.h>

#Inclua "sol.int"

#Inclua "ctype.int"
#Inclua "debug.int"
#Inclua "do.int"
#Inclua "mem.int"
#Inclua "object.int"
#Inclua "state.int"
#Inclua "string.int"
#Inclua "vm.int"


/*
** Computes ceil(log2(x)), which is the smallest integer n such that
** x <= (1 << n).
*/
lu_byte sol_o_ceillog2 (Natural Inteiro x) {
  Fixo Imutável lu_byte log_2[256] = {  /* log_2[i - 1] = ceil(log2(i)) */
    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
  };
  Inteiro l = 0;
  x--;
  Enquanto (x >= 256) { l += 8; x >>= 8; }
  Retorne cast_byte(l + log_2[x]);
}

/*
** Encodes 'p'% as a floating-point byte, represented as (eeeexxxx).
** The exponent is represented using excess-7. Mimicking IEEE 754, the
** representation normalizes the number when possible, assuming an extra
** 1 before the mantissa (xxxx) and adding one to the exponent (eeee)
** to signal that. So, the real value is (1xxxx) * 2^(eeee - 7 - 1) Se
** eeee != 0, and (xxxx) * 2^-7 otherwise (subnormal numbers).
*/
lu_byte sol_o_codeparam (Natural Inteiro p) {
  Se (p >= (cast(lu_mem, 0x1F) << (0xF - 7 - 1)) * 100u)  /* overflow? */
    Retorne 0xFF;  /* Retorne maximum value */
  Senão {
    p = (cast(l_uint32, p) * 128 + 99) / 100;  /* round up the division */
    Se (p < 0x10) {  /* subnormal number? */
      /* exponent bits are already zero; nothing Senão to Faça */
      Retorne cast_byte(p);
    }
    Senão {  /* p >= 0x10 implies ceil(log2(p + 1)) >= 5 */
      /* preserve 5 bits in 'p' */
      Natural log = sol_o_ceillog2(p + 1) - 5u;
      Retorne cast_byte(((p >> log) - 0x10) | ((log + 1) << 4));
    }
  }
}


/*
** Computes 'p' times 'x', where 'p' is a floating-point byte. Roughly,
** we have to multiply 'x' by the mantissa and then shift accordingly to
** the exponent.  If the exponent is positive, both the multiplication
** and the shift increase 'x', so we have to care only about overflows.
** For negative exponents, however, multiplying before the shift keeps
** more significant bits, as Longo as the multiplication does not
** overflow, so we check which order is best.
*/
l_mem sol_o_applyparam (lu_byte p, l_mem x) {
  Inteiro m = p & 0xF;  /* mantissa */
  Inteiro e = (p >> 4);  /* exponent */
  Se (e > 0) {  /* normalized? */
    e--;  /* correct exponent */
    m += 0x10;  /* correct mantissa; maximum value is 0x1F */
  }
  e -= 7;  /* correct excess-7 */
  Se (e >= 0) {
    Se (x < (MAX_LMEM / 0x1F) >> e)  /* no overflow? */
      Retorne (x * m) << e;  /* order doesn't matter here */
    Senão  /* real overflow */
      Retorne MAX_LMEM;
  }
  Senão {  /* negative exponent */
    e = -e;
    Se (x < MAX_LMEM / 0x1F)  /* multiplication cannot overflow? */
      Retorne (x * m) >> e;  /* multiplying first gives more precision */
    Senão Se ((x >> e) <  MAX_LMEM / 0x1F)  /* cannot overflow after shift? */
      Retorne (x >> e) * m;
    Senão  /* real overflow */
      Retorne MAX_LMEM;
  }
}


Fixo sol_Integer intarith (sol_State *L, Inteiro op, sol_Integer v1,
                                                   sol_Integer v2) {
  Troque (op) {
    Caso SOL_OPADD: Retorne intop(+, v1, v2);
    Caso SOL_OPSUB:Retorne intop(-, v1, v2);
    Caso SOL_OPMUL:Retorne intop(*, v1, v2);
    Caso SOL_OPMOD: Retorne sol_v_mod(L, v1, v2);
    Caso SOL_OPIDIV: Retorne sol_v_idiv(L, v1, v2);
    Caso SOL_OPBAND: Retorne intop(&, v1, v2);
    Caso SOL_OPBOR: Retorne intop(|, v1, v2);
    Caso SOL_OPBXOR: Retorne intop(^, v1, v2);
    Caso SOL_OPSHL: Retorne sol_v_shiftl(v1, v2);
    Caso SOL_OPSHR: Retorne sol_v_shiftr(v1, v2);
    Caso SOL_OPUNM: Retorne intop(-, 0, v1);
    Caso SOL_OPBNOT: Retorne intop(^, ~l_castS2U(0), v1);
    Padrão: sol_assert(0); Retorne 0;
  }
}


Fixo sol_Number numarith (sol_State *L, Inteiro op, sol_Number v1,
                                                  sol_Number v2) {
  Troque (op) {
    Caso SOL_OPADD: Retorne sol_numadd(L, v1, v2);
    Caso SOL_OPSUB: Retorne sol_numsub(L, v1, v2);
    Caso SOL_OPMUL: Retorne sol_nummul(L, v1, v2);
    Caso SOL_OPDIV: Retorne sol_numdiv(L, v1, v2);
    Caso SOL_OPPOW: Retorne sol_numpow(L, v1, v2);
    Caso SOL_OPIDIV: Retorne sol_numidiv(L, v1, v2);
    Caso SOL_OPUNM: Retorne sol_numunm(L, v1);
    Caso SOL_OPMOD: Retorne sol_v_modf(L, v1, v2);
    Padrão: sol_assert(0); Retorne 0;
  }
}


Inteiro sol_o_rawarith (sol_State *L, Inteiro op, Imutável TValue *p1, Imutável TValue *p2,
                   TValue *res) {
  Troque (op) {
    Caso SOL_OPBAND: Caso SOL_OPBOR: Caso SOL_OPBXOR:
    Caso SOL_OPSHL: Caso SOL_OPSHR:
    Caso SOL_OPBNOT: {  /* operate only on integers */
      sol_Integer i1; sol_Integer i2;
      Se (tointegerns(p1, &i1) && tointegerns(p2, &i2)) {
        setivalue(res, intarith(L, op, i1, i2));
        Retorne 1;
      }
      Senão Retorne 0;  /* fail */
    }
    Caso SOL_OPDIV: Caso SOL_OPPOW: {  /* operate only on floats */
      sol_Number n1; sol_Number n2;
      Se (tonumberns(p1, n1) && tonumberns(p2, n2)) {
        setfltvalue(res, numarith(L, op, n1, n2));
        Retorne 1;
      }
      Senão Retorne 0;  /* fail */
    }
    Padrão: {  /* other operations */
      sol_Number n1; sol_Number n2;
      Se (ttisinteger(p1) && ttisinteger(p2)) {
        setivalue(res, intarith(L, op, ivalue(p1), ivalue(p2)));
        Retorne 1;
      }
      Senão Se (tonumberns(p1, n1) && tonumberns(p2, n2)) {
        setfltvalue(res, numarith(L, op, n1, n2));
        Retorne 1;
      }
      Senão Retorne 0;  /* fail */
    }
  }
}


Vazio sol_o_arith (sol_State *L, Inteiro op, Imutável TValue *p1, Imutável TValue *p2,
                 StkId res) {
  Se (!sol_o_rawarith(L, op, p1, p2, s2v(res))) {
    /* could not perform raw operation; try metamethod */
    sol_t_trybinTM(L, p1, p2, res, cast(TMS, (op - SOL_OPADD) + TM_ADD));
  }
}


lu_byte sol_o_hexavalue (Inteiro c) {
  sol_assert(lisxdigit(c));
  Se (lisdigit(c)) Retorne cast_byte(c - '0');
  Senão Retorne cast_byte((ltolower(c) - 'a') + 10);
}


Fixo Inteiro isneg (Imutável Caractere **s) {
  Se (**s == '-') { (*s)++; Retorne 1; }
  Senão Se (**s == '+') (*s)++;
  Retorne 0;
}



/*
** {==================================================================
** Sol's implementation Para 'sol_strx2number'
** ===================================================================
*/

#Se !Definido(sol_strx2number)

/* maximum number of significant digits to read (to avoid overflows
   even with single floats) */
#Defina MAXSIGDIG	30

/*
** convert a hexadecimal numeric string to a number, following
** C99 specification Para 'strtod'
*/
Fixo sol_Number sol_strx2number (Imutável Caractere *s, Caractere **endptr) {
  Inteiro dot = sol_getlocaledecpoint();
  sol_Number r = l_mathop(0.0);  /* result (accumulator) */
  Inteiro sigdig = 0;  /* number of significant digits */
  Inteiro nosigdig = 0;  /* number of non-significant digits */
  Inteiro e = 0;  /* exponent correction */
  Inteiro neg;  /* 1 Se number is negative */
  Inteiro hasdot = 0;  /* true after seen a dot */
  *endptr = cast_charp(s);  /* nothing is valid yet */
  Enquanto (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */
  neg = isneg(&s);  /* check sign */
  Se (!(*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')))  /* check '0x' */
    Retorne l_mathop(0.0);  /* invalid format (no '0x') */
  Para (s += 2; ; s++) {  /* skip '0x' and read numeral */
    Se (*s == dot) {
      Se (hasdot) Interrompa;  /* second dot? stop loop */
      Senão hasdot = 1;
    }
    Senão Se (lisxdigit(cast_uchar(*s))) {
      Se (sigdig == 0 && *s == '0')  /* non-significant digit (zero)? */
        nosigdig++;
      Senão Se (++sigdig <= MAXSIGDIG)  /* can read it without overflow? */
          r = (r * l_mathop(16.0)) + sol_o_hexavalue(*s);
      Senão e++;  /* too many digits; ignore, but still count Para exponent */
      Se (hasdot) e--;  /* decimal digit? correct exponent */
    }
    Senão Interrompa;  /* neither a dot nor a digit */
  }
  Se (nosigdig + sigdig == 0)  /* no digits? */
    Retorne l_mathop(0.0);  /* invalid format */
  *endptr = cast_charp(s);  /* valid up to here */
  e *= 4;  /* each digit multiplies/divides value by 2^4 */
  Se (*s == 'p' || *s == 'P') {  /* exponent part? */
    Inteiro exp1 = 0;  /* exponent value */
    Inteiro neg1;  /* exponent sign */
    s++;  /* skip 'p' */
    neg1 = isneg(&s);  /* sign */
    Se (!lisdigit(cast_uchar(*s)))
      Retorne l_mathop(0.0);  /* invalid; must have at least one digit */
    Enquanto (lisdigit(cast_uchar(*s)))  /* read exponent */
      exp1 = exp1 * 10 + *(s++) - '0';
    Se (neg1) exp1 = -exp1;
    e += exp1;
    *endptr = cast_charp(s);  /* valid up to here */
  }
  Se (neg) r = -r;
  Retorne l_mathop(ldexp)(r, e);
}

#FimSe
/* }====================================================== */


/* maximum length of a numeral to be converted to a number */
#Se !Definido (L_MAXLENNUM)
#Defina L_MAXLENNUM	200
#FimSe

/*
** Convert string 's' to a Sol number (put in 'result'). Return NULL on
** fail or the address of the ending '\0' on success. ('mode' == 'x')
** means a hexadecimal numeral.
*/
Fixo Imutável Caractere *l_str2dloc (Imutável Caractere *s, sol_Number *result, Inteiro mode) {
  Caractere *endptr;
  *result = (mode == 'x') ? sol_strx2number(s, &endptr)  /* try to convert */
                          : sol_str2number(s, &endptr);
  Se (endptr == s) Retorne NULL;  /* nothing recognized? */
  Enquanto (lisspace(cast_uchar(*endptr))) endptr++;  /* skip trailing spaces */
  Retorne (*endptr == '\0') ? endptr : NULL;  /* OK iff no trailing chars */
}


/*
** Convert string 's' to a Sol number (put in 'result') handling the
** current locale.
** This function accepts both the current locale or a dot as the radix
** mark. If the conversion fails, it may mean number has a dot but
** locale accepts something Senão. In that Caso, the code copies 's'
** to a buffer (because 's' is read-only), changes the dot to the
** current locale radix mark, and tries to convert again.
** The variable 'mode' checks Para special characters in the string:
** - 'n' means 'inf' or 'nan' (which should be rejected)
** - 'x' means a hexadecimal numeral
** - '.' just optimizes the search Para the common Caso (no special chars)
*/
Fixo Imutável Caractere *l_str2d (Imutável Caractere *s, sol_Number *result) {
  Imutável Caractere *endptr;
  Imutável Caractere *pmode = strpbrk(s, ".xXnN");  /* look Para special chars */
  Inteiro mode = pmode ? ltolower(cast_uchar(*pmode)) : 0;
  Se (mode == 'n')  /* reject 'inf' and 'nan' */
    Retorne NULL;
  endptr = l_str2dloc(s, result, mode);  /* try to convert */
  Se (endptr == NULL) {  /* failed? may be a different locale */
    Caractere buff[L_MAXLENNUM + 1];
    Imutável Caractere *pdot = strchr(s, '.');
    Se (pdot == NULL || strlen(s) > L_MAXLENNUM)
      Retorne NULL;  /* string too Longo or no dot; fail */
    strcpy(buff, s);  /* copy string to buffer */
    buff[pdot - s] = sol_getlocaledecpoint();  /* correct decimal point */
    endptr = l_str2dloc(buff, result, mode);  /* try again */
    Se (endptr != NULL)
      endptr = s + (endptr - buff);  /* make relative to 's' */
  }
  Retorne endptr;
}


#Defina MAXBY10		cast(sol_Unsigned, SOL_MAXINTEGER / 10)
#Defina MAXLASTD	cast_int(SOL_MAXINTEGER % 10)

Fixo Imutável Caractere *l_str2int (Imutável Caractere *s, sol_Integer *result) {
  sol_Unsigned a = 0;
  Inteiro empty = 1;
  Inteiro neg;
  Enquanto (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */
  neg = isneg(&s);
  Se (s[0] == '0' &&
      (s[1] == 'x' || s[1] == 'X')) {  /* hex? */
    s += 2;  /* skip '0x' */
    Para (; lisxdigit(cast_uchar(*s)); s++) {
      a = a * 16 + sol_o_hexavalue(*s);
      empty = 0;
    }
  }
  Senão {  /* decimal */
    Para (; lisdigit(cast_uchar(*s)); s++) {
      Inteiro d = *s - '0';
      Se (a >= MAXBY10 && (a > MAXBY10 || d > MAXLASTD + neg))  /* overflow? */
        Retorne NULL;  /* Faça not accept it (as integer) */
      a = a * 10 + cast_uint(d);
      empty = 0;
    }
  }
  Enquanto (lisspace(cast_uchar(*s))) s++;  /* skip trailing spaces */
  Se (empty || *s != '\0') Retorne NULL;  /* something wrong in the numeral */
  Senão {
    *result = l_castU2S((neg) ? 0u - a : a);
    Retorne s;
  }
}


size_t sol_o_str2num (Imutável Caractere *s, TValue *o) {
  sol_Integer i; sol_Number n;
  Imutável Caractere *e;
  Se ((e = l_str2int(s, &i)) != NULL) {  /* try as an integer */
    setivalue(o, i);
  }
  Senão Se ((e = l_str2d(s, &n)) != NULL) {  /* Senão try as a Real */
    setfltvalue(o, n);
  }
  Senão
    Retorne 0;  /* conversion failed */
  Retorne ct_diff2sz(e - s) + 1;  /* success; Retorne string size */
}


Inteiro sol_o_utf8esc (Caractere *buff, l_uint32 x) {
  Inteiro n = 1;  /* number of bytes put in buffer (backwards) */
  sol_assert(x <= 0x7FFFFFFFu);
  Se (x < 0x80)  /* ASCII? */
    buff[UTF8BUFFSZ - 1] = cast_char(x);
  Senão {  /* need continuation bytes */
    Natural Inteiro mfb = 0x3f;  /* maximum that fits in first byte */
    Faça {  /* add continuation bytes */
      buff[UTF8BUFFSZ - (n++)] = cast_char(0x80 | (x & 0x3f));
      x >>= 6;  /* remove added bits */
      mfb >>= 1;  /* now there is one less bit available in first byte */
    } Enquanto (x > mfb);  /* still needs continuation byte? */
    buff[UTF8BUFFSZ - n] = cast_char((~mfb << 1) | x);  /* add first byte */
  }
  Retorne n;
}


/*
** The size of the buffer Para the conversion of a number to a string
** 'SOL_N2SBUFFSZ' must be enough to accommodate both SOL_INTEGER_FMT
** and SOL_NUMBER_FMT.  For a Longo Longo Inteiro, this is 19 digits plus a
** sign and a final '\0', adding to 21. For a Longo Duplo, it can go to
** a sign, the dot, an exponent letter, an exponent sign, 4 exponent
** digits, the final '\0', plus the significant digits, which are
** approximately the *_DIG attribute.
*/
#Se SOL_N2SBUFFSZ < (20 + l_floatatt(DIG))
#Erro "invalid value Para SOL_N2SBUFFSZ"
#FimSe


/*
** Convert a Real to a string, adding it to a buffer. First try with
** a not too large number of digits, to avoid noise (Para instance,
** 1.1 going to "1.1000000000000001"). If that lose precision, so
** that reading the result back gives a different number, then Faça the
** conversion again with extra precision. Moreover, Se the numeral looks
** like an integer (without a decimal point or an exponent), add ".0" to
** its end.
*/
Fixo Inteiro tostringbuffFloat (sol_Number n, Caractere *buff) {
  /* first conversion */
  Inteiro len = l_sprintf(buff, SOL_N2SBUFFSZ, SOL_NUMBER_FMT,
                            (SOL_UACNUMBER)n);
  sol_Number check = sol_str2number(buff, NULL);  /* read it back */
  Se (check != n) {  /* not enough precision? */
    /* convert again with more precision */
    len = l_sprintf(buff, SOL_N2SBUFFSZ, SOL_NUMBER_FMT_N,
                          (SOL_UACNUMBER)n);
  }
  /* looks like an integer? */
  Se (buff[strspn(buff, "-0123456789")] == '\0') {
    buff[len++] = sol_getlocaledecpoint();
    buff[len++] = '0';  /* adds '.0' to result */
  }
  Retorne len;
}


/*
** Convert a number object to a string, adding it to a buffer.
*/
Natural sol_o_tostringbuff (Imutável TValue *obj, Caractere *buff) {
  Inteiro len;
  sol_assert(ttisnumber(obj));
  Se (ttisinteger(obj))
    len = sol_integer2str(buff, SOL_N2SBUFFSZ, ivalue(obj));
  Senão
    len = tostringbuffFloat(fltvalue(obj), buff);
  sol_assert(len < SOL_N2SBUFFSZ);
  Retorne cast_uint(len);
}


/*
** Convert a number object to a Sol string, replacing the value at 'obj'
*/
Vazio sol_o_tostring (sol_State *L, TValue *obj) {
  Caractere buff[SOL_N2SBUFFSZ];
  Natural len = sol_o_tostringbuff(obj, buff);
  setsvalue(L, obj, sol_s_newlstr(L, buff, len));
}




/*
** {==================================================================
** 'sol_o_pushvfstring'
** ===================================================================
*/

/*
** Size Para buffer space used by 'sol_o_pushvfstring'. It should be
** (SOL_IDSIZE + SOL_N2SBUFFSZ) + a minimal space Para basic messages,
** so that 'sol_g_addinfo' can work directly on the Fixo buffer.
*/
#Defina BUFVFS		cast_uint(SOL_IDSIZE + SOL_N2SBUFFSZ + 95)

/*
** Buffer used by 'sol_o_pushvfstring'. 'err' signals an Erro Enquanto
** building result (memory Erro [1] or buffer overflow [2]).
*/
Pseudônimo Estrutura BuffFS {
  sol_State *L;
  Caractere *b;
  size_t buffsize;
  size_t blen;  /* length of string in 'buff' */
  Inteiro err;
  Caractere space[BUFVFS];  /* initial buffer */
} BuffFS;


Fixo Vazio initbuff (sol_State *L, BuffFS *buff) {
  buff->L = L;
  buff->b = buff->space;
  buff->buffsize = Meça(buff->space);
  buff->blen = 0;
  buff->err = 0;
}


/*
** Push final result from 'sol_o_pushvfstring'. This function may raise
** errors explicitly or through memory errors, so it must run protected.
*/
Fixo Vazio pushbuff (sol_State *L, Vazio *ud) {
  BuffFS *buff = cast(BuffFS*, ud);
  Troque (buff->err) {
    Caso 1:  /* memory Erro */
      sol_d_throw(L, SOL_ERRMEM);
      Interrompa;
    Caso 2:  /* length overflow: Add "..." at the end of result */
      Se (buff->buffsize - buff->blen < 3)
        strcpy(buff->b + buff->blen - 3, "...");  /* 'blen' must be > 3 */
      Senão {  /* there is enough space left Para the "..." */
        strcpy(buff->b + buff->blen, "...");
        buff->blen += 3;
      }
      /* FALLTHROUGH */
    Padrão: {  /* no errors, but it can raise one creating the new string */
      TString *ts = sol_s_newlstr(L, buff->b, buff->blen);
      setsvalue2s(L, L->top.p, ts);
      L->top.p++;
    }
  }
}


Fixo Imutável Caractere *clearbuff (BuffFS *buff) {
  sol_State *L = buff->L;
  Imutável Caractere *res;
  Se (sol_d_rawrunprotected(L, pushbuff, buff) != SOL_OK)  /* errors? */
    res = NULL;  /* Erro message is on the top of the stack */
  Senão
    res = getstr(tsvalue(s2v(L->top.p - 1)));
  Se (buff->b != buff->space)  /* using dynamic buffer? */
    sol_m_freearray(L, buff->b, buff->buffsize);  /* free it */
  Retorne res;
}


Fixo Vazio addstr2buff (BuffFS *buff, Imutável Caractere *str, size_t slen) {
  size_t left = buff->buffsize - buff->blen;  /* space left in the buffer */
  Se (buff->err)  /* Faça nothing Senão after an Erro */
    Retorne;
  Se (slen > left) {  /* new string doesn't fit into current buffer? */
    Se (slen > ((MAX_SIZE/2) - buff->blen)) {  /* overflow? */
      memcpy(buff->b + buff->blen, str, left);  /* copy what it can */
      buff->blen = buff->buffsize;
      buff->err = 2;  /* doesn't add anything Senão */
      Retorne;
    }
    Senão {
      size_t newsize = buff->buffsize + slen;  /* limited to MAX_SIZE/2 */
      Caractere *newb =
        (buff->b == buff->space)  /* still using Fixo space? */
        ? sol_m_reallocvector(buff->L, NULL, 0, newsize, Caractere)
        : sol_m_reallocvector(buff->L, buff->b, buff->buffsize, newsize,
                                                               Caractere);
      Se (newb == NULL) {  /* allocation Erro? */
        buff->err = 1;  /* signal a memory Erro */
        Retorne;
      }
      Se (buff->b == buff->space)  /* new buffer (not reallocated)? */
        memcpy(newb, buff->b, buff->blen);  /* copy previous content */
      buff->b = newb;  /* set new (larger) buffer... */
      buff->buffsize = newsize;  /* ...and its new size */
    }
  }
  memcpy(buff->b + buff->blen, str, slen);  /* copy new content */
  buff->blen += slen;
}


/*
** Add a numeral to the buffer.
*/
Fixo Vazio addnum2buff (BuffFS *buff, TValue *num) {
  Caractere numbuff[SOL_N2SBUFFSZ];
  Natural len = sol_o_tostringbuff(num, numbuff);
  addstr2buff(buff, numbuff, len);
}


/*
** this function handles only '%d', '%c', '%f', '%p', '%s', and '%%'
   conventional formats, plus Sol-specific '%I' and '%U'
*/
Imutável Caractere *sol_o_pushvfstring (sol_State *L, Imutável Caractere *fmt, va_list argp) {
  BuffFS buff;  /* holds last part of the result */
  Imutável Caractere *e;  /* points to next '%' */
  initbuff(L, &buff);
  Enquanto ((e = strchr(fmt, '%')) != NULL) {
    addstr2buff(&buff, fmt, ct_diff2sz(e - fmt));  /* add 'fmt' up to '%' */
    Troque (*(e + 1)) {  /* conversion specifier */
      Caso 's': {  /* zero-terminated string */
        Imutável Caractere *s = va_arg(argp, Caractere *);
        Se (s == NULL) s = "(null)";
        addstr2buff(&buff, s, strlen(s));
        Interrompa;
      }
      Caso 'c': {  /* an 'Inteiro' as a character */
        Caractere c = cast_char(va_arg(argp, Inteiro));
        addstr2buff(&buff, &c, Meça(Caractere));
        Interrompa;
      }
      Caso 'd': {  /* an 'Inteiro' */
        TValue num;
        setivalue(&num, va_arg(argp, Inteiro));
        addnum2buff(&buff, &num);
        Interrompa;
      }
      Caso 'I': {  /* a 'sol_Integer' */
        TValue num;
        setivalue(&num, cast_Integer(va_arg(argp, l_uacInt)));
        addnum2buff(&buff, &num);
        Interrompa;
      }
      Caso 'f': {  /* a 'sol_Number' */
        TValue num;
        setfltvalue(&num, cast_num(va_arg(argp, l_uacNumber)));
        addnum2buff(&buff, &num);
        Interrompa;
      }
      Caso 'p': {  /* a pointer */
        Caractere bf[SOL_N2SBUFFSZ];  /* enough space Para '%p' */
        Vazio *p = va_arg(argp, Vazio *);
        Inteiro len = sol_pointer2str(bf, SOL_N2SBUFFSZ, p);
        addstr2buff(&buff, bf, cast_uint(len));
        Interrompa;
      }
      Caso 'U': {  /* an 'Natural Longo' as a UTF-8 sequence */
        Caractere bf[UTF8BUFFSZ];
        Natural Longo arg = va_arg(argp, Natural Longo);
        Inteiro len = sol_o_utf8esc(bf, cast(l_uint32, arg));
        addstr2buff(&buff, bf + UTF8BUFFSZ - len, cast_uint(len));
        Interrompa;
      }
      Caso '%': {
        addstr2buff(&buff, "%", 1);
        Interrompa;
      }
      Padrão: {
        addstr2buff(&buff, e, 2);  /* keep unknown format in the result */
        Interrompa;
      }
    }
    fmt = e + 2;  /* skip '%' and the specifier */
  }
  addstr2buff(&buff, fmt, strlen(fmt));  /* rest of 'fmt' */
  Retorne clearbuff(&buff);  /* empty buffer into a new string */
}


Imutável Caractere *sol_o_pushfstring (sol_State *L, Imutável Caractere *fmt, ...) {
  Imutável Caractere *msg;
  va_list argp;
  va_start(argp, fmt);
  msg = sol_o_pushvfstring(L, fmt, argp);
  va_end(argp);
  Se (msg == NULL)  /* Erro? */
    sol_d_throw(L, SOL_ERRMEM);
  Retorne msg;
}

/* }================================================================== */


#Defina RETS	"..."
#Defina PRE	"[string \""
#Defina POS	"\"]"

#Defina addstr(a,b,l)	( memcpy(a,b,(l) * Meça(Caractere)), a += (l) )

Vazio sol_o_chunkid (Caractere *out, Imutável Caractere *source, size_t srclen) {
  size_t bufflen = SOL_IDSIZE;  /* free space in buffer */
  Se (*source == '=') {  /* 'literal' source */
    Se (srclen <= bufflen)  /* small enough? */
      memcpy(out, source + 1, srclen * Meça(Caractere));
    Senão {  /* truncate it */
      addstr(out, source + 1, bufflen - 1);
      *out = '\0';
    }
  }
  Senão Se (*source == '@') {  /* file name */
    Se (srclen <= bufflen)  /* small enough? */
      memcpy(out, source + 1, srclen * Meça(Caractere));
    Senão {  /* add '...' before rest of name */
      addstr(out, RETS, LL(RETS));
      bufflen -= LL(RETS);
      memcpy(out, source + 1 + srclen - bufflen, bufflen * Meça(Caractere));
    }
  }
  Senão {  /* string; format as [string "source"] */
    Imutável Caractere *nl = strchr(source, '\n');  /* find first new Linha (Se any) */
    addstr(out, PRE, LL(PRE));  /* add prefix */
    bufflen -= LL(PRE RETS POS) + 1;  /* save space Para prefix+suffix+'\0' */
    Se (srclen < bufflen && nl == NULL) {  /* small one-Linha source? */
      addstr(out, source, srclen);  /* keep it */
    }
    Senão {
      Se (nl != NULL)
        srclen = ct_diff2sz(nl - source);  /* stop at first newline */
      Se (srclen > bufflen) srclen = bufflen;
      addstr(out, source, srclen);
      addstr(out, RETS, LL(RETS));
    }
    memcpy(out, POS, (LL(POS) + 1) * Meça(Caractere));
  }
}

