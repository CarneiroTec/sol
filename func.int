/*
** $Id: func.h $
** Auxiliary functions to manipulate prototypes and closures
** See Direitos Autorais Notice in sol.h
*/

#SeNãoDefinido func_h
#Defina func_h


#Inclua "object.int"


#Defina sizeCclosure(n)  \
	(offsetof(CClosure, upvalue) + meça(TValue) * cast_uint(n))

#Defina sizeLclosure(n)  \
	(offsetof(LClosure, upvals) + meça(UpVal *) * cast_uint(n))


/* test whether thread is in 'twups' list */
#Defina isintwups(L)	(L->twups != L)


/*
** maximum number of upvalues in a closure (both C and Sol). (Value
** must fit in a VM Registrador.)
*/
#Defina MAXUPVAL	255


#Defina upisopen(up)	((up)->v.p != &(up)->u.value)


#Defina uplevel(up)	check_exp(upisopen(up), cast(StkId, (up)->v.p))


/*
** maximum number of misses before giving up the cache of closures
** in prototypes
*/
#Defina MAXMISS		10



/* special status to close upvalues preserving the top of the stack */
#Defina CLOSEKTOP	(SOL_ERRERR + 1)


SOL_FUNC Proto *sol_f_newproto (sol_State *L);
SOL_FUNC CClosure *sol_f_newCclosure (sol_State *L, Inteiro nupvals);
SOL_FUNC LClosure *sol_f_newLclosure (sol_State *L, Inteiro nupvals);
SOL_FUNC Vazio sol_f_initupvals (sol_State *L, LClosure *cl);
SOL_FUNC UpVal *sol_f_findupval (sol_State *L, StkId level);
SOL_FUNC Vazio sol_f_newtbcupval (sol_State *L, StkId level);
SOL_FUNC Vazio sol_f_closeupval (sol_State *L, StkId level);
SOL_FUNC StkId sol_f_close (sol_State *L, StkId level, TStatus status, Inteiro yy);
SOL_FUNC Vazio sol_f_unlinkupval (UpVal *uv);
SOL_FUNC lu_mem sol_f_protosize (Proto *p);
SOL_FUNC Vazio sol_f_freeproto (sol_State *L, Proto *f);
SOL_FUNC Imutável Caractere *sol_f_getlocalname (Imutável Proto *func, Inteiro local_number,
                                         Inteiro pc);


#FimSe
