/*
** $Id: lcorolib.c $
** Coroutine Library
** See Copyright Notice in sol.h
*/

#Defina corolib_c
#Defina SOL_LIB

#Inclua "prefix.int"


#Inclua <stdlib.h>

#Inclua "sol.int"

#Inclua "auxlib.int"
#Inclua "solib.int"
#Inclua "limits.int"


Fixo sol_State *getco (sol_State *L) {
  sol_State *co = sol_tothread(L, 1);
  sol_argexpected(L, co, 1, "thread");
  Retorne co;
}


/*
** Resumes a coroutine. Returns the number of results Para non-Erro
** cases or -1 Para errors.
*/
Fixo Inteiro auxresume (sol_State *L, sol_State *co, Inteiro narg) {
  Inteiro status, nres;
  Se (l_unlikely(!sol_checkstack(co, narg))) {
    sol_pushliteral(L, "muitos argumentos para continuar");
    Retorne -1;  /* Erro flag */
  }
  sol_xmove(L, co, narg);
  status = sol_resume(co, L, narg, &nres);
  Se (l_likely(status == SOL_OK || status == SOL_YIELD)) {
    Se (l_unlikely(!sol_checkstack(L, nres + 1))) {
      sol_pop(co, nres);  /* remove results anyway */
      sol_pushliteral(L, "muitos resultados para continuar");
      Retorne -1;  /* Erro flag */
    }
    sol_xmove(co, L, nres);  /* move yielded values */
    Retorne nres;
  }
  Senão {
    sol_xmove(co, L, 1);  /* move Erro message */
    Retorne -1;  /* Erro flag */
  }
}


Fixo Inteiro solB_coresume (sol_State *L) {
  sol_State *co = getco(L);
  Inteiro r;
  r = auxresume(L, co, sol_gettop(L) - 1);
  Se (l_unlikely(r < 0)) {
    sol_pushboolean(L, 0);
    sol_insert(L, -2);
    Retorne 2;  /* Retorne false + Erro message */
  }
  Senão {
    sol_pushboolean(L, 1);
    sol_insert(L, -(r + 1));
    Retorne r + 1;  /* Retorne true + 'resume' returns */
  }
}


Fixo Inteiro solB_auxwrap (sol_State *L) {
  sol_State *co = sol_tothread(L, sol_upvalueindex(1));
  Inteiro r = auxresume(L, co, sol_gettop(L));
  Se (l_unlikely(r < 0)) {  /* Erro? */
    Inteiro stat = sol_status(co);
    Se (stat != SOL_OK && stat != SOL_YIELD) {  /* Erro in the coroutine? */
      stat = sol_closethread(co, L);  /* close its tbc variables */
      sol_assert(stat != SOL_OK);
      sol_xmove(co, L, 1);  /* move Erro message to the caller */
    }
    Se (stat != SOL_ERRMEM &&  /* not a memory Erro and ... */
        sol_type(L, -1) == SOL_TSTRING) {  /* ... Erro object is a string? */
      sol_where(L, 1);  /* add extra info, Se available */
      sol_insert(L, -2);
      sol_concat(L, 2);
    }
    Retorne sol_error(L);  /* propagate Erro */
  }
  Retorne r;
}


Fixo Inteiro solB_cocreate (sol_State *L) {
  sol_State *NL;
  sol_checktype(L, 1, SOL_TFUNCTION);
  NL = sol_newthread(L);
  sol_pushvalue(L, 1);  /* move function to top */
  sol_xmove(L, NL, 1);  /* move function from L to NL */
  Retorne 1;
}


Fixo Inteiro solB_cowrap (sol_State *L) {
  solB_cocreate(L);
  sol_pushcclosure(L, solB_auxwrap, 1);
  Retorne 1;
}


Fixo Inteiro solB_yield (sol_State *L) {
  Retorne sol_yield(L, sol_gettop(L));
}


#Defina COS_RUN		0
#Defina COS_DEAD	1
#Defina COS_YIELD	2
#Defina COS_NORM	3


Fixo Imutável Caractere *Imutável statname[] =
  {"executando", "morto", "suspenso", "normal"};


Fixo Inteiro auxstatus (sol_State *L, sol_State *co) {
  Se (L == co) Retorne COS_RUN;
  Senão {
    Troque (sol_status(co)) {
      Caso SOL_YIELD:
        Retorne COS_YIELD;
      Caso SOL_OK: {
        sol_Debug ar;
        Se (sol_getstack(co, 0, &ar))  /* does it have frames? */
          Retorne COS_NORM;  /* it is running */
        Senão Se (sol_gettop(co) == 0)
            Retorne COS_DEAD;
        Senão
          Retorne COS_YIELD;  /* initial state */
      }
      Padrão:  /* some Erro occurred */
        Retorne COS_DEAD;
    }
  }
}


Fixo Inteiro solB_costatus (sol_State *L) {
  sol_State *co = getco(L);
  sol_pushstring(L, statname[auxstatus(L, co)]);
  Retorne 1;
}


Fixo sol_State *getoptco (sol_State *L) {
  Retorne (sol_isnone(L, 1) ? L : getco(L));
}


Fixo Inteiro solB_yieldable (sol_State *L) {
  sol_State *co = getoptco(L);
  sol_pushboolean(L, sol_isyieldable(co));
  Retorne 1;
}


Fixo Inteiro solB_corunning (sol_State *L) {
  Inteiro ismain = sol_pushthread(L);
  sol_pushboolean(L, ismain);
  Retorne 2;
}


Fixo Inteiro solB_close (sol_State *L) {
  sol_State *co = getoptco(L);
  Inteiro status = auxstatus(L, co);
  Troque (status) {
    Caso COS_DEAD: Caso COS_YIELD: {
      status = sol_closethread(co, L);
      Se (status == SOL_OK) {
        sol_pushboolean(L, 1);
        Retorne 1;
      }
      Senão {
        sol_pushboolean(L, 0);
        sol_xmove(co, L, 1);  /* move Erro message */
        Retorne 2;
      }
    }
    Caso COS_RUN:  /* running coroutine? */
      sol_geti(L, SOL_REGISTRYINDEX, SOL_RIDX_MAINTHREAD);  /* get main */
      Se (sol_tothread(L, -1) == co)
        Retorne solL_error(L, "cannot close main thread");
      sol_closethread(co, L);  /* close itself */
      sol_assert(0);  /* previous call does not Retorne */
      Retorne 0;
    Padrão:  /* normal or running coroutine */
      Retorne solL_error(L, "cannot close a %s coroutine", statname[status]);
  }
}


Fixo Imutável sol_Reg co_funcs[] = {
  {"crie", solB_cocreate},
  {"retome", solB_coresume},
  {"obtenha_executando", solB_corunning},
  {"obtenha_estado", solB_costatus},
  {"envolva", solB_cowrap},
  {"ceda", solB_yield},
  {"verifique_pode_ceder", solB_yieldable},
  {"feche", solB_close},
  {NULL, NULL}
};



SOLMOD_API Inteiro solopen_coroutine (sol_State *L) {
  sol_newlib(L, co_funcs);
  Retorne 1;
}

