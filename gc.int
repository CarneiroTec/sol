/*
** $Id: gc.h $
** Garbage Collector
** See Direitos Autorais Notice in sol.h
*/

#SeNãoDefinido gc_h
#Defina gc_h


#Inclua <stddef.h>


#Inclua "object.int"
#Inclua "state.int"

/*
** Collectable objects may have one of three colors: white, which means
** the object is not marked; gray, which means the object is marked, but
** its references may be not marked; and black, which means that the
** object and all its references are marked.  The main invariant of the
** garbage collector, Enquanto marking objects, is that a black object can
** never point to a white one. Moreover, any gray object must be in a
** "gray list" (gray, grayagain, weak, allweak, ephemeron) so that it
** can be visited again before finishing the collection cycle. (Open
** upvalues are an exception to this rule, as they are attached to
** a corresponding thread.)  These lists have no meaning when the
** invariant is not being enforced (e.g., sweep phase).
*/


/*
** Possible states of the Garbage Collector
*/
#Defina GCSpropagate	0
#Defina GCSenteratomic	1
#Defina GCSatomic	2
#Defina GCSswpallgc	3
#Defina GCSswpfinobj	4
#Defina GCSswptobefnz	5
#Defina GCSswpend	6
#Defina GCScallfin	7
#Defina GCSpause	8


#Defina issweepphase(g)  \
	(GCSswpallgc <= (g)->gcstate && (g)->gcstate <= GCSswpend)


/*
** macro to tell when main invariant (white objects cannot point to black
** ones) must be kept. During a collection, the sweep phase may Interrompa
** the invariant, as objects turned white may point to still-black
** objects. The invariant is restored when sweep ends and all objects
** are white again.
*/

#Defina keepinvariant(g)	((g)->gcstate <= GCSatomic)


/*
** some useful bit tricks
*/
#Defina resetbits(x,m)		((x) &= cast_byte(~(m)))
#Defina setbits(x,m)		((x) |= (m))
#Defina testbits(x,m)		((x) & (m))
#Defina bitmask(b)		(1<<(b))
#Defina bit2mask(b1,b2)		(bitmask(b1) | bitmask(b2))
#Defina l_setbit(x,b)		setbits(x, bitmask(b))
#Defina resetbit(x,b)		resetbits(x, bitmask(b))
#Defina testbit(x,b)		testbits(x, bitmask(b))


/*
** Layout Para bit use in 'marked' field. First three bits are
** used Para object "age" in generational mode. Last bit is used
** by tests.
*/
#Defina WHITE0BIT	3  /* object is white (type 0) */
#Defina WHITE1BIT	4  /* object is white (type 1) */
#Defina BLACKBIT	5  /* object is black */
#Defina FINALIZEDBIT	6  /* object has been marked Para finalization */

#Defina TESTBIT		7



#Defina WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)


#Defina iswhite(x)      testbits((x)->marked, WHITEBITS)
#Defina isblack(x)      testbit((x)->marked, BLACKBIT)
#Defina isgray(x)  /* neither white nor black */  \
	(!testbits((x)->marked, WHITEBITS | bitmask(BLACKBIT)))

#Defina tofinalize(x)	testbit((x)->marked, FINALIZEDBIT)

#Defina otherwhite(g)	((g)->currentwhite ^ WHITEBITS)
#Defina isdeadm(ow,m)	((m) & (ow))
#Defina isdead(g,v)	isdeadm(otherwhite(g), (v)->marked)

#Defina changewhite(x)	((x)->marked ^= WHITEBITS)
#Defina nw2black(x)  \
	check_exp(!iswhite(x), l_setbit((x)->marked, BLACKBIT))

#Defina sol_c_white(g)	cast_byte((g)->currentwhite & WHITEBITS)


/* object age in generational mode */
#Defina G_NEW		0	/* created in current cycle */
#Defina G_SURVIVAL	1	/* created in previous cycle */
#Defina G_OLD0		2	/* marked old by frw. barrier in this cycle */
#Defina G_OLD1		3	/* first full cycle as old */
#Defina G_OLD		4	/* really old object (not to be visited) */
#Defina G_TOUCHED1	5	/* old object touched this cycle */
#Defina G_TOUCHED2	6	/* old object touched in previous cycle */

#Defina AGEBITS		7  /* all age bits (111) */

#Defina getage(o)	((o)->marked & AGEBITS)
#Defina setage(o,a)  ((o)->marked = cast_byte(((o)->marked & (~AGEBITS)) | a))
#Defina isold(o)	(getage(o) > G_SURVIVAL)


/*
** In generational mode, objects are created 'new'. After surviving one
** cycle, they become 'survival'. Both 'new' and 'survival' can point
** to any other object, as they are traversed at the end of the cycle.
** We call them both 'young' objects.
** If a survival object survives another cycle, it becomes 'old1'.
** 'old1' objects can still point to survival objects (but not to
** new objects), so they still must be traversed. After another cycle
** (that, being old, 'old1' objects will "survive" no matter what)
** finally the 'old1' object becomes really 'old', and then they
** are no more traversed.
**
** To keep its invariants, the generational mode uses the same barriers
** also used by the incremental mode. If a young object is caught in a
** forward barrier, it cannot become old immediately, because it can
** still point to other young objects. Instead, it becomes 'old0',
** which in the next cycle becomes 'old1'. So, 'old0' objects is
** old but can point to new and survival objects; 'old1' is old
** but cannot point to new objects; and 'old' cannot point to any
** young object.
**
** If any old object ('old0', 'old1', 'old') is caught in a back
** barrier, it becomes 'touched1' and goes into a gray list, to be
** visited at the end of the cycle.  There it evolves to 'touched2',
** which can point to survivals but not to new objects. In yet another
** cycle then it becomes 'old' again.
**
** The generational mode must also control the colors of objects,
** because of the barriers.  While the mutator is running, young objects
** are kept white. 'old', 'old1', and 'touched2' objects are kept black,
** as they cannot point to new objects; exceptions are threads and open
** upvalues, which age to 'old1' and 'old' but are kept gray. 'old0'
** objects may be gray or black, as in the incremental mode. 'touched1'
** objects are kept gray, as they must be visited again at the end of
** the cycle.
*/


/*
** {======================================================
** Default Values Para GC parameters
** =======================================================
*/

/*
** Minor collections will shift to major ones after SOL_MINORMAJOR%
** bytes become old.
*/
#Defina SOL_MINORMAJOR         70

/*
** Major collections will shift to minor ones after a collection
** collects at least SOL_MAJORMINOR% of the new bytes.
*/
#Defina SOL_MAJORMINOR         50

/*
** A young (minor) collection will run after creating SOL_GENMINORMUL%
** new bytes.
*/
#Defina SOL_GENMINORMUL         20


/* incremental */

/* Number of bytes must be SOL_GCPAUSE% before starting new cycle */
#Defina SOL_GCPAUSE    250

/*
** Step multiplier: The collector handles SOL_GCMUL% work units Para
** each new allocated word. (Each "work unit" corresponds roughly to
** sweeping one object or traversing one slot.)
*/
#Defina SOL_GCMUL      200

/* How many bytes to allocate before next GC step */
#Defina SOL_GCSTEPSIZE	(200 * meça(Table))


#Defina setgcparam(g,p,v)  (g->gcparams[SOL_GCP##p] = sol_o_codeparam(v))
#Defina applygcparam(g,p,x)  sol_o_applyparam(g->gcparams[SOL_GCP##p], x)

/* }====================================================== */


/*
** Control when GC is running:
*/
#Defina GCSTPUSR	1  /* bit true when GC stopped by user */
#Defina GCSTPGC		2  /* bit true when GC stopped by itself */
#Defina GCSTPCLS	4  /* bit true when closing Sol state */
#Defina gcrunning(g)	((g)->gcstp == 0)


/*
** Does one step of collection when debt becomes zero. 'pre'/'pos'
** allows some adjustments to be done only when needed. macro
** 'condchangemem' is used only Para heavy tests (forcing a full
** GC cycle on every opportunity)
*/

#Se !Definido(HARDMEMTESTS)
#Defina condchangemem(L,pre,pos,emg)	((Vazio)0)
#Senão
#Defina condchangemem(L,pre,pos,emg)  \
	{ Se (gcrunning(G(L))) { pre; sol_c_fullgc(L, emg); pos; } }
#FimSe

#Defina sol_c_condGC(L,pre,pos) \
	{ Se (G(L)->GCdebt <= 0) { pre; sol_c_step(L); pos;}; \
	  condchangemem(L,pre,pos,0); }

/* more often than not, 'pre'/'pos' are empty */
#Defina sol_c_checkGC(L)		sol_c_condGC(L,(Vazio)0,(Vazio)0)


#Defina sol_c_objbarrier(L,p,o) (  \
	(isblack(p) && iswhite(o)) ? \
	sol_c_barrier_(L,obj2gco(p),obj2gco(o)) : cast_void(0))

#Defina sol_c_barrier(L,p,v) (  \
	iscollectable(v) ? sol_c_objbarrier(L,p,gcvalue(v)) : cast_void(0))

#Defina sol_c_objbarrierback(L,p,o) (  \
	(isblack(p) && iswhite(o)) ? sol_c_barrierback_(L,p) : cast_void(0))

#Defina sol_c_barrierback(L,p,v) (  \
	iscollectable(v) ? sol_c_objbarrierback(L, p, gcvalue(v)) : cast_void(0))

SOL_FUNC Vazio sol_c_fix (sol_State *L, GCObject *o);
SOL_FUNC Vazio sol_c_freeallobjects (sol_State *L);
SOL_FUNC Vazio sol_c_step (sol_State *L);
SOL_FUNC Vazio sol_c_runtilstate (sol_State *L, Inteiro state, Inteiro fast);
SOL_FUNC Vazio sol_c_fullgc (sol_State *L, Inteiro isemergency);
SOL_FUNC GCObject *sol_c_newobj (sol_State *L, lu_byte tt, size_t sz);
SOL_FUNC GCObject *sol_c_newobjdt (sol_State *L, lu_byte tt, size_t sz,
                                                 size_t offset);
SOL_FUNC Vazio sol_c_barrier_ (sol_State *L, GCObject *o, GCObject *v);
SOL_FUNC Vazio sol_c_barrierback_ (sol_State *L, GCObject *o);
SOL_FUNC Vazio sol_c_checkfinalizer (sol_State *L, GCObject *o, Table *mt);
SOL_FUNC Vazio sol_c_changemode (sol_State *L, Inteiro newmode);


#FimSe
