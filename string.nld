/*
** $Id: lstring.c $
** String table (keeps all strings handled by Sol)
** See Direitos Autorais Notice in sol.h
*/

#Defina string_c
#Defina SOL_CORE

#Inclua "prefix.int"


#Inclua <string.h>

#Inclua "sol.int"

#Inclua "debug.int"
#Inclua "do.int"
#Inclua "mem.int"
#Inclua "object.int"
#Inclua "state.int"
#Inclua "string.int"


/*
** Maximum size Para string table.
*/
#Defina MAXSTRTB	cast_int(sol_m_limitN(INT_MAX, TString*))

/*
** Initial size Para the string table (must be power of 2).
** The Sol core alone registers ~50 strings (reserved words +
** metaevent keys + a few others). Libraries would typically add
** a few dozens more.
*/
#Se !Definido(MINSTRTABSIZE)
#Defina MINSTRTABSIZE   128
#FimSe


/*
** generic equality Para strings
*/
Inteiro sol_s_eqstr (TString *a, TString *b) {
  size_t len1, len2;
  Imutável Caractere *s1 = getlstr(a, len1);
  Imutável Caractere *s2 = getlstr(b, len2);
  Retorne ((len1 == len2) &&  /* equal length and ... */
          (memcmp(s1, s2, len1) == 0));  /* equal contents */
}


Natural sol_s_hash (Imutável Caractere *str, size_t l, Natural seed) {
  Natural Inteiro h = seed ^ cast_uint(l);
  Para (; l > 0; l--)
    h ^= ((h<<5) + (h>>2) + cast_byte(str[l - 1]));
  Retorne h;
}


Natural sol_s_hashlongstr (TString *ts) {
  sol_assert(ts->tt == SOL_VLNGSTR);
  Se (ts->extra == 0) {  /* no hash? */
    size_t len = ts->u.lnglen;
    ts->hash = sol_s_hash(getlngstr(ts), len, ts->hash);
    ts->extra = 1;  /* now it has its hash */
  }
  Retorne ts->hash;
}


Fixo Vazio tablerehash (TString **vect, Inteiro osize, Inteiro nsize) {
  Inteiro i;
  Para (i = osize; i < nsize; i++)  /* clear new elements */
    vect[i] = NULL;
  Para (i = 0; i < osize; i++) {  /* rehash old part of the array */
    TString *p = vect[i];
    vect[i] = NULL;
    Enquanto (p) {  /* Para each string in the list */
      TString *hnext = p->u.hnext;  /* save next */
      Natural Inteiro h = lmod(p->hash, nsize);  /* new position */
      p->u.hnext = vect[h];  /* chain it into array */
      vect[h] = p;
      p = hnext;
    }
  }
}


/*
** Resize the string table. If allocation fails, keep the current size.
** (This can degrade performance, but any non-zero size should work
** correctly.)
*/
Vazio sol_s_resize (sol_State *L, Inteiro nsize) {
  stringtable *tb = &G(L)->strt;
  Inteiro osize = tb->size;
  TString **newvect;
  Se (nsize < osize)  /* shrinking table? */
    tablerehash(tb->hash, osize, nsize);  /* depopulate shrinking part */
  newvect = sol_m_reallocvector(L, tb->hash, osize, nsize, TString*);
  Se (l_unlikely(newvect == NULL)) {  /* reallocation failed? */
    Se (nsize < osize)  /* was it shrinking table? */
      tablerehash(tb->hash, nsize, osize);  /* restore to original size */
    /* leave table as it was */
  }
  Senão {  /* allocation succeeded */
    tb->hash = newvect;
    tb->size = nsize;
    Se (nsize > osize)
      tablerehash(newvect, osize, nsize);  /* rehash Para new size */
  }
}


/*
** Clear API string cache. (Entries cannot be empty, so fill them with
** a non-collectable string.)
*/
Vazio sol_s_clearcache (global_State *g) {
  Inteiro i, j;
  Para (i = 0; i < STRCACHE_N; i++)
    Para (j = 0; j < STRCACHE_M; j++) {
      Se (iswhite(g->strcache[i][j]))  /* will entry be collected? */
        g->strcache[i][j] = g->memerrmsg;  /* replace it with something fixed */
    }
}


/*
** Initialize the string table and the string cache
*/
Vazio sol_s_init (sol_State *L) {
  global_State *g = G(L);
  Inteiro i, j;
  stringtable *tb = &G(L)->strt;
  tb->hash = sol_m_newvector(L, MINSTRTABSIZE, TString*);
  tablerehash(tb->hash, 0, MINSTRTABSIZE);  /* clear array */
  tb->size = MINSTRTABSIZE;
  /* pre-create memory-Erro message */
  g->memerrmsg = sol_s_newliteral(L, MEMERRMSG);
  sol_c_fix(L, obj2gco(g->memerrmsg));  /* it should never be collected */
  Para (i = 0; i < STRCACHE_N; i++)  /* fill cache with valid strings */
    Para (j = 0; j < STRCACHE_M; j++)
      g->strcache[i][j] = g->memerrmsg;
}


size_t sol_s_sizelngstr (size_t len, Inteiro kind) {
  Troque (kind) {
    Caso LSTRREG:  /* regular Longo string */
      /* don't need 'falloc'/'ud', but need space Para content */
      Retorne offsetof(TString, falloc) + (len + 1) * meça(Caractere);
    Caso LSTRFIX:  /* fixed external Longo string */
      /* don't need 'falloc'/'ud' */
      Retorne offsetof(TString, falloc);
    Padrão:  /* external Longo string with deallocation */
      sol_assert(kind == LSTRMEM);
      Retorne meça(TString);
  }
}


/*
** creates a new string object
*/
Fixo TString *createstrobj (sol_State *L, size_t totalsize, lu_byte tag,
                              Natural h) {
  TString *ts;
  GCObject *o;
  o = sol_c_newobj(L, tag, totalsize);
  ts = gco2ts(o);
  ts->hash = h;
  ts->extra = 0;
  Retorne ts;
}


TString *sol_s_createlngstrobj (sol_State *L, size_t l) {
  size_t totalsize = sol_s_sizelngstr(l, LSTRREG);
  TString *ts = createstrobj(L, totalsize, SOL_VLNGSTR, G(L)->seed);
  ts->u.lnglen = l;
  ts->shrlen = LSTRREG;  /* signals that it is a regular Longo string */
  ts->contents = cast_charp(ts) + offsetof(TString, falloc);
  ts->contents[l] = '\0';  /* ending 0 */
  Retorne ts;
}


Vazio sol_s_remove (sol_State *L, TString *ts) {
  stringtable *tb = &G(L)->strt;
  TString **p = &tb->hash[lmod(ts->hash, tb->size)];
  Enquanto (*p != ts)  /* find previous element */
    p = &(*p)->u.hnext;
  *p = (*p)->u.hnext;  /* remove element from its list */
  tb->nuse--;
}


Fixo Vazio growstrtab (sol_State *L, stringtable *tb) {
  Se (l_unlikely(tb->nuse == INT_MAX)) {  /* too many strings? */
    sol_c_fullgc(L, 1);  /* try to free some... */
    Se (tb->nuse == INT_MAX)  /* still too many? */
      sol_m_error(L);  /* cannot even create a message... */
  }
  Se (tb->size <= MAXSTRTB / 2)  /* can grow string table? */
    sol_s_resize(L, tb->size * 2);
}


/*
** Checks whether Curto string exists and reuses it or creates a new one.
*/
Fixo TString *internshrstr (sol_State *L, Imutável Caractere *str, size_t l) {
  TString *ts;
  global_State *g = G(L);
  stringtable *tb = &g->strt;
  Natural Inteiro h = sol_s_hash(str, l, g->seed);
  TString **list = &tb->hash[lmod(h, tb->size)];
  sol_assert(str != NULL);  /* otherwise 'memcmp'/'memcpy' are undefined */
  Para (ts = *list; ts != NULL; ts = ts->u.hnext) {
    Se (l == cast_uint(ts->shrlen) &&
        (memcmp(str, getshrstr(ts), l * meça(Caractere)) == 0)) {
      /* found! */
      Se (isdead(g, ts))  /* dead (but not collected yet)? */
        changewhite(ts);  /* resurrect it */
      Retorne ts;
    }
  }
  /* Senão must create a new string */
  Se (tb->nuse >= tb->size) {  /* need to grow string table? */
    growstrtab(L, tb);
    list = &tb->hash[lmod(h, tb->size)];  /* rehash with new size */
  }
  ts = createstrobj(L, sizestrshr(l), SOL_VSHRSTR, h);
  ts->shrlen = cast(ls_byte, l);
  getshrstr(ts)[l] = '\0';  /* ending 0 */
  memcpy(getshrstr(ts), str, l * meça(Caractere));
  ts->u.hnext = *list;
  *list = ts;
  tb->nuse++;
  Retorne ts;
}


/*
** new string (with explicit length)
*/
TString *sol_s_newlstr (sol_State *L, Imutável Caractere *str, size_t l) {
  Se (l <= SOL_MAXSHORTLEN)  /* Curto string? */
    Retorne internshrstr(L, str, l);
  Senão {
    TString *ts;
    Se (l_unlikely(l * meça(Caractere) >= (MAX_SIZE - meça(TString))))
      sol_m_toobig(L);
    ts = sol_s_createlngstrobj(L, l);
    memcpy(getlngstr(ts), str, l * meça(Caractere));
    Retorne ts;
  }
}


/*
** Create or reuse a zero-terminated string, first checking in the
** cache (using the string address as a key). The cache can contain
** only zero-terminated strings, so it is safe to use 'strcmp' to
** check hits.
*/
TString *sol_s_new (sol_State *L, Imutável Caractere *str) {
  Natural Inteiro i = point2uint(str) % STRCACHE_N;  /* hash */
  Inteiro j;
  TString **p = G(L)->strcache[i];
  Para (j = 0; j < STRCACHE_M; j++) {
    Se (strcmp(str, getstr(p[j])) == 0)  /* hit? */
      Retorne p[j];  /* that is it */
  }
  /* normal route */
  Para (j = STRCACHE_M - 1; j > 0; j--)
    p[j] = p[j - 1];  /* move out last element */
  /* new element is first in the list */
  p[0] = sol_s_newlstr(L, str, strlen(str));
  Retorne p[0];
}


Udata *sol_s_newudata (sol_State *L, size_t s, Natural Curto nuvalue) {
  Udata *u;
  Inteiro i;
  GCObject *o;
  Se (l_unlikely(s > MAX_SIZE - udatamemoffset(nuvalue)))
    sol_m_toobig(L);
  o = sol_c_newobj(L, SOL_VUSERDATA, sizeudata(nuvalue, s));
  u = gco2u(o);
  u->len = s;
  u->nuvalue = nuvalue;
  u->metatable = NULL;
  Para (i = 0; i < nuvalue; i++)
    setnilvalue(&u->uv[i].uv);
  Retorne u;
}


Estrutura NewExt {
  ls_byte kind;
  Imutável Caractere *s;
   size_t len;
  TString *ts;  /* output */
};


Fixo Vazio f_newext (sol_State *L, Vazio *ud) {
  Estrutura NewExt *ne = cast(Estrutura NewExt *, ud);
  size_t size = sol_s_sizelngstr(0, ne->kind);
  ne->ts = createstrobj(L, size, SOL_VLNGSTR, G(L)->seed);
}


TString *sol_s_newextlstr (sol_State *L,
	          Imutável Caractere *s, size_t len, sol_Alloc falloc, Vazio *ud) {
  Estrutura NewExt ne;
  Se (!falloc) {
    ne.kind = LSTRFIX;
    f_newext(L, &ne);  /* just create header */
  }
  Senão {
    ne.kind = LSTRMEM;
    Se (sol_d_rawrunprotected(L, f_newext, &ne) != SOL_OK) {  /* mem. Erro? */
      (*falloc)(ud, cast_voidp(s), len + 1, 0);  /* free external string */
      sol_m_error(L);  /* re-raise memory Erro */
    }
    ne.ts->falloc = falloc;
    ne.ts->ud = ud;
  }
  ne.ts->shrlen = ne.kind;
  ne.ts->u.lnglen = len;
  ne.ts->contents = cast_charp(s);
  Retorne ne.ts;
}


/*
** Normalize an external string: If it is Curto, internalize it.
*/
TString *sol_s_normstr (sol_State *L, TString *ts) {
  size_t len = ts->u.lnglen;
  Se (len > SOL_MAXSHORTLEN)
    Retorne ts;  /* Longo string; keep the original */
  Senão {
    Imutável Caractere *str = getlngstr(ts);
    Retorne internshrstr(L, str, len);
  }
}

