/*
** teste_lsp_utils.ctec - Testes das funções utilitárias do LSP
** 
** Funções testadas:
** - lsp_skip_whitespace
** - lsp_skip_comment
** - lsp_extract_name
** - lsp_check_keyword
** - lsp_peek_keyword
** - lsp_get_cursor_context
** - lsp_parse_table
**
** Cada função: ESPERADO, NAO_ESPERADO, NULO, ESTOURO
*/

#Defina teste_utils_c
#Defina SOL_LIB

#Inclua "prefix.int"
#Inclua <stdio.h>
#Inclua <stdlib.h>
#Inclua <string.h>
#Inclua "sol.int"
#Inclua "auxlib.int"
#Inclua "lsp.int"

#Defina TESTE_OK 0
#Defina TESTE_FALHA 1
#Defina MAX_ERRO 512

Fixo Caractere ultimo_erro[MAX_ERRO] = "";

Fixo Vazio registra_erro(Imutável Caractere *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vsnprintf(ultimo_erro, MAX_ERRO, fmt, args);
    va_end(args);
}

Fixo Vazio imprime(Imutável Caractere *nome, Imutável Caractere *cenario, Inteiro ok) {
    fprintf(stderr, "[%s][%s] %s%s\n", nome, cenario, ok ? "OK" : "FALHA", ok ? "" : ultimo_erro);
}

/* ============================================================
** lsp_skip_whitespace
** ============================================================ */

Inteiro teste_whitespace_esperado() {
    Imutável Caractere *texto = "   \t\n  abc";
    Imutável Caractere *p = texto;
    Inteiro linha = 0;
    
    lsp_skip_whitespace(&p, &linha);
    
    /* Deve parar em 'a' */
    Se (*p != 'a') {
        registra_erro(": parou em '%c', esperava 'a'", *p);
        Retorne TESTE_FALHA;
    }
    
    /* Deve ter contado 1 newline */
    Se (linha != 1) {
        registra_erro(": linha=%d, esperava 1", linha);
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_whitespace_nao_esperado() {
    /* Texto sem whitespace no início */
    Imutável Caractere *texto = "abc";
    Imutável Caractere *p = texto;
    Inteiro linha = 0;
    
    lsp_skip_whitespace(&p, &linha);
    
    /* Não deve mover */
    Se (p != texto) {
        registra_erro(": moveu quando não deveria");
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_whitespace_nulo() {
    /* String vazia */
    Imutável Caractere *texto = "";
    Imutável Caractere *p = texto;
    Inteiro linha = 0;
    
    lsp_skip_whitespace(&p, &linha);
    
    /* Deve parar no \0 */
    Se (*p != '\0') {
        registra_erro(": não parou no fim");
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_whitespace_estouro() {
    /* Muitas newlines */
    Caractere texto[1024];
    memset(texto, '\n', 1000);
    texto[1000] = 'x';
    texto[1001] = '\0';
    
    Imutável Caractere *p = texto;
    Inteiro linha = 0;
    
    lsp_skip_whitespace(&p, &linha);
    
    Se (*p != 'x') {
        registra_erro(": não chegou ao 'x'");
        Retorne TESTE_FALHA;
    }
    
    Se (linha != 1000) {
        registra_erro(": linha=%d, esperava 1000", linha);
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

/* ============================================================
** lsp_skip_comment
** ============================================================ */

Inteiro teste_comment_esperado() {
    Imutável Caractere *texto = "-- comentário\nabc";
    Imutável Caractere *p = texto;
    
    lsp_skip_comment(&p);
    
    /* Deve parar no \n */
    Se (*p != '\n') {
        registra_erro(": parou em '%c', esperava newline", *p);
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_comment_nao_esperado() {
    /* Não é comentário */
    Imutável Caractere *texto = "abc -- depois";
    Imutável Caractere *p = texto;
    
    lsp_skip_comment(&p);
    
    /* Não deve mover (não começa com --) */
    Se (p != texto) {
        registra_erro(": moveu quando não deveria");
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_comment_nulo() {
    /* Comentário vazio */
    Imutável Caractere *texto = "--\n";
    Imutável Caractere *p = texto;
    
    lsp_skip_comment(&p);
    
    Se (*p != '\n') {
        registra_erro(": não chegou ao newline");
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_comment_estouro() {
    /* Comentário muito longo */
    Caractere texto[4096];
    texto[0] = '-';
    texto[1] = '-';
    memset(texto + 2, 'x', 4000);
    texto[4002] = '\n';
    texto[4003] = 'y';
    texto[4004] = '\0';
    
    Imutável Caractere *p = texto;
    lsp_skip_comment(&p);
    
    Se (*p != '\n') {
        registra_erro(": não chegou ao fim do comentário");
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

/* ============================================================
** lsp_extract_name
** ============================================================ */

Inteiro teste_extract_esperado() {
    Imutável Caractere *texto = "variável_123 = 1";
    Imutável Caractere *p = texto;
    Caractere nome[256];
    
    Inteiro ok = lsp_extract_name(&p, nome, 256);
    
    Se (!ok) {
        registra_erro(": falhou ao extrair");
        Retorne TESTE_FALHA;
    }
    
    Se (strcmp(nome, "variável_123") != 0) {
        registra_erro(": extraiu '%s', esperava 'variável_123'", nome);
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_extract_nao_esperado() {
    /* Começa com número (não é identificador válido) */
    Imutável Caractere *texto = "123abc";
    Imutável Caractere *p = texto;
    Caractere nome[256];
    
    Inteiro ok = lsp_extract_name(&p, nome, 256);
    
    /* Deve extrair "123abc" (números são válidos em identifiers após início)
       MAS a função pode ter comportamento diferente */
    /* Não crashar é o importante */
    
    Retorne TESTE_OK;
}

Inteiro teste_extract_nulo() {
    /* String vazia */
    Imutável Caractere *texto = "";
    Imutável Caractere *p = texto;
    Caractere nome[256];
    
    Inteiro ok = lsp_extract_name(&p, nome, 256);
    
    /* Deve falhar graciosamente */
    Se (ok && nome[0] != '\0') {
        registra_erro(": extraiu algo de string vazia");
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_extract_estouro() {
    /* Nome muito longo */
    Caractere texto[1024];
    memset(texto, 'a', 1000);
    texto[1000] = '\0';
    
    Imutável Caractere *p = texto;
    Caractere nome[64];  /* Buffer pequeno */
    
    Inteiro ok = lsp_extract_name(&p, nome, 64);
    
    /* Não deve crashar - pode truncar ou falhar */
    
    Retorne TESTE_OK;
}

/* ============================================================
** lsp_check_keyword / lsp_peek_keyword
** ============================================================ */

Inteiro teste_keyword_esperado() {
    Imutável Caractere *texto = "local x = 1";
    Imutável Caractere *p = texto;
    
    /* Deve reconhecer 'local' */
    Se (!lsp_check_keyword(&p, "local")) {
        registra_erro(": não reconheceu 'local'");
        Retorne TESTE_FALHA;
    }
    
    /* Ponteiro deve ter avançado */
    Se (*p != ' ') {
        registra_erro(": ponteiro não avançou");
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_keyword_nao_esperado() {
    Imutável Caractere *texto = "localmente = 1";
    Imutável Caractere *p = texto;
    
    /* Não deve reconhecer 'local' (é prefixo de 'localmente') */
    Se (lsp_check_keyword(&p, "local")) {
        registra_erro(": reconheceu 'local' em 'localmente'");
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_keyword_nulo() {
    Imutável Caractere *texto = "";
    Imutável Caractere *p = texto;
    
    /* Não deve crashar */
    Se (lsp_check_keyword(&p, "local")) {
        registra_erro(": reconheceu keyword em string vazia");
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_keyword_estouro() {
    /* Keyword muito longa (não existe, mas não deve crashar) */
    Caractere kw[256];
    memset(kw, 'a', 255);
    kw[255] = '\0';
    
    Imutável Caractere *texto = "abc";
    Imutável Caractere *p = texto;
    
    /* Não deve crashar */
    lsp_check_keyword(&p, kw);
    
    Retorne TESTE_OK;
}

/* ============================================================
** lsp_get_cursor_context
** ============================================================ */

Inteiro teste_cursor_esperado() {
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    
    Imutável Caractere *codigo = "local obj = {}\nobj.campo = 1";
    LSPDocument *doc = lsp_add_document(lsp, "file:///cursor.sol", codigo);
    
    Caractere word[256], table[64];
    Inteiro isDot = 0;
    
    /* Cursor após 'obj.' na linha 1, coluna 4 */
    lsp_get_cursor_context(doc, 1, 4, word, 256, &isDot, table, 64);
    
    /* Deve detectar contexto de tabela */
    Se (!isDot) {
        registra_erro(": não detectou contexto de tabela");
        lsp_shutdown(lsp); sol_close(L);
        Retorne TESTE_FALHA;
    }
    
    Se (strcmp(table, "obj") != 0) {
        registra_erro(": table='%s', esperava 'obj'", table);
        lsp_shutdown(lsp); sol_close(L);
        Retorne TESTE_FALHA;
    }
    
    lsp_shutdown(lsp); sol_close(L);
    Retorne TESTE_OK;
}

Inteiro teste_cursor_nao_esperado() {
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    
    Imutável Caractere *codigo = "local x = 1";
    LSPDocument *doc = lsp_add_document(lsp, "file:///cursor2.sol", codigo);
    
    Caractere word[256], table[64];
    Inteiro isDot = 0;
    
    /* Cursor no meio de 'local' */
    lsp_get_cursor_context(doc, 0, 3, word, 256, &isDot, table, 64);
    
    /* Não deve ser contexto de tabela */
    Se (isDot) {
        registra_erro(": detectou tabela incorretamente");
        lsp_shutdown(lsp); sol_close(L);
        Retorne TESTE_FALHA;
    }
    
    lsp_shutdown(lsp); sol_close(L);
    Retorne TESTE_OK;
}

Inteiro teste_cursor_nulo() {
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    
    Caractere word[256], table[64];
    Inteiro isDot = 0;
    
    /* Documento NULL */
    lsp_get_cursor_context(NULL, 0, 0, word, 256, &isDot, table, 64);
    
    /* Não deve crashar */
    
    lsp_shutdown(lsp); sol_close(L);
    Retorne TESTE_OK;
}

Inteiro teste_cursor_estouro() {
    sol_State *L = solL_newstate();
    LSPState *lsp = lsp_init(L);
    
    /* Linha fora do documento */
    Imutável Caractere *codigo = "local x = 1";
    LSPDocument *doc = lsp_add_document(lsp, "file:///cursor3.sol", codigo);
    
    Caractere word[256], table[64];
    Inteiro isDot = 0;
    
    /* Linha 1000 não existe */
    lsp_get_cursor_context(doc, 1000, 0, word, 256, &isDot, table, 64);
    
    /* Não deve crashar */
    
    lsp_shutdown(lsp); sol_close(L);
    Retorne TESTE_OK;
}

/* ============================================================
** lsp_strdup
** ============================================================ */

Inteiro teste_strdup_esperado() {
    Imutável Caractere *original = "teste de cópia";
    Caractere *copia = lsp_strdup(original);
    
    Se (!copia) {
        registra_erro(": retornou NULL");
        Retorne TESTE_FALHA;
    }
    
    Se (strcmp(copia, original) != 0) {
        registra_erro(": cópia diferente do original");
        free(copia);
        Retorne TESTE_FALHA;
    }
    
    Se (copia == original) {
        registra_erro(": retornou mesmo ponteiro");
        Retorne TESTE_FALHA;
    }
    
    free(copia);
    Retorne TESTE_OK;
}

Inteiro teste_strdup_nao_esperado() {
    /* String com caracteres especiais */
    Imutável Caractere *original = "açúcar ñ 日本語";
    Caractere *copia = lsp_strdup(original);
    
    Se (!copia) {
        registra_erro(": retornou NULL para unicode");
        Retorne TESTE_FALHA;
    }
    
    Se (strcmp(copia, original) != 0) {
        registra_erro(": unicode não copiado corretamente");
        free(copia);
        Retorne TESTE_FALHA;
    }
    
    free(copia);
    Retorne TESTE_OK;
}

Inteiro teste_strdup_nulo() {
    /* NULL input */
    Caractere *copia = lsp_strdup(NULL);
    
    Se (copia != NULL) {
        registra_erro(": deveria retornar NULL para input NULL");
        free(copia);
        Retorne TESTE_FALHA;
    }
    
    Retorne TESTE_OK;
}

Inteiro teste_strdup_estouro() {
    /* String muito longa */
    Caractere original[65536];
    memset(original, 'x', 65535);
    original[65535] = '\0';
    
    Caractere *copia = lsp_strdup(original);
    
    Se (!copia) {
        /* Falhou por memória - aceitável */
        Retorne TESTE_OK;
    }
    
    Se (strlen(copia) != 65535) {
        registra_erro(": tamanho incorreto");
        free(copia);
        Retorne TESTE_FALHA;
    }
    
    free(copia);
    Retorne TESTE_OK;
}

/* ============================================================
** Função Principal
** ============================================================ */

Inteiro Início() {
    fprintf(stderr, "\n=== TESTES LSP: FUNÇÕES UTILITÁRIAS ===\n\n");
    
    Inteiro total = 0, passou = 0;
    
    #Defina EXECUTA(nome, cenario, func) \
        total++; \
        Se (func() == TESTE_OK) { passou++; imprime(nome, cenario, 1); } \
        Senão { imprime(nome, cenario, 0); }
    
    fprintf(stderr, "--- lsp_skip_whitespace ---\n");
    EXECUTA("whitespace", "ESPERADO", teste_whitespace_esperado);
    EXECUTA("whitespace", "NAO_ESPERADO", teste_whitespace_nao_esperado);
    EXECUTA("whitespace", "NULO", teste_whitespace_nulo);
    EXECUTA("whitespace", "ESTOURO", teste_whitespace_estouro);
    
    fprintf(stderr, "\n--- lsp_skip_comment ---\n");
    EXECUTA("comment", "ESPERADO", teste_comment_esperado);
    EXECUTA("comment", "NAO_ESPERADO", teste_comment_nao_esperado);
    EXECUTA("comment", "NULO", teste_comment_nulo);
    EXECUTA("comment", "ESTOURO", teste_comment_estouro);
    
    fprintf(stderr, "\n--- lsp_extract_name ---\n");
    EXECUTA("extract", "ESPERADO", teste_extract_esperado);
    EXECUTA("extract", "NAO_ESPERADO", teste_extract_nao_esperado);
    EXECUTA("extract", "NULO", teste_extract_nulo);
    EXECUTA("extract", "ESTOURO", teste_extract_estouro);
    
    fprintf(stderr, "\n--- lsp_check_keyword ---\n");
    EXECUTA("keyword", "ESPERADO", teste_keyword_esperado);
    EXECUTA("keyword", "NAO_ESPERADO", teste_keyword_nao_esperado);
    EXECUTA("keyword", "NULO", teste_keyword_nulo);
    EXECUTA("keyword", "ESTOURO", teste_keyword_estouro);
    
    fprintf(stderr, "\n--- lsp_get_cursor_context ---\n");
    EXECUTA("cursor", "ESPERADO", teste_cursor_esperado);
    EXECUTA("cursor", "NAO_ESPERADO", teste_cursor_nao_esperado);
    EXECUTA("cursor", "NULO", teste_cursor_nulo);
    EXECUTA("cursor", "ESTOURO", teste_cursor_estouro);
    
    fprintf(stderr, "\n--- lsp_strdup ---\n");
    EXECUTA("strdup", "ESPERADO", teste_strdup_esperado);
    EXECUTA("strdup", "NAO_ESPERADO", teste_strdup_nao_esperado);
    EXECUTA("strdup", "NULO", teste_strdup_nulo);
    EXECUTA("strdup", "ESTOURO", teste_strdup_estouro);
    
    fprintf(stderr, "\n=== RESULTADO: %d/%d testes passaram ===\n", passou, total);
    
    Retorne (passou == total) ? 0 : 1;
}
