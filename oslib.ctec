/*
** $Id: loslib.c $
** Standard Operating System library
** See Copyright Notice in sol.h
*/

#Defina oslib_c
#Defina SOL_LIB

#Inclua "prefix.int"


#Inclua <errno.h>
#Inclua <locale.h>
#Inclua <stdlib.h>
#Inclua <string.h>
#Inclua <time.h>

/* Para criação de diretórios */
#Se Definido(_WIN32)
#Inclua <direct.h>
#Defina os_mkdir(path) _mkdir(path)
#Senão
#Inclua <sys/stat.h>
#Defina os_mkdir(path) mkdir(path, 0755)
#FimSe

#Inclua "sol.int"

#Inclua "auxlib.int"
#Inclua "solib.int"
#Inclua "limits.int"


/*
** {==================================================================
** List of valid conversion specifiers Para the 'strftime' function;
** options are grouped by length; group of length 2 start with '||'.
** ===================================================================
*/
#Se !Definido(SOL_STRFTIMEOPTIONS)	/* { */

#Se Definido(SOL_USE_WINDOWS)
#Defina SOL_STRFTIMEOPTIONS  "aAbBcdHIjmMpSUwWxXyYzZ%" \
    "||" "#c#x#d#H#I#j#m#M#S#U#w#W#y#Y"  /* two-Caractere options */
#Exceto Definido(SOL_USE_C89)  /* C89 (only 1-Caractere options) */
#Defina SOL_STRFTIMEOPTIONS  "aAbBcdHIjmMpSUwWxXyYZ%"
#Senão  /* C99 specification */
#Defina SOL_STRFTIMEOPTIONS  "aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%" \
    "||" "EcECExEXEyEY" "OdOeOHOIOmOMOSOuOUOVOwOWOy"  /* two-Caractere options */
#FimSe

#FimSe					/* } */
/* }================================================================== */


/*
** {==================================================================
** Configuration Para time-related stuff
** ===================================================================
*/

/*
** type to represent time_t in Sol
*/
#Se !Definido(SOL_NUMTIME)	/* { */

#Defina l_timet			sol_Integer
#Defina l_pushtime(L,t)		sol_pushinteger(L,(sol_Integer)(t))
#Defina l_gettime(L,arg)	sol_checkinteger(L, arg)

#Senão				/* }{ */

#Defina l_timet			sol_Number
#Defina l_pushtime(L,t)		sol_pushnumber(L,(sol_Number)(t))
#Defina l_gettime(L,arg)	sol_checknumber(L, arg)

#FimSe				/* } */


#Se !Definido(l_gmtime)		/* { */
/*
** By Padrão, Sol uses gmtime/localtime, except when POSIX is available,
** where it uses gmtime_r/localtime_r
*/

#Se Definido(SOL_USE_POSIX)	/* { */

#Defina l_gmtime(t,r)		gmtime_r(t,r)
#Defina l_localtime(t,r)	localtime_r(t,r)

#Senão				/* }{ */

/* ISO C definitions */
#Defina l_gmtime(t,r)		((Vazio)(r)->tm_sec, gmtime(t))
#Defina l_localtime(t,r)	((Vazio)(r)->tm_sec, localtime(t))

#FimSe				/* } */

#FimSe				/* } */

/* }================================================================== */


/*
** {==================================================================
** Configuration Para 'tmpnam':
** By Padrão, Sol uses tmpnam except when POSIX is available, where
** it uses mkstemp.
** ===================================================================
*/
#Se !Definido(sol_tmpnam)	/* { */

#Se Definido(SOL_USE_POSIX)	/* { */

#Inclua <unistd.int>

#Defina SOL_TMPNAMBUFSIZE	32

#Se !Definido(SOL_TMPNAMTEMPLATE)
#Defina SOL_TMPNAMTEMPLATE	"/tmp/sol_XXXXXX"
#FimSe

#Defina sol_tmpnam(b,e) { \
        strcpy(b, SOL_TMPNAMTEMPLATE); \
        e = mkstemp(b); \
        Se (e != -1) close(e); \
        e = (e == -1); }

#Senão				/* }{ */

/* ISO C definitions */
#Defina SOL_TMPNAMBUFSIZE	L_tmpnam
#Defina sol_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }

#FimSe				/* } */

#FimSe				/* } */
/* }================================================================== */


#Se !Definido(l_system)
#Se Definido(SOL_USE_IOS)
/* Despite claiming to be ISO C, iOS does not implement 'system'. */
#Defina l_system(cmd) ((cmd) == NULL ? 0 : -1)
#Senão
#Defina l_system(cmd)	system(cmd)  /* Padrão definition */
#FimSe
#FimSe


Fixo Inteiro os_execute (sol_State *L) {
  Imutável Caractere *cmd = sol_optstring(L, 1, NULL);
  Inteiro stat;
  errno = 0;
  stat = l_system(cmd);
  Se (cmd != NULL)
    Retorne sol_execresult(L, stat);
  Senão {
    sol_pushboolean(L, stat);  /* true Se there is a shell */
    Retorne 1;
  }
}


Fixo Inteiro os_remove (sol_State *L) {
  Imutável Caractere *filename = sol_checkstring(L, 1);
  errno = 0;
  Retorne sol_fileresult(L, remove(filename) == 0, filename);
}


Fixo Inteiro os_rename (sol_State *L) {
  Imutável Caractere *fromname = sol_checkstring(L, 1);
  Imutável Caractere *toname = sol_checkstring(L, 2);
  errno = 0;
  Retorne sol_fileresult(L, rename(fromname, toname) == 0, NULL);
}


/* Cria um diretório */
Fixo Inteiro os_makedir (sol_State *L) {
  Imutável Caractere *dirname = sol_checkstring(L, 1);
  errno = 0;
  Retorne sol_fileresult(L, os_mkdir(dirname) == 0, dirname);
}


Fixo Inteiro os_tmpname (sol_State *L) {
  Caractere buff[SOL_TMPNAMBUFSIZE];
  Inteiro err;
  sol_tmpnam(buff, err);
  Se (l_unlikely(err))
    Retorne solL_error(L, "unable to generate a unique filename");
  sol_pushstring(L, buff);
  Retorne 1;
}


Fixo Inteiro os_getenv (sol_State *L) {
  sol_pushstring(L, getenv(sol_checkstring(L, 1)));  /* Se NULL push nil */
  Retorne 1;
}


Fixo Inteiro os_clock (sol_State *L) {
  sol_pushnumber(L, ((sol_Number)clock())/(sol_Number)CLOCKS_PER_SEC);
  Retorne 1;
}


/*
** {======================================================
** Time/Date operations
** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
**   wday=%w+1, yday=%j, isdst=? }
** =======================================================
*/

/*
** About the overflow check: an overflow cannot occur when time
** is represented by a sol_Integer, because either sol_Integer is
** large enough to represent all Inteiro fields or it is not large enough
** to represent a time that cause a field to overflow.  However, Se
** times are represented as doubles and sol_Integer is Inteiro, then the
** time 0x1.e1853b0d184f6p+55 would cause an overflow when adding 1900
** to compute the year.
*/
Fixo Vazio setfield (sol_State *L, Imutável Caractere *key, Inteiro value, Inteiro delta) {
  #Se (Definido(SOL_NUMTIME) && SOL_MAXINTEGER <= INT_MAX)
    Se (l_unlikely(value > SOL_MAXINTEGER - delta))
      solL_error(L, "field '%s' is out-of-bound", key);
  #FimSe
  sol_pushinteger(L, (sol_Integer)value + delta);
  sol_setfield(L, -2, key);
}


Fixo Vazio setboolfield (sol_State *L, Imutável Caractere *key, Inteiro value) {
  Se (value < 0)  /* undefined? */
    Retorne;  /* does not set field */
  sol_pushboolean(L, value);
  sol_setfield(L, -2, key);
}


/*
** Set all fields from structure 'tm' in the table on top of the stack
*/
Fixo Vazio setallfields (sol_State *L, Estrutura tm *stm) {
  setfield(L, "year", stm->tm_year, 1900);
  setfield(L, "month", stm->tm_mon, 1);
  setfield(L, "day", stm->tm_mday, 0);
  setfield(L, "hour", stm->tm_hour, 0);
  setfield(L, "min", stm->tm_min, 0);
  setfield(L, "sec", stm->tm_sec, 0);
  setfield(L, "yday", stm->tm_yday, 1);
  setfield(L, "wday", stm->tm_wday, 1);
  setboolfield(L, "isdst", stm->tm_isdst);
}


Fixo Inteiro getboolfield (sol_State *L, Imutável Caractere *key) {
  Inteiro res;
  res = (sol_getfield(L, -1, key) == SOL_TNIL) ? -1 : sol_toboolean(L, -1);
  sol_pop(L, 1);
  Retorne res;
}


Fixo Inteiro getfield (sol_State *L, Imutável Caractere *key, Inteiro d, Inteiro delta) {
  Inteiro isnum;
  Inteiro t = sol_getfield(L, -1, key);  /* get field and its type */
  sol_Integer res = sol_tointegerx(L, -1, &isnum);
  Se (!isnum) {  /* field is not an integer? */
    Se (l_unlikely(t != SOL_TNIL))  /* some other value? */
      Retorne solL_error(L, "field '%s' is not an integer", key);
    Senão Se (l_unlikely(d < 0))  /* absent field; no Padrão? */
      Retorne solL_error(L, "field '%s' missing in date table", key);
    res = d;
  }
  Senão {
    Se (!(res >= 0 ? res - delta <= INT_MAX : INT_MIN + delta <= res))
      Retorne solL_error(L, "field '%s' is out-of-bound", key);
    res -= delta;
  }
  sol_pop(L, 1);
  Retorne (Inteiro)res;
}


Fixo Imutável Caractere *checkoption (sol_State *L, Imutável Caractere *conv,
                                size_t convlen, Caractere *buff) {
  Imutável Caractere *option = SOL_STRFTIMEOPTIONS;
  Natural oplen = 1;  /* length of options being checked */
  Para (; *option != '\0' && oplen <= convlen; option += oplen) {
    Se (*option == '|')  /* next block? */
      oplen++;  /* will check options with next length (+1) */
    Senão Se (memcmp(conv, option, oplen) == 0) {  /* match? */
      memcpy(buff, conv, oplen);  /* copy valid option to buffer */
      buff[oplen] = '\0';
      Retorne conv + oplen;  /* Retorne next item */
    }
  }
  sol_argerror(L, 1,
    sol_pushfstring(L, "invalid conversion specifier '%%%s'", conv));
  Retorne conv;  /* to avoid warnings */
}


Fixo time_t l_checktime (sol_State *L, Inteiro arg) {
  l_timet t = l_gettime(L, arg);
  sol_argcheck(L, (time_t)t == t, arg, "time out-of-bounds");
  Retorne (time_t)t;
}


/* maximum size Para an individual 'strftime' item */
#Defina SIZETIMEFMT	250


Fixo Inteiro os_date (sol_State *L) {
  size_t slen;
  Imutável Caractere *s = sol_optlstring(L, 1, "%c", &slen);
  time_t t = sol_opt(L, l_checktime, 2, time(NULL));
  Imutável Caractere *se = s + slen;  /* 's' end */
  Estrutura tm tmr, *stm;
  Se (*s == '!') {  /* UTC? */
    stm = l_gmtime(&t, &tmr);
    s++;  /* skip '!' */
  }
  Senão
    stm = l_localtime(&t, &tmr);
  Se (stm == NULL)  /* invalid date? */
    Retorne solL_error(L,
                 "date result cannot be represented in this installation");
  Se (strcmp(s, "*t") == 0) {
    sol_createtable(L, 0, 9);  /* 9 = number of fields */
    setallfields(L, stm);
  }
  Senão {
    Caractere cc[4];  /* buffer Para individual conversion specifiers */
    sol_Buffer b;
    cc[0] = '%';
    sol_buffinit(L, &b);
    Enquanto (s < se) {
      Se (*s != '%')  /* not a conversion specifier? */
        sol_addchar(&b, *s++);
      Senão {
        size_t reslen;
        Caractere *buff = sol_prepbuffsize(&b, SIZETIMEFMT);
        s++;  /* skip '%' */
        /* copy specifier to 'cc' */
        s = checkoption(L, s, ct_diff2sz(se - s), cc + 1);
        reslen = strftime(buff, SIZETIMEFMT, cc, stm);
        sol_addsize(&b, reslen);
      }
    }
    sol_pushresult(&b);
  }
  Retorne 1;
}


Fixo Inteiro os_time (sol_State *L) {
  time_t t;
  Se (sol_isnoneornil(L, 1))  /* called without args? */
    t = time(NULL);  /* get current time */
  Senão {
    Estrutura tm ts;
    sol_checktype(L, 1, SOL_TTABLE);
    sol_settop(L, 1);  /* make sure table is at the top */
    ts.tm_year = getfield(L, "year", -1, 1900);
    ts.tm_mon = getfield(L, "month", -1, 1);
    ts.tm_mday = getfield(L, "day", -1, 0);
    ts.tm_hour = getfield(L, "hour", 12, 0);
    ts.tm_min = getfield(L, "min", 0, 0);
    ts.tm_sec = getfield(L, "sec", 0, 0);
    ts.tm_isdst = getboolfield(L, "isdst");
    t = mktime(&ts);
    setallfields(L, &ts);  /* update fields with normalized values */
  }
  Se (t != (time_t)(l_timet)t || t == (time_t)(-1))
    Retorne solL_error(L,
                  "time result cannot be represented in this installation");
  l_pushtime(L, t);
  Retorne 1;
}


Fixo Inteiro os_difftime (sol_State *L) {
  time_t t1 = l_checktime(L, 1);
  time_t t2 = l_checktime(L, 2);
  sol_pushnumber(L, (sol_Number)difftime(t1, t2));
  Retorne 1;
}

/* }====================================================== */


Fixo Inteiro os_setlocale (sol_State *L) {
  Fixo Imutável Inteiro cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
                      LC_NUMERIC, LC_TIME};
  Fixo Imutável Caractere *Imutável catnames[] = {"all", "collate", "ctype", "monetary",
     "numeric", "time", NULL};
  Imutável Caractere *l = sol_optstring(L, 1, NULL);
  Inteiro op = sol_checkoption(L, 2, "all", catnames);
  sol_pushstring(L, setlocale(cat[op], l));
  Retorne 1;
}


Fixo Inteiro os_exit (sol_State *L) {
  Inteiro status;
  Se (sol_isboolean(L, 1))
    status = (sol_toboolean(L, 1) ? EXIT_SUCCESS : EXIT_FAILURE);
  Senão
    status = (Inteiro)sol_optinteger(L, 1, EXIT_SUCCESS);
  Se (sol_toboolean(L, 2))
    sol_close(L);
  Se (L) exit(status);  /* 'Se' to avoid warnings Para unreachable 'Retorne' */
  Retorne 0;
}


Fixo Imutável sol_Reg syslib[] = {
  {"obtenha_relógio",     os_clock},
  {"obtenha_data",      os_date},
  {"calcule_diferença_tempo",  os_difftime},
  {"execute",   os_execute},
  {"saia",      os_exit},
  {"obtenha_variável_ambiente",    os_getenv},
  {"remova",    os_remove},
  {"renomeie",    os_rename},
  {"crie_pasta",  os_makedir},
  {"defina_localidade", os_setlocale},
  {"obtenha_tempo",      os_time},
  {"gere_nome_temporário",   os_tmpname},
  {NULL, NULL}
};

/* }====================================================== */



SOLMOD_API Inteiro solopen_os (sol_State *L) {
  sol_newlib(L, syslib);
  Retorne 1;
}

