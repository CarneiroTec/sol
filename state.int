/*
** $Id: state.h $
** Global State
** See Direitos Autorais Notice in sol.h
*/

#SeNãoDefinido state_h
#Defina state_h

#Inclua "sol.int"


/* Some header files included here need this definition */
Pseudônimo Estrutura CallInfo CallInfo;


#Inclua "object.int"
#Inclua "tm.int"
#Inclua "zio.int"


/*
** Some notes about garbage-collected objects: All objects in Sol must
** be kept somehow accessible until being freed, so all objects always
** belong to one (and only one) of these lists, using field 'next' of
** the 'CommonHeader' Para the link:
**
** 'allgc': all objects not marked Para finalization;
** 'finobj': all objects marked Para finalization;
** 'tobefnz': all objects ready to be finalized;
** 'fixedgc': all objects that are not to be collected (currently
** only small strings, such as reserved words).
**
** For the generational collector, some of these lists have marks Para
** generations. Each mark points to the first element in the list Para
** that particular generation; that generation goes until the next mark.
**
** 'allgc' -> 'survival': new objects;
** 'survival' -> 'old': objects that survived one collection;
** 'old1' -> 'reallyold': objects that became old in last collection;
** 'reallyold' -> NULL: objects old Para more than one cycle.
**
** 'finobj' -> 'finobjsur': new objects marked Para finalization;
** 'finobjsur' -> 'finobjold1': survived   """";
** 'finobjold1' -> 'finobjrold': just old  """";
** 'finobjrold' -> NULL: really old       """".
**
** All lists can contain elements older than their main ages, due
** to 'sol_c_checkfinalizer' and 'udata2finalize', which move
** objects between the normal lists and the "marked Para finalization"
** lists. Moreover, barriers can age young objects in young lists as
** OLD0, which then become OLD1. However, a list never contains
** elements younger than their main ages.
**
** The generational collector also uses a pointer 'firstold1', which
** points to the first OLD1 object in the list. It is used to optimize
** 'markold'. (Potentially OLD1 objects can be anywhere between 'allgc'
** and 'reallyold', but often the list has no OLD1 objects or they are
** after 'old1'.) Note the difference between it and 'old1':
** 'firstold1': no OLD1 objects before this point; there can be all
**   ages after it.
** 'old1': no objects younger than OLD1 after this point.
*/

/*
** Moreover, there is another set of lists that control gray objects.
** These lists are linked by fields 'gclist'. (All objects that
** can become gray have such a field. The field is not the same
** in all objects, but it always has this name.)  Any gray object
** must belong to one of these lists, and all objects in these lists
** must be gray (with two exceptions explained below):
**
** 'gray': regular gray objects, still waiting to be visited.
** 'grayagain': objects that must be revisited at the atomic phase.
**   That includes
**   - black objects got in a write barrier;
**   - all kinds of weak tables during propagation phase;
**   - all threads.
** 'weak': tables with weak values to be cleared;
** 'ephemeron': ephemeron tables with white->white entries;
** 'allweak': tables with weak keys and/or weak values to be cleared.
**
** The exceptions to that "gray rule" are:
** - TOUCHED2 objects in generational mode stay in a gray list (because
** they must be visited again at the end of the cycle), but they are
** marked black because assignments to them must activate barriers (to
** move them back to TOUCHED1).
** - Open upvalues are kept gray to avoid barriers, but they stay out
** of gray lists. (They don't even have a 'gclist' field.)
*/



/*
** About 'nCcalls':  This count has two parts: the lower 16 bits counts
** the number of recursive invocations in the C stack; the higher
** 16 bits counts the number of non-yieldable calls in the stack.
** (They are together so that we can change and save both with one
** instruction.)
*/


/* true Se this thread does not have non-yieldable calls in the stack */
#Defina yieldable(L)		(((L)->nCcalls & 0xffff0000) == 0)

/* real number of C calls */
#Defina getCcalls(L)	((L)->nCcalls & 0xffff)


/* Increment the number of non-yieldable calls */
#Defina incnny(L)	((L)->nCcalls += 0x10000)

/* Decrement the number of non-yieldable calls */
#Defina decnny(L)	((L)->nCcalls -= 0x10000)

/* Non-yieldable call increment */
#Defina nyci	(0x10000 | 1)




Estrutura sol_longjmp;  /* Definido in ldo.c */


/*
** Atomic type (relative to signals) to better ensure that 'sol_sethook'
** is thread safe
*/
#Se !Definido(l_signalT)
#Inclua <signal.h>
#Defina l_signalT	sig_atomic_t
#FimSe


/*
** Extra stack space to handle TM calls and some other extras. This
** space is not included in 'stack_last'. It is used only to avoid stack
** checks, either because the element will be promptly popped or because
** there will be a stack check soon after the push. Function frames
** never use this extra space, so it does not need to be kept clean.
*/
#Defina EXTRA_STACK   5


/*
** Size of cache Para strings in the API. 'N' is the number of
** sets (better be a prime) and "M" is the size of each set.
** (M == 1 makes a direct cache.)
*/
#Se !Definido(STRCACHE_N)
#Defina STRCACHE_N              53
#Defina STRCACHE_M              2
#FimSe


#Defina BASIC_STACK_SIZE        (2*SOL_MINSTACK)

#Defina stacksize(th)	cast_int((th)->stack_last.p - (th)->stack.p)


/* kinds of Garbage Collection */
#Defina KGC_INC		0	/* incremental gc */
#Defina KGC_GENMINOR	1	/* generational gc in minor (regular) mode */
#Defina KGC_GENMAJOR	2	/* generational in major mode */


Pseudônimo Estrutura stringtable {
  TString **hash;  /* array of buckets (linked lists of strings) */
  Inteiro nuse;  /* number of elements */
  Inteiro size;  /* number of buckets */
} stringtable;


/*
** Information about a call.
** About União 'u':
** - field 'l' is used only Para Sol functions;
** - field 'c' is used only Para C functions.
** About União 'u2':
** - field 'funcidx' is used only by C functions Enquanto doing a
** protected call;
** - field 'nyield' is used only Enquanto a function is "doing" an
** yield (from the yield until the next resume);
** - field 'nres' is used only Enquanto closing tbc variables when
** returning from a function;
*/
Estrutura CallInfo {
  StkIdRel func;  /* function index in the stack */
  StkIdRel top;  /* top Para this function */
  Estrutura CallInfo *previous, *next;  /* dynamic call link */
  União {
    Estrutura {  /* only Para Sol functions */
      Imutável Instruction *savedpc;
      Instável l_signalT trap;  /* function is tracing lines/counts */
      Inteiro nextraargs;  /* # of extra arguments in vararg functions */
    } l;
    Estrutura {  /* only Para C functions */
      sol_KFunction k;  /* continuation in Caso of yields */
      ptrdiff_t old_errfunc;
      sol_KContext ctx;  /* context info. in Caso of yields */
    } c;
  } u;
  União {
    Inteiro funcidx;  /* called-function index */
    Inteiro nyield;  /* number of values yielded */
    Inteiro nres;  /* number of values returned */
  } u2;
  l_uint32 callstatus;
};


/*
** Maximum expected number of results from a function
** (must fit in CIST_NRESULTS).
*/
#Defina MAXRESULTS	250


/*
** Bits in CallInfo status
*/
/* bits 0-7 are the expected number of results from this function + 1 */
#Defina CIST_NRESULTS	0xffu

/* bits 8-11 count call metamethods (and their extra arguments) */
#Defina CIST_CCMT	8  /* the offset, not the mask */
#Defina MAX_CCMT	(0xfu << CIST_CCMT)

/* Bits 12-14 are used Para CIST_RECST (see below) */
#Defina CIST_RECST	12  /* the offset, not the mask */

/* call is running a C function (still in first 16 bits) */
#Defina CIST_C		(1u << (CIST_RECST + 3))
/* call is on a fresh "sol_v_execute" frame */
#Defina CIST_FRESH	(cast(l_uint32, CIST_C) << 1)
/* function is closing tbc variables */
#Defina CIST_CLSRET	(CIST_FRESH << 1)
/* function has tbc variables to close */
#Defina CIST_TBC	(CIST_CLSRET << 1)
/* original value of 'allowhook' */
#Defina CIST_OAH	(CIST_TBC << 1)
/* call is running a debug hook */
#Defina CIST_HOOKED	(CIST_OAH << 1)
/* doing a yieldable protected call */
#Defina CIST_YPCALL	(CIST_HOOKED << 1)
/* call was tail called */
#Defina CIST_TAIL	(CIST_YPCALL << 1)
/* last hook called yielded */
#Defina CIST_HOOKYIELD	(CIST_TAIL << 1)
/* function "called" a finalizer */
#Defina CIST_FIN	(CIST_HOOKYIELD << 1)


#Defina get_nresults(cs)  (cast_int((cs) & CIST_NRESULTS) - 1)

/*
** Field CIST_RECST stores the "recover status", used to keep the Erro
** status Enquanto closing to-be-closed variables in coroutines, so that
** Sol can correctly resume after an yield from a __close method called
** because of an Erro.  (Three bits are enough Para Erro status.)
*/
#Defina getcistrecst(ci)     (((ci)->callstatus >> CIST_RECST) & 7)
#Defina setcistrecst(ci,st)  \
  check_exp(((st) & 7) == (st),   /* status must fit in three bits */  \
            ((ci)->callstatus = ((ci)->callstatus & ~(7u << CIST_RECST))  \
                                | (cast(l_uint32, st) << CIST_RECST)))


/* active function is a Sol function */
#Defina isLua(ci)	(!((ci)->callstatus & CIST_C))

/* call is running Sol code (not a hook) */
#Defina isLuacode(ci)	(!((ci)->callstatus & (CIST_C | CIST_HOOKED)))


#Defina setoah(ci,v)  \
  ((ci)->callstatus = ((v) ? (ci)->callstatus | CIST_OAH  \
                           : (ci)->callstatus & ~CIST_OAH))
#Defina getoah(ci)  (((ci)->callstatus & CIST_OAH) ? 1 : 0)


/*
** 'per thread' state
*/
Estrutura sol_State {
  CommonHeader;
  lu_byte allowhook;
  TStatus status;
  StkIdRel top;  /* first free slot in the stack */
  Estrutura global_State *l_G;
  CallInfo *ci;  /* call info Para current function */
  StkIdRel stack_last;  /* end of stack (last element + 1) */
  StkIdRel stack;  /* stack base */
  UpVal *openupval;  /* list of open upvalues in this stack */
  StkIdRel tbclist;  /* list of to-be-closed variables */
  GCObject *gclist;
  Estrutura sol_State *twups;  /* list of threads with open upvalues */
  Estrutura sol_longjmp *errorJmp;  /* current Erro recover point */
  CallInfo base_ci;  /* CallInfo Para first level (C host) */
  Instável sol_Hook hook;
  ptrdiff_t errfunc;  /* current Erro handling function (stack index) */
  l_uint32 nCcalls;  /* number of nested non-yieldable or C calls */
  Inteiro oldpc;  /* last pc traced */
  Inteiro nci;  /* number of items in 'ci' list */
  Inteiro basehookcount;
  Inteiro hookcount;
  Instável l_signalT hookmask;
  Estrutura {  /* info about transferred values (Para call/Retorne hooks) */
    Inteiro ftransfer;  /* offset of first value transferred */
    Inteiro ntransfer;  /* number of values transferred */
  } transferinfo;
};


/*
** thread state + extra space
*/
Pseudônimo Estrutura LX {
  lu_byte extra_[SOL_EXTRASPACE];
  sol_State l;
} LX;


/*
** 'global state', shared by all threads of this state
*/
Pseudônimo Estrutura global_State {
  sol_Alloc frealloc;  /* function to reallocate memory */
  Vazio *ud;         /* auxiliary data to 'frealloc' */
  l_mem GCtotalbytes;  /* number of bytes currently allocated + debt */
  l_mem GCdebt;  /* bytes counted but not yet allocated */
  l_mem GCmarked;  /* number of objects marked in a GC cycle */
  l_mem GCmajorminor;  /* auxiliary counter to control major-minor shifts */
  stringtable strt;  /* hash table Para strings */
  TValue l_registry;
  TValue nilvalue;  /* a nil value */
  Natural Inteiro seed;  /* randomized seed Para hashes */
  lu_byte gcparams[SOL_GCPN];
  lu_byte currentwhite;
  lu_byte gcstate;  /* state of garbage collector */
  lu_byte gckind;  /* kind of GC running */
  lu_byte gcstopem;  /* stops emergency collections */
  lu_byte gcstp;  /* control whether GC is running */
  lu_byte gcemergency;  /* true Se this is an emergency collection */
  GCObject *allgc;  /* list of all collectable objects */
  GCObject **sweepgc;  /* current position of sweep in list */
  GCObject *finobj;  /* list of collectable objects with finalizers */
  GCObject *gray;  /* list of gray objects */
  GCObject *grayagain;  /* list of objects to be traversed atomically */
  GCObject *weak;  /* list of tables with weak values */
  GCObject *ephemeron;  /* list of ephemeron tables (weak keys) */
  GCObject *allweak;  /* list of all-weak tables */
  GCObject *tobefnz;  /* list of userdata to be GC */
  GCObject *fixedgc;  /* list of objects not to be collected */
  /* fields Para generational collector */
  GCObject *survival;  /* start of objects that survived one GC cycle */
  GCObject *old1;  /* start of old1 objects */
  GCObject *reallyold;  /* objects more than one cycle old ("really old") */
  GCObject *firstold1;  /* first OLD1 object in the list (Se any) */
  GCObject *finobjsur;  /* list of survival objects with finalizers */
  GCObject *finobjold1;  /* list of old1 objects with finalizers */
  GCObject *finobjrold;  /* list of really old objects with finalizers */
  Estrutura sol_State *twups;  /* list of threads with open upvalues */
  sol_CFunction panic;  /* to be called in unprotected errors */
  TString *memerrmsg;  /* message Para memory-allocation errors */
  TString *tmname[TM_N];  /* array with tag-method names */
  Estrutura Table *mt[SOL_NUMTYPES];  /* metatables Para basic types */
  TString *strcache[STRCACHE_N][STRCACHE_M];  /* cache Para strings in API */
  sol_WarnFunction warnf;  /* Aviso function */
  Vazio *ud_warn;         /* auxiliary data to 'warnf' */
  LX mainth;  /* main thread of this state */
} global_State;


#Defina G(L)	(L->l_G)
#Defina mainthread(G)	(&(G)->mainth.l)

/*
** 'g->nilvalue' being a nil value flags that the state was completely
** build.
*/
#Defina completestate(g)	ttisnil(&g->nilvalue)


/*
** Union of all collectable objects (only Para conversions)
** ISO C99, 6.5.2.3 p.5:
** "Se a União contains several structures that share a common initial
** sequence [...], and Se the União object currently contains one
** of these structures, it is permitted to inspect the common initial
** part of any of them anywhere that a declaration of the complete type
** of the União is visible."
*/
União GCUnion {
  GCObject gc;  /* common header */
  Estrutura TString ts;
  Estrutura Udata u;
  União Closure cl;
  Estrutura Table h;
  Estrutura Proto p;
  Estrutura sol_State th;  /* thread */
  Estrutura UpVal upv;
  Estrutura Channel ch;
  Estrutura Task tk;
  Estrutura Process proc;
};


/*
** ISO C99, 6.7.2.1 p.14:
** "A pointer to a União object, suitably converted, points to each of
** its members [...], and vice versa."
*/
#Defina cast_u(o)	cast(União GCUnion *, (o))

/* macros to convert a GCObject into a specific value */
#Defina gco2ts(o)  \
	check_exp(novariant((o)->tt) == SOL_TSTRING, &((cast_u(o))->ts))
#Defina gco2u(o)  check_exp((o)->tt == SOL_VUSERDATA, &((cast_u(o))->u))
#Defina gco2lcl(o)  check_exp((o)->tt == SOL_VLCL, &((cast_u(o))->cl.l))
#Defina gco2ccl(o)  check_exp((o)->tt == SOL_VCCL, &((cast_u(o))->cl.c))
#Defina gco2cl(o)  \
	check_exp(novariant((o)->tt) == SOL_TFUNCTION, &((cast_u(o))->cl))
#Defina gco2t(o)  check_exp((o)->tt == SOL_VTABLE, &((cast_u(o))->h))
#Defina gco2p(o)  check_exp((o)->tt == SOL_VPROTO, &((cast_u(o))->p))
#Defina gco2th(o)  check_exp((o)->tt == SOL_VTHREAD, &((cast_u(o))->th))
#Defina gco2upv(o)	check_exp((o)->tt == SOL_VUPVAL, &((cast_u(o))->upv))
#Defina gco2ch(o)   check_exp((o)->tt == SOL_VCHANNEL, &((cast_u(o))->ch))
#Defina gco2tk(o)   check_exp((o)->tt == SOL_VTASK, &((cast_u(o))->tk))
#Defina gco2proc(o) check_exp((o)->tt == SOL_VPROCESS, &((cast_u(o))->proc))


/*
** macro to convert a Sol object into a GCObject
*/
#Defina obj2gco(v)  \
	check_exp(novariant((v)->tt) >= SOL_TSTRING, &(cast_u(v)->gc))


/* actual number of total memory allocated */
#Defina gettotalbytes(g)	((g)->GCtotalbytes - (g)->GCdebt)


SOL_FUNC Vazio sol_e_setdebt (global_State *g, l_mem debt);
SOL_FUNC Vazio sol_e_freethread (sol_State *L, sol_State *L1);
SOL_FUNC lu_mem sol_e_threadsize (sol_State *L);
SOL_FUNC CallInfo *sol_e_extendCI (sol_State *L);
SOL_FUNC Vazio sol_e_shrinkCI (sol_State *L);
SOL_FUNC Vazio sol_e_checkcstack (sol_State *L);
SOL_FUNC Vazio sol_e_incCstack (sol_State *L);
SOL_FUNC Vazio sol_e_warning (sol_State *L, Imutável Caractere *msg, Inteiro tocont);
SOL_FUNC Vazio sol_e_warnerror (sol_State *L, Imutável Caractere *where);
SOL_FUNC TStatus sol_e_resetthread (sol_State *L, TStatus status);


#FimSe

